## **“巨石”工作台**

快手的运营中台业务向上为直播、电商、磁力聚星、游戏、短剧等众多一线业务提供合作签约、促活促产、变现结算等多种高效的运营能力，向下促达无数快手内部运营和外部MCN机构、公会，以提供强功能性的桌面端Web工作台类型的产品为主。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnLnSUz1dqvK2tIx7mRiaaYPibSmCiaIJkwUmZ1qw2Jb1M4XUUkXyJEnVMw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

工作台系统在业界有多种意义相同或相近的别名，比如“CMS”、“Admin”、“中后台”、“控制台”、“管理系统”等，但无论以哪种名字出现，也不管是面向内部还是外部的，其视图的功能布局都是非常类似的。  

以我们的一个对外的“机构服务平台”为例，整个页面划分成三部分：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnue5MADR4xaTI0wRiajq4AEMpHpZ30a2KB2bk5kcCpbt0Sdibfhxiacsibw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

第一部分：**顶栏**，用于展现系统logo、系统名称、常驻操作入口等信息，大多以fixed布局固定在视窗顶部；

第二部分：**菜单栏**，一般位于左侧，在某些语言场景中也可以位于右侧，都是用作不同功能页面的导航，一般也是fixed布局固定在一侧；

第三部分：**功能区**，占据视窗的绝大部分空间，可上下左右滚动，顾名思义，用来展现系统的主要内容

**工作台**系统的初期建设在现代的技术条件下已经没有任何障碍，反而是中后期的大量功能堆叠，往往是通过添加大量代码实现的，久而久之这会带来几个显而易见的问题：

1.  **公共模块变更风险大，回归成本高昂**

2.  **不利于技术升级，影响面大**

3.  **不利于多团队开发共建，不能响应技术多样性**

4.  **发布成本高，整体编译发布慢**

总结来看，这就是“巨石（*monolithic*）应用”的几个典型特征，而该问题的解决方案也基本上固化了——前端微服务化，俗称”微前端（Micro-Frontend）“。

## **分治的微前端**

在多数业务场景中，往往在需要把不同时期、不同解决方案的多个子系统聚合到，以统一的门户向外提供服务之时，才想到利用微前端对解决方案的高度包容性这个特征。

和上面这种需要“聚合”的诉求正相反，快手运营中台真正遭遇到了巨石应用的困扰，进而推导出要利用微前端的“反聚合”特性，我们称之为“分治”。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnVe0aJFtghqiciaoZLYuvfSbRPdVgTEpVALbbCG2W8souOfBfU5xiasuQA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

“聚合”与“分治”辩证而统一，都可以用微前端来实现。虽然概念很简单，但对于Web来说，分治后的应用并非是线性组合的方式，而是需要一个中控模块来实现应用的生命周期，因而微前端架构下的应用都是树形结构的，最简单的是二层结构，但理论上可以支持无限层次：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnGZ9fMjxZh4IyYBfavkRNibbiclLdgxCOyO8H5q5FWS2bhmsC5qBwmXzA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

微前端架构是应用层的概念，浏览器对此一无所知，以上图为例，**子应用**的加载（mount）与卸载（unmount）都要由在同一个浏览器页面下的**主应用**来实现。

## **取舍：single-spa是什么**

***single-spa***几乎是任何微前端方案都无法回避的一个library。很多厂商实现的方案，事实上就是基于*single-spa*的。下面来简单分析*single-spa*的功能与不足。

### **路由**

来看*single-spa*的官网首页（https://single-spa.js.org/）：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnqaKXWQwGWLoGicISrdA6uLhJow18l5cT8ew2mBiapicQx6VtQTYicp6MZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

有这样一行副标题：

A javascript router for front-end microservices.

关键词：**router**。

这里可以参考vue/react-router的功能。工作台类型的应用中，功能区显示的内容是受浏览器地址栏的路由控制的，无论是通过代码编程、前进后退按钮还是点击a链接，都应该可以触发关联的子应用的挂载或者卸载。因此，single-spa的主要工作之一，便是**响应路由的变化来切换子应用**。

我们从它的API上便知——*activeWhen*函数用于计算子应用何时应该被挂载到页面上运行，反过来便是何时应该从页面上卸载。它有且只有一个参数，便是location，**因此一个应用被挂载还是卸载，只应取决于浏览器路由这唯一一个因素**。

微前端的交互特征决定了无论如何设计、无论是否使用*single-spa*，与路由之间的交互都是必不可少的，这几乎是微前端的标配能力之一。

### **状态机**

页面在响应用户的指令上是有矛盾的，即页面的路由几乎可以瞬间变化（同步），但是子应用的挂载/卸载却是一个有明显耗时的异步过程。

如果浏览器的路由快速变化，子应用应该如何响应呢？这明显是生产和消费之间的不均衡问题，下面来看两种极端方案：

1.  取消当前子应用，转而响应最新子应用；

2.  依次响应所有激活过的子应用

举一个例子，假设子应用A正在被挂载，因为耗时较长，用户点击了一个a链接，使得浏览器路由立刻发生了变化，导致子应用B应该被挂载，A应该被卸载。不过还未等B开始挂载，用户又快速点击另一个a链接跳到了新的路由，此时子应用C又应该被挂载。那么此时系统在卸载完A之后，应该立即挂载C呢，还是应该先挂载B、卸载B再挂载C呢？

显然挂载B这一环节已经没有意义，必须要有能力略过它。*single-spa*通过两种设计来实现这种效果。

首先，伴随着每一次路由变更，记录下所有需要挂载或者卸载的应用，作为一种需要消费的“报文”塞入一个队列当中，确保所有被影响到的应用都有被处理的机会，并且要以正确的次序被处理。例如从A切到C，必然是先卸载A再挂载C。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKn07TLeHvjfhVOuCaicXxvOIaxZBia54fpvj3ZibwkaZ1e5hLcpGLO4JLLg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

其次，处理“报文”，比如遇到「挂载B」这个指令，要判断是否真正要执行。因为队列中的所有待处理“报文”几乎全部都是异步的，生成它和处理它之间有一定的时间延迟，所以此时B可能应该被挂载，也可能已经过时不再需要被挂载。做法是检查一下当前的路由环境和应用B当前的状态，判断「挂载B」这个指令是否已经过时。

该检查需要用到B的状态，因为子应用有多个不同的异步阶段，能否继续执行下一个指令必然要参考其当前的状态，例如如果B允许被挂载，那么它当前必须处于“未挂载”状态——这就引出了状态机的概念。由此可知，***single-spa*****还负责监控每一个子应用的当前状态，根据状态限制某些非法的行为**。

在*single-spa*中，任何子应用都一定处于下列状态枚举中：

```
<span>NOT_LOADED</span>
```

每一个-ING都代表了子应用的一种异步阶段，通过对状态的追踪才能保证众多应用对于路由响应在时序上的正确性。

在上面这个例子中，显然「挂载B」的指令与当前location不符，而「卸载B」的指令与B的状态不符，它们都属于过时的指令，应当抛弃，进位到「挂载C」这个指令。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnictAo9ZJaAt3UmKGrPuKfrWGjAWPLmypLj1r76icKxibM5BSN01HQzgiaQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

因此，对于微前端来说，跟踪子应用的状态也是必不可少的，无论是否使用single-spa。

### **加载器**

加载与卸载，都是通过操纵子应用暴露出来的生命周期方法来实现的，也意味着主应用必须要在内存中能拿到子应用的接口函数，下面将接口函数的集合称为**接口对象**。

*single-spa*的官方示例中仅以dynamic import的方式来异步加载一个子应用的接口对象，该对象中包含了各个生命周期方法：bootstrap、mount、unmount。

```
<span>// single-spa-config.js</span>
```

上面这个例子相当于主应用已经提前知道了子应用的接口对象路径，并没有考虑子应用的非逻辑资源——CSS，这是不符合实际生产环境要求的。

正因为如此，依赖*single-spa*的微前端方案都不约而同地实现了自己的加载器，让主应用有能力发现并加载一个完整的子应用，包括它的JS和CSS。**适用于生产环境的加载器的缺失是这些方案基于*single-spa*但又要做一层封装的最主要原因之一**。

## 微前端设计

### **关于微前端设计，你应该考虑到的**

快手运营中台的微前端方案目前也是基于*single-spa*来搭建的，以复用其路由和状态机这些基础能力，并同样定制了自己的加载器。本章节来讨论基础功能之外的一些实际生产环境需求细节，涉及到可持续性、健壮性、安全性、性能、生产效率等各种各样的边界场景。

### **如何描述子应用**

业界常见的一种实践是子应用向主应用暴露一个HTML地址，称之为“*HTML Entry*”。这种方案通常应用在有历史包袱的业务场景中，比如需要把已经存在的几个系统聚合起来，向外提供统一入口，而各自还能继续独立运行。

该HTML包含了子应用能够运行起来的两个必备要素——JS和CSS。于是，主应用不得不具备解析HTML以及提取其中CSS和JS的能力。这需要一定的计算成本以及对HTML内容的约束，不是任意HTML都可以被作为“*HTML Entry*”。因此**使用HTML作为子应用的入口，应该是一种折衷而非特性**。

更简单的方法是把HTML换成结构化更强、语义化更明确的格式，比如JSON。于是，我们让子应用各自生成一个JSON文件，来发挥HTML同样的功效：

```
<span>// assets-map.json</span>
```

这个JSON文件会被部署到生产环境中，拥有固定的URL。这样主应用就可以轻松地请求和解析它，拿到子应用的全部静态资源路径。我们称此文件为“资源映射表（Assets Map）”。

在主应用中，还需要配置一个规则，把子应用的名称映射到其资源映射表的地址，可以用一个Map，例如：

```
<span>// sub-apps.json</span>
```

也可以做一个统一的映射规则：

```
<span>assetsMapURL = `/assets-map/${appName}.json`;</span>
```

区别仅仅是反向代理的配置规则不同而已，具体实现起来灵活度很大。如果CORS配置好的话，资源表地址与页面不在同域也是允许的。

### **如何加载资源**

资源映射表是子应用的“敲门砖”，距离主应用成功启动一个子应用，只差「下载其CSS/JS静态资源」，以及「调用其生命周期函数」这两步。

现在来讨论如何动态下载CSS和JS，下面是业界已有的两种方案。

#### **Ajax请求**

很多微前端方案都要求子应用的JS和CSS的URL是可跨域的，就是因为它们下载资源的方式是Ajax——先异步请求（用XMLHttpRequest或者fetch）到源代码，然后对于CSS就创建一个style标签，注入CSS代码进去；对于JS就把动态执行（利用eval或Function），相当于分别模拟了link标签和script标签的功能。

这样做的目的，至少有两方面：

-   第一，对于CSS，可以轻易实现enabled/disabled，这在切换子应用时是必要的；对于JS，一旦报错可以实现简单重试；

-   第二，也是最重要的，可以实现沙箱（sandbox）机制——这是很多微前端方案宣传的最重要亮点之一。

关于沙箱，在后文“如何看待‘沙箱’”的章节还会继续讨论，下面先来分析Ajax加载静态资源的潜在弊端。

首先，代码不再依附于link或script标签运行，一旦解析或运行报错，浏览器将不能把错误堆栈索引到真正的资源路径上，这对于诊断报错将带来一定的障碍。

其次，无论是CSS还是JS，都非常有可能存在对其它资源的相对路径引用，例如CSS引用图片、字体，JS用dynamic import引用其它ESM，上面的做法相当于破坏了入口资源的位置，必然将影响到对引用资源的加载，极易导致404错误。

如果不考虑对沙箱的诉求，上面两个问题是没有优雅且简单的方法来解决的，那么可以考虑使用更简单的标签请求方式。

#### **标签请求**

这种模式尊重浏览器原生加载资源的方式，创建link标签和script标签，让浏览器来管理资源的请求、执行，其结果可以通过onload和onerror来获取。

这样做不受跨域的限制，也保留了原有的错误定位能力和引用资源加载能力，不过缺点也比较明显：

-   第一，无法支持沙箱；

-   第二，一旦出错难以重试

对于第二个问题，我们业务的策略是一旦子应用的CSS出错（即style标签onerror），通过删除标签再重建的方式来进行有限次数的重试；一旦JS出错（即script标签onerror），直接标记该子应用启动失败且永远失败。

这种方式对于实现CSS的enabled/disabled并没有阻碍，可以直接删除<link>标签来实现disabled、重建标签来实现enabled。由于标签重建后CSS的请求几乎一定是from cache，所以速度上可以接受。另一种稳妥的方案是通过修改<link>标签的type或rel属性为合法/非法值来实现enabled/disabled切换。

以上两种方案各有优劣，可以做一层封装，向外暴露抽象后的API，自由选择具体的请求方式。此外，JS和CSS应该做并行加载，能显著节约一些阻塞的时间。

#### **Async vs Initial**

以dynamic import为典型的写法常用做代码的拆分，来尽可能降低页面首次载入的资源体积。以webpack环境为例，页面一打开就会加载的JS/CSS资源，称之为*initial chunk*，按需异步加载的叫做*async chunk*。

*async chunk*是由*initial chunk*自动加载的，并不需要人为干预。于是有这样一个推论，无论使用Ajax请求还是标签请求，请求的都是*initial chunk*，不包括*async chunk*。

但*async chunk*仍然有必要被主应用感知，至少CSS是必要的，因为**子应用在卸载时，主应用需要负责清理其包括initial和async在内的全部资源**。

鉴于此，需要改进资源映射表的格式，体现出inital和async的区别：

```
<span>{</span>
```

对于vite来说，虽然其没有明确的*initial chunk*概念，但仍然有同步/异步资源的区别，也能够契合上面的格式。

#### **如何运行JS**

上面一节讨论了资源加载的途径问题，接下来来看如何发起资源加载。

CSS不在讨论范围内，无论使用Ajax请求还是标签请求，都是按照其initial部分的顺序来依次插入HTML中，没有争议。

JS不尽然，从模块化的格式上有AMD、CJS、UMD、ESM等多种之分，加载方法不尽相同。下面以其中的两个典型为例，UMD和ESM，来讨论如何运行这两种格式的代码，得到暴露给主应用的生命周期接口对象。

#### **UMD**

UMD因为可以兼顾独立运行和嵌入运行，是微前端方案中应用得最广的。它可以被编译成多个独立的JS文件，但其它的都是作为依赖而存在，唯独最后一个才是入口（Entry）。

因此无论是Ajax请求还是标签请求，时序都是先并发加载前N-1个JS，再加载最后一个JS，伪代码如下：

```
<span>await Promise.all(src.slice(0, -1).map(script =&gt; fetchAndExecScript(script)));</span>
```

对于Ajax请求来说，拿到JS源码后，调用eval（或类似方法）即可完成代码的执行，在这个过程中，注入一些上下文变量，就实现了沙箱的功能。

可以参考SystemJS的实现（详见https://github.com/systemjs/systemjs/blob/main/src/extras/global.js）来获取暴露出来的接口对象，其原理不再赘述，有一定的失败概率，更安全的方式是使用ESM。

#### **ESM**

ESM格式更简单，语义更清晰，且已经被现代浏览器所广泛支持。只需要发起对入口（Entry）JS文件的请求，浏览器就能够处理其背后的所有依赖关系，操作复杂度上要比UMD更简单。

入口文件依然可以使用标签请求的方式，但是相比于动态创建一个script type="module"标签，有更简单也更健壮的办法：

```
<span>import(entryJS).then(...)</span>
```

这依赖浏览器原生的dynamic import能力，需要特别关注的是这种写法非常容易被webpack或者vite误伤，因此需要加上两个“魔法注释（magic comments）”：

```
<span>import(/* @vite-ignore */ /* webpackIgnore: true */entryJS).then(...)</span>
```

也可以使用Ajax来请求ESM，不过其代码要转换成*data URI*才能执行：

```
<span>const js = `export const message='HelloWorld'`;</span>
```

显然ESM格式的代码是没有途径去注入上下文变量的，因此杜绝了ESM实现沙箱的可能性。既然如此，Ajax请求JS源码转换成data URI再dynamic import的方式就显得多此一举。

## **如何看待“沙箱”**

“沙箱”是一个比较敏感的话题，它的作用自然是想规避JS/CSS的全局冲突。不过比较遗憾，**在目前的浏览器技术条件下，实现100%安全的沙箱是不可能的**。

### **JS沙箱**

目前业界流行的JS沙箱机制都是使用Proxy对window、globalThis等常见全局对象做一层包装，然后再以Function（或类似方案）的方式执行子应用的代码，这样在子应用卸载时便可以清理被污染的全局对象。

因为能够访问到的全局变量几乎不可枚举，只代理这有限的几个对象难以称之为安全。而且，子应用污染全局的方式也不限于在这几个全局对象上挂载变量，也可能通过它们的多层后代来污染，因此Proxy根本无法做到足够完备的隔离效果。

而且，**无论沙箱机制实现得多么先进，也只能处理同步代码，对于异步代码则难以招架**。如果一定要做，可以尝试在Service Worker下代理JS代码的请求，做适当修改，以注入必要的代理对象。理论上可行，但实现起来可能有一些复杂。

另一种思路是自定义浏览器创建script标签的能力，进而能够控制真正被执行JS的代码。简单来说就是JS调用浏览器API（如createElement）来动态创建script标签时，实际上是「Ajax请求JS源码」——「修改代码」——「eval执行」这样一个过程。其中覆盖浏览器原生API的做法，也许会带来一些意外的副作用。

以上讨论都是针对UMD格式，如果**对于ESM格式的子应用，由于import/export只能作用于最外层，无法再用函数包裹注入上下文变量，便无法实现沙箱**。

### **CSS沙箱**

除了JS外，实现CSS的沙箱机制还是相对简单的，但需要对CSS代码进行复杂的解析和重构，其中对容错性、耗时的考量，需要进一步斟酌。而且也无法对keyframes动画起作用。

#### **预加载**

回顾子应用的启动流程，如下图：

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640.png)

1.  主应用请求子应用的资源映射表；

2.  主应用加载子应用的静态资源，拿到生命周期接口对象；

3.  主应用从接口对象中获取bootstrap、mount生命周期方法，依次调用。

如果主应用事先能获取各个子应用的资源映射表内容，那么第一步就是可省略的，进而也能节省一次HTTP请求。

但第二步无法省略，子应用的资源不可能全部被提前载入。往往都是由于路由的变动，激活相关子应用，再去加载其CSS/JS资源。

不过完全有可能存在部分子应用被激活的概率很高的场景，这种情况可以将该子应用设置为预加载（prefetch）模式，以提升其响应速度。具体做法是先把资源请求发出去，甚至可以拿到接口对象。这样在子应用真正被激活的时候，几乎可以立即调用bootstrap、mount完成启动。这其中必然要涉及到对资源的异步状态的监控和缓存，但原理显而易见，不再赘述。

#### **释放**

此处释放并非指子应用的卸载，只要主应用的环境还在，子应用的卸载就没有任何难度。这里指的是整个微前端环境的释放，包括子应用也包括主应用。

常规的基于微前端架构的应用，通常都是顶层框架中实现主应用，其在浏览器页面的生命周期中是常驻的，不需要考虑资源释放。

设想这样一个特殊场景，vue-router位于应用程序的最顶层，在其中一个路由页面中去创建主应用。一旦路由发生跳转，这个主应用连带其下面的子应用都应该被清理释放。实现这一功能要考虑子应用的状态。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161318157.png)

如果当前应该被激活的子应用已经完成了挂载，这是最简单的场景。single-spa已经提供了一个叫做unregisterApplication的方法，其中除了反注册之外，也能够对该子应用执行从DOM上卸载的操作。但至少还有两件事是single-spa处理不了的：

-   第一，子应用的JS已经被加载执行完了，如果有沙箱，需要释放沙箱。为了在子应用下次再启动时复用上次已经加载好的接口对象，需要设定一个缓存池，把子应用的接口对象放进去；

-   第二，子应用的CSS，包括initial部分和async部分，已经挂载到HTML中的，都应该被移除。

以上是对已经挂载的子应用的处理，总体看上去还是可预期、易操作的。但是前面也提到过，子应用是由状态机控制的，其处于不同状态时，清理它的操作也不尽相同，为了能尽快中断当前子应用的异步操作，完成资源清理和释放，就不得不遍历其状态，设计有针对性的措施。

既然single-spa已经记录了子应用的状态，直接查询即可。只有这几个异步状态需要关心：LOADING_SOURCE_CODE、BOOTSTRAPPING、MOUNTING，分别是正在请求资源映射表或下载静态资源、启动中、挂载中。对这些状态的处理方法基本上一致，即尽快抛出异常实现退出。

比如发现子应用当前正处于BOOTSTRAPPING状态，那么就需要在bootstrap完成后，立即抛出异常，阻止继续进入MOUNTING状态。以此类推：

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161333803.png)

以上场景仍然不是最复杂的，还需要考察用户真实使用场景下的各种非预期性动作。比如主应用由于上层路由变更的关系而正在执行释放操作，而用户又快速点击链接，让浏览器的路由又跳了回来，即刚刚还没来得及完成释放的主应用又要重新初始化，如何在保证数据一致性的前提下尽可能提高效率是一个关键的问题。

single-spa在这种场景中还是有一定的局限性的。首先single-spa是单例模式，不允许反复初始化；其次single-spa没有提供与start对应的方法，这意味着一旦single-spa开始运行就停不下来，会在一定程度上污染当前的浏览器页面环境。比如对pushState、replaceState、addEventListener、removeEventListener等原生方法的覆写、全局监听的事件等等，都没有方法来回位。

为了主应用能够在频繁无规律的启动、释放事件中保证状态的正确性，必然要对其设置全局的状态暂存区，用来保存子应用的释放状态，这里的释放要定义成停止当前异步操作——卸载——移除样式等一系列操作。

例如，在window对象上设置固定变量 __APP_STATE = { }，如果子应用A正在释放，设置__APP_STATE.A.releasing=true。当路由反复流转，A又需要被激活时，检查发现其正在释放过程中，那么就必须等到其完成释放再重新进行启动或挂载。

除了子应用的释放状态应该被记录外，同样的道理，主应用也需要在下次被重新启动前，等待上一次的释放完成。至于主应用如何在状态暂存区中找到“前世”的数据，有多种手段，比如在应用程序的宏观层面保证可控的主应用名称，以名称来判定是否是同一个主应用。

在浏览器这种单线程的环境下，资源释放的紧迫性，并不能被很及时地处理，因为一旦有阻塞式任务，将很难快速退出，进而带来明显的资源释放时延，而这种时延又会明显增加应用下一次启动的时间。

这种冲突完全是由于在同一个浏览器页面下支持应用反复重启带来的资源分配和释放问题导致的，作为类比，同一台电脑上，操作系统只启动一次，就可以支持同一个应用程序反复启动和关闭无数次，如何保证应用状态的一致性以及避免内存泄漏就是客观存在的问题。

操作系统上一般都会有类似“资源管理器”的功能，用来统一负责代理对数据状态、数据缓存等的各种访问诉求。同样的道理，我们也设计了类似的一个中间层，无论上层的路由如何频繁地驱动应用的反复重启，底层资源的异步操作一致性不受影响。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161351354.png)

这种做法不是万能的，它最多能保证状态的一致性，但不能保证及时性。

#### **嵌套**

嵌套是指微前端的子应用当中再创建一个微前端主应用，理论上随着子应用的颗粒化程度的加深，嵌套可能存在多个层级。

受到运行原理的限制，同一个页面下只能存在一个single-spa实例，那么即使存在多个主应用之间的嵌套，那么也必须使用同一个single-spa实例的API。这个实例的代码如何引入便成为了问题。

如果在应用程序顶层统一引入一个single-spa.js，就破坏了各级主应用之间的独立性，它们将无法独立启动，至少存在着对single-spa版本的依赖耦合。如果各级主应用独立引入自己的single-spa，那么将需要沙箱来保证隔离性，而前面已经论证过，沙箱在某些场景下是无法实现的，比如ESM。

在各种各样的条件束缚之下，我们目前没有对嵌套表示明确支持，需要这种特性的业务必须舍弃一定的独立性来间接实现。

#### **跨应用跳转**

一般来说，在子应用内部都会有vue/react-router，负责在子应用内部跳转，无论怎么跳转，都在该子应用声明的activeWhen实现范围内。比如：

```
<span>foo.activeWhen = <span>(<span>location</span>) =&gt;</span> location.pathname.startsWith(<span>/\/foo\//</span>);</span>
```

上面是典型的activeWhen实现，意思就是只要浏览器路由是以/foo/开头，就激活子应用foo。在foo内部，可以声明一个base为/foo/的vue-router：

```
<span><span>new</span> <span>Router</span>({</span>
```

只要路由在此范围内跳转，顶层的single-spa不需要有任何反应，因为跳转的前后，子应用没有发生变化。在子应用内部，可以使用router-link或者router.push/replace来执行编程跳转。

但路由跳转一旦超过了该vue/react-router实例的控制范围，比如从/foo/home跳转到/bar/home，仅仅调用vue/react-router实例的API已经无法完成导航，必须要通知到single-spa这一层来切换子应用，就只能通过history API来实现（在hash模式下也可以用a链接）。

作为业务来讲，时刻需要关注根据跳转目标地址来选择跳转方法，显然是不可接受的，必须有一种方法来抹平跳转目的地不同带来的跳转方法差异性。我们的实践是，把全部跳转请求都派给vue/react-router，利用兜底机制来实现“冒泡”通知。

举例来说，在vue-router的实例中，定义一个“*”匹配规则：

```
<span>{</span>
```

所有未被匹配的路由都会落到这条规则上，然后转换成对history API的调用，从而实现跨应用跳转。

**keep-alive**

keep-alive是vue中的一个重要内置组件，特别是在与vue-router配合时，能营造出一种“视图缓存”的效果，在路由回转时能够提高渲染效率。

在微前端场景中，keep-alive应该是子应用的一种属性，即不执行真正的卸载（除非其主应用也要卸载），只是暂时不展现。

所有的子应用都是通过其mount生命周期方法来挂载到主应用提供的一个DOM元素上的，我们称之为根（root）元素。通常来说，工作台应用程序只需要一个根元素，因为同一时刻始终都只有一个子应用填充在功能区。

keep-alive代表着一种缓存属性，如果存在设定为keep-alive的子应用，当它被“卸载”后，下一个子应用想启动就必须挂载到一个新的根元素上，这个元素需要主应用负责创建和销毁。

如果不想动态创建新的根元素，一种办法是把keep-alive子应用的DOM元素从根元素中移出暂存起来，用的时候再移回来，不过这样就会影响子应用创建的DOM树的路径。

无论哪种方式，被“卸载”的keep-alive子应用，其CSS都应该被移除或禁用掉，以避免与现在被激活的子应用发生样式冲突。

#### **公共依赖**

有这样一种需求，子应用依赖某一个拥有独立URL的library，比如vue.js，且被声明在资源映射表中，这带来一个问题：这种library一般是UMD导出，如果不同子应用依赖相同library，重复加载会导致全局对象混乱。同样是vue.js，全局对象window.Vue的相互覆盖会丢失原型链上挂载的数据，如果版本不同，则还可能造成运行时的致命错误。

在没有沙箱的环境下，这种全局冲突需要一定的规则来约束，这里我们提出一种由主应用统一管理的公共依赖的概念。

在主应用中配置各个子应用时，同时声明一系列公共依赖资源，可以是CSS也可以是JS。子应用可以依赖其中一个或几个，也可以不依赖。一旦主应用感知到有子应用要启动，就要首先检查其声明的公共依赖是否有加载，这里要区分四种状态：未加载、加载中、加载成功、加载失败。

显然这里也需要一个资源管理器，集中管理公共依赖资源。不过依然不允许公共依赖中存在两个及以上相同功能的不同版本。

## **冲突调和，成本与时效**

微前端除了在运行时原理上带来很大的革新之外，也间接影响到了线下的开发模式、安全、部署等相关工具和流程。

### **冲突探测**

在前文中已经提到，沙箱不能实现100%的隔离性，冲突依然有可能发生。很多全局冲突都难以发现，不过针对其中一部分还是能够做一些预警工作。在快手运营中台的实践中，我们针对其中一种简单的场景——JS变量覆盖冲突，实现了一种静态分析工具，其主要构成部分是一个eslint插件。

其工作原理也相当简单，当它发现JS中有针对全局变量的读写操作便会发出预警，例如以下代码，都属于有冲突风险的：

```
<span><span>window</span><span>.foo</span></span>
```

哪些全局变量的访问方式会被认为有风险是可配置的。这样即便是有很多老旧代码，还是能够实现对其中可能引起全局冲突的写法有一定的预期，并非完全失控。

未来我们还将对Vue组件中非scoped的样式代码作出类似的预警。

### **联合开发**

子应用能否以所见即所得的方式进行高效的本地开发调试，是微前端架构下必须要解决的线下问题之一。

对于工作台这类应用，其完整视图分属在主/子应用当中——顶栏和左侧菜单栏属于主应用，构成一个“「”型框架，子应用位于功能区嵌入其中。接下来要解决在本地环境中单独调试开发子应用，其视图如何装载到主应用框架中的问题。

我们过去的实践是，在源码层面上对这一部分视图框架进行抽离，命名为“foundation”。它会被主应用和子应用分别依赖，主应用以prod方式依赖它，需要把其打包上线，而子应用是以dev方式，只需在本地开发调试时才需要编译，最终上线时并不需要打包。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161411711.png)

该方案相对容易实现，唯一值得诟病的就是迭代麻烦，例如一旦foundation代码更新，需要主应用和众多子应用项目分别升级。

随着技术方案的演进，这种做法还会逐渐遭遇更严重的问题，甚至变得不可实现，因为子应用在源码层面依赖foundation，这就需要它们有一致的技术方案，比如要么都是React，要么都是Vue2或者都是Vue3。现在假设部分子应用从Vue2升级到Vue3，就要求foundation也要升级到Vue3。但此时可能还有其它子应用在使用Vue2版本，于是不得不同时维护foundation的两种版本，直到所有子应用全部升级完成，这会让子应用的独立维护变得缺乏自由。如果不同子应用由不同团队来维护，还会增加一定的沟通协调成本。

考虑到这种耦合带来的不便，我们开始逐渐实现**运行时动态依赖方案**——简单来说，就是子应用不再从源码层面上依赖foundation，而是动态将主应用运行在本地开发环境。这种操作并非要把主应用的源码同步到子应用中再启动，而是直接代理本地浏览器的HTML到远程的一个在线部署的主应用的HTML，另外再代理其对当前子应用资源表的请求（其它请求均默认放行）到本地，流程原理如下图：

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161511091.png)

 各种资源的代理穿透流向如下：

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161526188.png)

在此方案下，只要有一个稳定部署的主应用，便可以用来给全部子应用的开发调试共同使用，不存在技术方案的耦合性。即便主应用是React，子应用是Vue也完全可以支持。

在实际业务场景中还有更复杂的需求是本文没有讨论到的，比如在本地共同开发主应用和几个子应用，如何将它们聚合在一个浏览器页面当中来体验，是我们目前还没有完全解决的问题。未来我们会提供工具让散落在不同端口的服务智能地组装到一起，来降低复杂业务场景下的开发难度。

### **映射表生成**

资源映射表承载所有的静态资源路径，包括JS和CSS，如前讨论，要区分async和initial两种分类。理论上可以输出成任何结构化格式，当然最常用的还是JSON。

我们针对webpack环境和vite环境分别开发了两个插件，插件不是简单的把编译结果写到磁盘文件中，而是要写到内存文件中，这样即使在开发调试阶段，浏览器也能时刻读取到最新的资源映射表。

### **映射表配置化**

在典型的生产环境部署中，子应用的全部静态资源都被发送到了CDN上，部署在IDC上的几乎就只有资源映射表这一个文件。对于业界常用的容器部署环境，即便一个文件也仍然要占用至少一个容器实例，其CPU、内存、磁盘等资源被严重浪费。

通过优化子应用的部署方式，甚至能够节省出90%的IDC资源。我们设计了一个**主-子应用映射管理系统**（Asset Management System，以下简称*AMS*）。该系统通过对外暴露接口的方式，允许主应用读取到各子应用的资源映射表地址，而该地址不再像以前那样部署在IDC上，而是在CDN上，虽然有一些跨域要求，但配置难度小，可行性很高。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161604630.png)

此方案相当于集中维护了各个子应用的资源映射表地址，不再各自单独部署服务来提供。这样显然能够大幅优化资源占用，只需要少量的存储和计算资源。

该系统的存在还有一个优势，在过去想回滚一个子应用的代码，最少也需要重新部署一次，消耗数分钟的时间。现在只需要在*AMS*系统上调整配置，向主应用输出旧版本的资源映射表即可，数秒内即可完成切换。

对*AMS*的访问增加了一次HTTP请求的开销，但也是可以优化的。例如将其与现有的业务接口合并，或者让*AMS*直接维护资源映射表的内容而不是路径，不再赘述。

### **渐进演进**

虽然实施微前端的目标是解决“巨石应用”等问题，然而在实际等场景中，一个系统从开始建设的时候，常常并不能准确地看到它未来的规模，无法预知到它演变为“巨石应用”的可能性。

如果在技术上不加区分地直接以完整的微前端方案来实施，相比于业务规模则引入了过量的复杂性，影响系统建设初期的效率；如果完全不考虑，未来在拆解成微前端架构时，则会牵一发而动全身。

我们在微前端方案的设计上，实现了一种渐进式的折衷方案，实际编码体验与纯粹的微前端架构等同，有主应用和子应用的概念，每个子应用有独立的目录，有自己的router实例，也要考虑子应用之间的跳转方法。但是，整个项目实际上是一个SPA应用，不仅代码是在一起的，最终也是一同编译、一同部署的。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161739407.png)

虽然和真正的微前端托管方式还有不少的差别，比如依赖是共享的等，但是已经相当接近，只要系统有需要被改造成真正的微前端架构，那么仅需要把各个子应用目录拷贝出去，“自立门户”即可，在源代码层面几乎不需要有太多的修改，从而让本来具有较大成本和风险的重构工作，变得轻而易举。

以这样一种渐进式演进的微前端方案，我们有信心保证一个新的业务在两三年内稳定、高效地迭代开发。

## **成效，前景与展望**

快手运营中台以工作台类业务为主要对象，针对支持团队众多、成员流动性大、业务场景复杂、可维护性要求高等特点，实现了一套可移植的微前端方案，有效解决或者优化了前叙问题，但仍有许多feature缺失和不足。

未来，我们计划首先仍然是夯实现有方案的普适性、健壮性，补齐缺失的部分，比如联合开发的体验和效率问题、应用的嵌套问题、资源的释放问题；其次是面向未来探索更具标准化的解决方案，比如WebComponents在微前端上的应用等等；最后是以此为契机，间接地推动业务工程的技术演进，比如ESM的推广。
