## **“巨石”工作台**

快手的运营中台业务向上为直播、电商、磁力聚星、游戏、短剧等众多一线业务提供合作签约、促活促产、变现结算等多种高效的运营能力，向下促达无数快手内部运营和外部MCN机构、公会，以提供强功能性的桌面端Web工作台类型的产品为主。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnLnSUz1dqvK2tIx7mRiaaYPibSmCiaIJkwUmZ1qw2Jb1M4XUUkXyJEnVMw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

工作台系统在业界有多种意义相同或相近的别名，比如“CMS”、“Admin”、“中后台”、“控制台”、“管理系统”等，但无论以哪种名字出现，也不管是面向内部还是外部的，其视图的功能布局都是非常类似的。  

以我们的一个对外的“机构服务平台”为例，整个页面划分成三部分：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnue5MADR4xaTI0wRiajq4AEMpHpZ30a2KB2bk5kcCpbt0Sdibfhxiacsibw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

第一部分：**顶栏**，用于展现系统logo、系统名称、常驻操作入口等信息，大多以fixed布局固定在视窗顶部；

第二部分：**菜单栏**，一般位于左侧，在某些语言场景中也可以位于右侧，都是用作不同功能页面的导航，一般也是fixed布局固定在一侧；

第三部分：**功能区**，占据视窗的绝大部分空间，可上下左右滚动，顾名思义，用来展现系统的主要内容

**工作台**系统的初期建设在现代的技术条件下已经没有任何障碍，反而是中后期的大量功能堆叠，往往是通过添加大量代码实现的，久而久之这会带来几个显而易见的问题：

1.  **公共模块变更风险大，回归成本高昂**

2.  **不利于技术升级，影响面大**

3.  **不利于多团队开发共建，不能响应技术多样性**

4.  **发布成本高，整体编译发布慢**

总结来看，这就是“巨石（*monolithic*）应用”的几个典型特征，而该问题的解决方案也基本上固化了——前端微服务化，俗称”微前端（Micro-Frontend）“。

## **分治的微前端**

在多数业务场景中，往往在需要把不同时期、不同解决方案的多个子系统聚合到，以统一的门户向外提供服务之时，才想到利用微前端对解决方案的高度包容性这个特征。

和上面这种需要“聚合”的诉求正相反，快手运营中台真正遭遇到了巨石应用的困扰，进而推导出要利用微前端的“反聚合”特性，我们称之为“分治”。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnVe0aJFtghqiciaoZLYuvfSbRPdVgTEpVALbbCG2W8souOfBfU5xiasuQA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

“聚合”与“分治”辩证而统一，都可以用微前端来实现。虽然概念很简单，但对于Web来说，分治后的应用并非是线性组合的方式，而是需要一个中控模块来实现应用的生命周期，因而微前端架构下的应用都是树形结构的，最简单的是二层结构，但理论上可以支持无限层次：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnGZ9fMjxZh4IyYBfavkRNibbiclLdgxCOyO8H5q5FWS2bhmsC5qBwmXzA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

微前端架构是应用层的概念，浏览器对此一无所知，以上图为例，**子应用**的加载（mount）与卸载（unmount）都要由在同一个浏览器页面下的**主应用**来实现。

## **取舍：single-spa是什么**

***single-spa***几乎是任何微前端方案都无法回避的一个library。很多厂商实现的方案，事实上就是基于*single-spa*的。下面来简单分析*single-spa*的功能与不足。

### **路由**

来看*single-spa*的官网首页（https://single-spa.js.org/）：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnqaKXWQwGWLoGicISrdA6uLhJow18l5cT8ew2mBiapicQx6VtQTYicp6MZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

有这样一行副标题：

A javascript router for front-end microservices.

关键词：**router**。

这里可以参考vue/react-router的功能。工作台类型的应用中，功能区显示的内容是受浏览器地址栏的路由控制的，无论是通过代码编程、前进后退按钮还是点击a链接，都应该可以触发关联的子应用的挂载或者卸载。因此，single-spa的主要工作之一，便是**响应路由的变化来切换子应用**。

我们从它的API上便知——*activeWhen*函数用于计算子应用何时应该被挂载到页面上运行，反过来便是何时应该从页面上卸载。它有且只有一个参数，便是location，**因此一个应用被挂载还是卸载，只应取决于浏览器路由这唯一一个因素**。

微前端的交互特征决定了无论如何设计、无论是否使用*single-spa*，与路由之间的交互都是必不可少的，这几乎是微前端的标配能力之一。

### **状态机**

页面在响应用户的指令上是有矛盾的，即页面的路由几乎可以瞬间变化（同步），但是子应用的挂载/卸载却是一个有明显耗时的异步过程。

如果浏览器的路由快速变化，子应用应该如何响应呢？这明显是生产和消费之间的不均衡问题，下面来看两种极端方案：

1.  取消当前子应用，转而响应最新子应用；

2.  依次响应所有激活过的子应用

举一个例子，假设子应用A正在被挂载，因为耗时较长，用户点击了一个a链接，使得浏览器路由立刻发生了变化，导致子应用B应该被挂载，A应该被卸载。不过还未等B开始挂载，用户又快速点击另一个a链接跳到了新的路由，此时子应用C又应该被挂载。那么此时系统在卸载完A之后，应该立即挂载C呢，还是应该先挂载B、卸载B再挂载C呢？

显然挂载B这一环节已经没有意义，必须要有能力略过它。*single-spa*通过两种设计来实现这种效果。

首先，伴随着每一次路由变更，记录下所有需要挂载或者卸载的应用，作为一种需要消费的“报文”塞入一个队列当中，确保所有被影响到的应用都有被处理的机会，并且要以正确的次序被处理。例如从A切到C，必然是先卸载A再挂载C。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKn07TLeHvjfhVOuCaicXxvOIaxZBia54fpvj3ZibwkaZ1e5hLcpGLO4JLLg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

其次，处理“报文”，比如遇到「挂载B」这个指令，要判断是否真正要执行。因为队列中的所有待处理“报文”几乎全部都是异步的，生成它和处理它之间有一定的时间延迟，所以此时B可能应该被挂载，也可能已经过时不再需要被挂载。做法是检查一下当前的路由环境和应用B当前的状态，判断「挂载B」这个指令是否已经过时。

该检查需要用到B的状态，因为子应用有多个不同的异步阶段，能否继续执行下一个指令必然要参考其当前的状态，例如如果B允许被挂载，那么它当前必须处于“未挂载”状态——这就引出了状态机的概念。由此可知，***single-spa*****还负责监控每一个子应用的当前状态，根据状态限制某些非法的行为**。

在*single-spa*中，任何子应用都一定处于下列状态枚举中：

```
<span>NOT_LOADED</span>
```

每一个-ING都代表了子应用的一种异步阶段，通过对状态的追踪才能保证众多应用对于路由响应在时序上的正确性。

在上面这个例子中，显然「挂载B」的指令与当前location不符，而「卸载B」的指令与B的状态不符，它们都属于过时的指令，应当抛弃，进位到「挂载C」这个指令。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ZxDY5TMPs0GBGJiaGg2L1BoJPMYNMhicKnictAo9ZJaAt3UmKGrPuKfrWGjAWPLmypLj1r76icKxibM5BSN01HQzgiaQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

因此，对于微前端来说，跟踪子应用的状态也是必不可少的，无论是否使用single-spa。

### **加载器**

加载与卸载，都是通过操纵子应用暴露出来的生命周期方法来实现的，也意味着主应用必须要在内存中能拿到子应用的接口函数，下面将接口函数的集合称为**接口对象**。

*single-spa*的官方示例中仅以dynamic import的方式来异步加载一个子应用的接口对象，该对象中包含了各个生命周期方法：bootstrap、mount、unmount。

```
<span>// single-spa-config.js</span>
```

上面这个例子相当于主应用已经提前知道了子应用的接口对象路径，并没有考虑子应用的非逻辑资源——CSS，这是不符合实际生产环境要求的。

正因为如此，依赖*single-spa*的微前端方案都不约而同地实现了自己的加载器，让主应用有能力发现并加载一个完整的子应用，包括它的JS和CSS。**适用于生产环境的加载器的缺失是这些方案基于*single-spa*但又要做一层封装的最主要原因之一**。

## 微前端设计

### **关于微前端设计，你应该考虑到的**

快手运营中台的微前端方案目前也是基于*single-spa*来搭建的，以复用其路由和状态机这些基础能力，并同样定制了自己的加载器。本章节来讨论基础功能之外的一些实际生产环境需求细节，涉及到可持续性、健壮性、安全性、性能、生产效率等各种各样的边界场景。

### **如何描述子应用**

业界常见的一种实践是子应用向主应用暴露一个HTML地址，称之为“*HTML Entry*”。这种方案通常应用在有历史包袱的业务场景中，比如需要把已经存在的几个系统聚合起来，向外提供统一入口，而各自还能继续独立运行。

该HTML包含了子应用能够运行起来的两个必备要素——JS和CSS。于是，主应用不得不具备解析HTML以及提取其中CSS和JS的能力。这需要一定的计算成本以及对HTML内容的约束，不是任意HTML都可以被作为“*HTML Entry*”。因此**使用HTML作为子应用的入口，应该是一种折衷而非特性**。

更简单的方法是把HTML换成结构化更强、语义化更明确的格式，比如JSON。于是，我们让子应用各自生成一个JSON文件，来发挥HTML同样的功效：

```
<span>// assets-map.json</span>
```

这个JSON文件会被部署到生产环境中，拥有固定的URL。这样主应用就可以轻松地请求和解析它，拿到子应用的全部静态资源路径。我们称此文件为“资源映射表（Assets Map）”。

在主应用中，还需要配置一个规则，把子应用的名称映射到其资源映射表的地址，可以用一个Map，例如：

```
<span>// sub-apps.json</span>
```

也可以做一个统一的映射规则：

```
<span>assetsMapURL = `/assets-map/${appName}.json`;</span>
```

区别仅仅是反向代理的配置规则不同而已，具体实现起来灵活度很大。如果CORS配置好的话，资源表地址与页面不在同域也是允许的。

### **如何加载资源**

资源映射表是子应用的“敲门砖”，距离主应用成功启动一个子应用，只差「下载其CSS/JS静态资源」，以及「调用其生命周期函数」这两步。

现在来讨论如何动态下载CSS和JS，下面是业界已有的两种方案。

#### **Ajax请求**

很多微前端方案都要求子应用的JS和CSS的URL是可跨域的，就是因为它们下载资源的方式是Ajax——先异步请求（用XMLHttpRequest或者fetch）到源代码，然后对于CSS就创建一个<style>标签，注入CSS代码进去；对于JS就把动态执行（利用eval或Function），相当于分别模拟了<link>标签和<script>标签的功能。

这样做的目的，至少有两方面：

-   第一，对于CSS，可以轻易实现enabled/disabled，这在切换子应用时是必要的；对于JS，一旦报错可以实现简单重试；

-   第二，也是最重要的，可以实现沙箱（sandbox）机制——这是很多微前端方案宣传的最重要亮点之一。

关于沙箱，在后文“如何看待‘沙箱’”的章节还会继续讨论，下面先来分析Ajax加载静态资源的潜在弊端。

首先，代码不再依附于<link>或<script>标签运行，一旦解析或运行报错，浏览器将不能把错误堆栈索引到真正的资源路径上，这对于诊断报错将带来一定的障碍。

其次，无论是CSS还是JS，都非常有可能存在对其它资源的相对路径引用，例如CSS引用图片、字体，JS用dynamic import引用其它ESM，上面的做法相当于破坏了入口资源的位置，必然将影响到对引用资源的加载，极易导致404错误。

如果不考虑对沙箱的诉求，上面两个问题是没有优雅且简单的方法来解决的，那么可以考虑使用更简单的标签请求方式。

#### **标签请求**

这种模式尊重浏览器原生加载资源的方式，创建<link>标签和<script>标签，让浏览器来管理资源的请求、执行，其结果可以通过onload和onerror来获取。

这样做不受跨域的限制，也保留了原有的错误定位能力和引用资源加载能力，不过缺点也比较明显：

-   第一，无法支持沙箱；

-   第二，一旦出错难以重试

对于第二个问题，我们业务的策略是一旦子应用的CSS出错（即<style>标签onerror），通过删除标签再重建的方式来进行有限次数的重试；一旦JS出错（即<script>标签onerror），直接标记该子应用启动失败且永远失败。

这种方式对于实现CSS的enabled/disabled并没有阻碍，可以直接删除<link>标签来实现disabled、重建标签来实现enabled。由于标签重建后CSS的请求几乎一定是from cache，所以速度上可以接受。另一种稳妥的方案是通过修改<link>标签的type或rel属性为合法/非法值来实现enabled/disabled切换。

以上两种方案各有优劣，可以做一层封装，向外暴露抽象后的API，自由选择具体的请求方式。此外，JS和CSS应该做并行加载，能显著节约一些阻塞的时间。

#### **Async vs Initial**

以dynamic import为典型的写法常用做代码的拆分，来尽可能降低页面首次载入的资源体积。以webpack环境为例，页面一打开就会加载的JS/CSS资源，称之为*initial chunk*，按需异步加载的叫做*async chunk*。

*async chunk*是由*initial chunk*自动加载的，并不需要人为干预。于是有这样一个推论，无论使用Ajax请求还是标签请求，请求的都是*initial chunk*，不包括*async chunk*。

但*async chunk*仍然有必要被主应用感知，至少CSS是必要的，因为**子应用在卸载时，主应用需要负责清理其包括initial和async在内的全部资源**。

鉴于此，需要改进资源映射表的格式，体现出inital和async的区别：

```
<span>{</span>
```

对于vite来说，虽然其没有明确的*initial chunk*概念，但仍然有同步/异步资源的区别，也能够契合上面的格式。

#### **如何运行JS**

上面一节讨论了资源加载的途径问题，接下来来看如何发起资源加载。

CSS不在讨论范围内，无论使用Ajax请求还是标签请求，都是按照其initial部分的顺序来依次插入HTML中，没有争议。

JS不尽然，从模块化的格式上有AMD、CJS、UMD、ESM等多种之分，加载方法不尽相同。下面以其中的两个典型为例，UMD和ESM，来讨论如何运行这两种格式的代码，得到暴露给主应用的生命周期接口对象。

#### **UMD**

UMD因为可以兼顾独立运行和嵌入运行，是微前端方案中应用得最广的。它可以被编译成多个独立的JS文件，但其它的都是作为依赖而存在，唯独最后一个才是入口（Entry）。

因此无论是Ajax请求还是标签请求，时序都是先并发加载前N-1个JS，再加载最后一个JS，伪代码如下：

```
<span>await Promise.all(src.slice(0, -1).map(script =&gt; fetchAndExecScript(script)));</span>
```

对于Ajax请求来说，拿到JS源码后，调用eval（或类似方法）即可完成代码的执行，在这个过程中，注入一些上下文变量，就实现了沙箱的功能。

可以参考SystemJS的实现（详见https://github.com/systemjs/systemjs/blob/main/src/extras/global.js）来获取暴露出来的接口对象，其原理不再赘述，有一定的失败概率，更安全的方式是使用ESM。

#### **ESM**

ESM格式更简单，语义更清晰，且已经被现代浏览器所广泛支持。只需要发起对入口（Entry）JS文件的请求，浏览器就能够处理其背后的所有依赖关系，操作复杂度上要比UMD更简单。

入口文件依然可以使用标签请求的方式，但是相比于动态创建一个<script type="module">标签，有更简单也更健壮的办法：

```
<span>import(entryJS).then(...)</span>
```

这依赖浏览器原生的dynamic import能力，需要特别关注的是这种写法非常容易被webpack或者vite误伤，因此需要加上两个“魔法注释（magic comments）”：

```
<span>import(/* @vite-ignore */ /* webpackIgnore: true */entryJS).then(...)</span>
```

也可以使用Ajax来请求ESM，不过其代码要转换成*data URI*才能执行：

```
<span>const js = `export const message='HelloWorld'`;</span>
```

显然ESM格式的代码是没有途径去注入上下文变量的，因此杜绝了ESM实现沙箱的可能性。既然如此，Ajax请求JS源码转换成data URI再dynamic import的方式就显得多此一举。

以上是设计加载器所必须要考虑的要素，除此之外，还有更多场景的需求细节需要深入探索，限于推送篇幅，我们将在下篇中继续讨论。
