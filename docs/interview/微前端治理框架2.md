## **如何看待“沙箱”**

“沙箱”是一个比较敏感的话题，它的作用自然是想规避JS/CSS的全局冲突。不过比较遗憾，**在目前的浏览器技术条件下，实现100%安全的沙箱是不可能的**。

### **JS沙箱**

目前业界流行的JS沙箱机制都是使用Proxy对window、globalThis等常见全局对象做一层包装，然后再以Function（或类似方案）的方式执行子应用的代码，这样在子应用卸载时便可以清理被污染的全局对象。

因为能够访问到的全局变量几乎不可枚举，只代理这有限的几个对象难以称之为安全。而且，子应用污染全局的方式也不限于在这几个全局对象上挂载变量，也可能通过它们的多层后代来污染，因此Proxy根本无法做到足够完备的隔离效果。

而且，**无论沙箱机制实现得多么先进，也只能处理同步代码，对于异步代码则难以招架**。如果一定要做，可以尝试在Service Worker下代理JS代码的请求，做适当修改，以注入必要的代理对象。理论上可行，但实现起来可能有一些复杂。

另一种思路是自定义浏览器创建script标签的能力，进而能够控制真正被执行JS的代码。简单来说就是JS调用浏览器API（如createElement）来动态创建script标签时，实际上是「Ajax请求JS源码」——「修改代码」——「eval执行」这样一个过程。其中覆盖浏览器原生API的做法，也许会带来一些意外的副作用。

以上讨论都是针对UMD格式，如果**对于ESM格式的子应用，由于import/export只能作用于最外层，无法再用函数包裹注入上下文变量，便无法实现沙箱**。

### **CSS沙箱**

除了JS外，实现CSS的沙箱机制还是相对简单的，但需要对CSS代码进行复杂的解析和重构，其中对容错性、耗时的考量，需要进一步斟酌。而且也无法对keyframes动画起作用。

#### **预加载**

回顾子应用的启动流程，如下图：

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640.png)

1.  主应用请求子应用的资源映射表；

2.  主应用加载子应用的静态资源，拿到生命周期接口对象；

3.  主应用从接口对象中获取bootstrap、mount生命周期方法，依次调用。

如果主应用事先能获取各个子应用的资源映射表内容，那么第一步就是可省略的，进而也能节省一次HTTP请求。

但第二步无法省略，子应用的资源不可能全部被提前载入。往往都是由于路由的变动，激活相关子应用，再去加载其CSS/JS资源。

不过完全有可能存在部分子应用被激活的概率很高的场景，这种情况可以将该子应用设置为预加载（prefetch）模式，以提升其响应速度。具体做法是先把资源请求发出去，甚至可以拿到接口对象。这样在子应用真正被激活的时候，几乎可以立即调用bootstrap、mount完成启动。这其中必然要涉及到对资源的异步状态的监控和缓存，但原理显而易见，不再赘述。

#### **释放**

此处释放并非指子应用的卸载，只要主应用的环境还在，子应用的卸载就没有任何难度。这里指的是整个微前端环境的释放，包括子应用也包括主应用。

常规的基于微前端架构的应用，通常都是顶层框架中实现主应用，其在浏览器页面的生命周期中是常驻的，不需要考虑资源释放。

设想这样一个特殊场景，vue-router位于应用程序的最顶层，在其中一个路由页面中去创建主应用。一旦路由发生跳转，这个主应用连带其下面的子应用都应该被清理释放。实现这一功能要考虑子应用的状态。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161318157.png)

如果当前应该被激活的子应用已经完成了挂载，这是最简单的场景。single-spa已经提供了一个叫做unregisterApplication的方法，其中除了反注册之外，也能够对该子应用执行从DOM上卸载的操作。但至少还有两件事是single-spa处理不了的：

-   第一，子应用的JS已经被加载执行完了，如果有沙箱，需要释放沙箱。为了在子应用下次再启动时复用上次已经加载好的接口对象，需要设定一个缓存池，把子应用的接口对象放进去；

-   第二，子应用的CSS，包括initial部分和async部分，已经挂载到HTML中的，都应该被移除。

以上是对已经挂载的子应用的处理，总体看上去还是可预期、易操作的。但是前面也提到过，子应用是由状态机控制的，其处于不同状态时，清理它的操作也不尽相同，为了能尽快中断当前子应用的异步操作，完成资源清理和释放，就不得不遍历其状态，设计有针对性的措施。

既然single-spa已经记录了子应用的状态，直接查询即可。只有这几个异步状态需要关心：LOADING_SOURCE_CODE、BOOTSTRAPPING、MOUNTING，分别是正在请求资源映射表或下载静态资源、启动中、挂载中。对这些状态的处理方法基本上一致，即尽快抛出异常实现退出。

比如发现子应用当前正处于BOOTSTRAPPING状态，那么就需要在bootstrap完成后，立即抛出异常，阻止继续进入MOUNTING状态。以此类推：

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161333803.png)

以上场景仍然不是最复杂的，还需要考察用户真实使用场景下的各种非预期性动作。比如主应用由于上层路由变更的关系而正在执行释放操作，而用户又快速点击链接，让浏览器的路由又跳了回来，即刚刚还没来得及完成释放的主应用又要重新初始化，如何在保证数据一致性的前提下尽可能提高效率是一个关键的问题。

single-spa在这种场景中还是有一定的局限性的。首先single-spa是单例模式，不允许反复初始化；其次single-spa没有提供与start对应的方法，这意味着一旦single-spa开始运行就停不下来，会在一定程度上污染当前的浏览器页面环境。比如对pushState、replaceState、addEventListener、removeEventListener等原生方法的覆写、全局监听的事件等等，都没有方法来回位。

为了主应用能够在频繁无规律的启动、释放事件中保证状态的正确性，必然要对其设置全局的状态暂存区，用来保存子应用的释放状态，这里的释放要定义成停止当前异步操作——卸载——移除样式等一系列操作。

例如，在window对象上设置固定变量 __APP_STATE = { }，如果子应用A正在释放，设置__APP_STATE.A.releasing=true。当路由反复流转，A又需要被激活时，检查发现其正在释放过程中，那么就必须等到其完成释放再重新进行启动或挂载。

除了子应用的释放状态应该被记录外，同样的道理，主应用也需要在下次被重新启动前，等待上一次的释放完成。至于主应用如何在状态暂存区中找到“前世”的数据，有多种手段，比如在应用程序的宏观层面保证可控的主应用名称，以名称来判定是否是同一个主应用。

在浏览器这种单线程的环境下，资源释放的紧迫性，并不能被很及时地处理，因为一旦有阻塞式任务，将很难快速退出，进而带来明显的资源释放时延，而这种时延又会明显增加应用下一次启动的时间。

这种冲突完全是由于在同一个浏览器页面下支持应用反复重启带来的资源分配和释放问题导致的，作为类比，同一台电脑上，操作系统只启动一次，就可以支持同一个应用程序反复启动和关闭无数次，如何保证应用状态的一致性以及避免内存泄漏就是客观存在的问题。

操作系统上一般都会有类似“资源管理器”的功能，用来统一负责代理对数据状态、数据缓存等的各种访问诉求。同样的道理，我们也设计了类似的一个中间层，无论上层的路由如何频繁地驱动应用的反复重启，底层资源的异步操作一致性不受影响。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161351354.png)

这种做法不是万能的，它最多能保证状态的一致性，但不能保证及时性。

#### **嵌套**

嵌套是指微前端的子应用当中再创建一个微前端主应用，理论上随着子应用的颗粒化程度的加深，嵌套可能存在多个层级。

受到运行原理的限制，同一个页面下只能存在一个single-spa实例，那么即使存在多个主应用之间的嵌套，那么也必须使用同一个single-spa实例的API。这个实例的代码如何引入便成为了问题。

如果在应用程序顶层统一引入一个single-spa.js，就破坏了各级主应用之间的独立性，它们将无法独立启动，至少存在着对single-spa版本的依赖耦合。如果各级主应用独立引入自己的single-spa，那么将需要沙箱来保证隔离性，而前面已经论证过，沙箱在某些场景下是无法实现的，比如ESM。

在各种各样的条件束缚之下，我们目前没有对嵌套表示明确支持，需要这种特性的业务必须舍弃一定的独立性来间接实现。

#### **跨应用跳转**

一般来说，在子应用内部都会有vue/react-router，负责在子应用内部跳转，无论怎么跳转，都在该子应用声明的activeWhen实现范围内。比如：

```
<span>foo.activeWhen = <span>(<span>location</span>) =&gt;</span> location.pathname.startsWith(<span>/\/foo\//</span>);</span>
```

上面是典型的activeWhen实现，意思就是只要浏览器路由是以/foo/开头，就激活子应用foo。在foo内部，可以声明一个base为/foo/的vue-router：

```
<span><span>new</span> <span>Router</span>({</span>
```

只要路由在此范围内跳转，顶层的single-spa不需要有任何反应，因为跳转的前后，子应用没有发生变化。在子应用内部，可以使用router-link或者router.push/replace来执行编程跳转。

但路由跳转一旦超过了该vue/react-router实例的控制范围，比如从/foo/home跳转到/bar/home，仅仅调用vue/react-router实例的API已经无法完成导航，必须要通知到single-spa这一层来切换子应用，就只能通过history API来实现（在hash模式下也可以用a链接）。

作为业务来讲，时刻需要关注根据跳转目标地址来选择跳转方法，显然是不可接受的，必须有一种方法来抹平跳转目的地不同带来的跳转方法差异性。我们的实践是，把全部跳转请求都派给vue/react-router，利用兜底机制来实现“冒泡”通知。

举例来说，在vue-router的实例中，定义一个“*”匹配规则：

```
<span>{</span>
```

所有未被匹配的路由都会落到这条规则上，然后转换成对history API的调用，从而实现跨应用跳转。

**keep-alive**

keep-alive是vue中的一个重要内置组件，特别是在与vue-router配合时，能营造出一种“视图缓存”的效果，在路由回转时能够提高渲染效率。

在微前端场景中，keep-alive应该是子应用的一种属性，即不执行真正的卸载（除非其主应用也要卸载），只是暂时不展现。

所有的子应用都是通过其mount生命周期方法来挂载到主应用提供的一个DOM元素上的，我们称之为根（root）元素。通常来说，工作台应用程序只需要一个根元素，因为同一时刻始终都只有一个子应用填充在功能区。

keep-alive代表着一种缓存属性，如果存在设定为keep-alive的子应用，当它被“卸载”后，下一个子应用想启动就必须挂载到一个新的根元素上，这个元素需要主应用负责创建和销毁。

如果不想动态创建新的根元素，一种办法是把keep-alive子应用的DOM元素从根元素中移出暂存起来，用的时候再移回来，不过这样就会影响子应用创建的DOM树的路径。

无论哪种方式，被“卸载”的keep-alive子应用，其CSS都应该被移除或禁用掉，以避免与现在被激活的子应用发生样式冲突。

#### **公共依赖**

有这样一种需求，子应用依赖某一个拥有独立URL的library，比如vue.js，且被声明在资源映射表中，这带来一个问题：这种library一般是UMD导出，如果不同子应用依赖相同library，重复加载会导致全局对象混乱。同样是vue.js，全局对象window.Vue的相互覆盖会丢失原型链上挂载的数据，如果版本不同，则还可能造成运行时的致命错误。

在没有沙箱的环境下，这种全局冲突需要一定的规则来约束，这里我们提出一种由主应用统一管理的公共依赖的概念。

在主应用中配置各个子应用时，同时声明一系列公共依赖资源，可以是CSS也可以是JS。子应用可以依赖其中一个或几个，也可以不依赖。一旦主应用感知到有子应用要启动，就要首先检查其声明的公共依赖是否有加载，这里要区分四种状态：未加载、加载中、加载成功、加载失败。

显然这里也需要一个资源管理器，集中管理公共依赖资源。不过依然不允许公共依赖中存在两个及以上相同功能的不同版本。

## **冲突调和，成本与时效**

微前端除了在运行时原理上带来很大的革新之外，也间接影响到了线下的开发模式、安全、部署等相关工具和流程。

### **冲突探测**

在前文中已经提到，沙箱不能实现100%的隔离性，冲突依然有可能发生。很多全局冲突都难以发现，不过针对其中一部分还是能够做一些预警工作。在快手运营中台的实践中，我们针对其中一种简单的场景——JS变量覆盖冲突，实现了一种静态分析工具，其主要构成部分是一个eslint插件。

其工作原理也相当简单，当它发现JS中有针对全局变量的读写操作便会发出预警，例如以下代码，都属于有冲突风险的：

```
<span><span>window</span><span>.foo</span></span>
```

哪些全局变量的访问方式会被认为有风险是可配置的。这样即便是有很多老旧代码，还是能够实现对其中可能引起全局冲突的写法有一定的预期，并非完全失控。

未来我们还将对Vue组件中非scoped的样式代码作出类似的预警。

### **联合开发**

子应用能否以所见即所得的方式进行高效的本地开发调试，是微前端架构下必须要解决的线下问题之一。

对于工作台这类应用，其完整视图分属在主/子应用当中——顶栏和左侧菜单栏属于主应用，构成一个“「”型框架，子应用位于功能区嵌入其中。接下来要解决在本地环境中单独调试开发子应用，其视图如何装载到主应用框架中的问题。

我们过去的实践是，在源码层面上对这一部分视图框架进行抽离，命名为“foundation”。它会被主应用和子应用分别依赖，主应用以prod方式依赖它，需要把其打包上线，而子应用是以dev方式，只需在本地开发调试时才需要编译，最终上线时并不需要打包。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161411711.png)

该方案相对容易实现，唯一值得诟病的就是迭代麻烦，例如一旦foundation代码更新，需要主应用和众多子应用项目分别升级。

随着技术方案的演进，这种做法还会逐渐遭遇更严重的问题，甚至变得不可实现，因为子应用在源码层面依赖foundation，这就需要它们有一致的技术方案，比如要么都是React，要么都是Vue2或者都是Vue3。现在假设部分子应用从Vue2升级到Vue3，就要求foundation也要升级到Vue3。但此时可能还有其它子应用在使用Vue2版本，于是不得不同时维护foundation的两种版本，直到所有子应用全部升级完成，这会让子应用的独立维护变得缺乏自由。如果不同子应用由不同团队来维护，还会增加一定的沟通协调成本。

考虑到这种耦合带来的不便，我们开始逐渐实现**运行时动态依赖方案**——简单来说，就是子应用不再从源码层面上依赖foundation，而是动态将主应用运行在本地开发环境。这种操作并非要把主应用的源码同步到子应用中再启动，而是直接代理本地浏览器的HTML到远程的一个在线部署的主应用的HTML，另外再代理其对当前子应用资源表的请求（其它请求均默认放行）到本地，流程原理如下图：

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161511091.png)

 各种资源的代理穿透流向如下：

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161526188.png)

在此方案下，只要有一个稳定部署的主应用，便可以用来给全部子应用的开发调试共同使用，不存在技术方案的耦合性。即便主应用是React，子应用是Vue也完全可以支持。

在实际业务场景中还有更复杂的需求是本文没有讨论到的，比如在本地共同开发主应用和几个子应用，如何将它们聚合在一个浏览器页面当中来体验，是我们目前还没有完全解决的问题。未来我们会提供工具让散落在不同端口的服务智能地组装到一起，来降低复杂业务场景下的开发难度。

### **映射表生成**

资源映射表承载所有的静态资源路径，包括JS和CSS，如前讨论，要区分async和initial两种分类。理论上可以输出成任何结构化格式，当然最常用的还是JSON。

我们针对webpack环境和vite环境分别开发了两个插件，插件不是简单的把编译结果写到磁盘文件中，而是要写到内存文件中，这样即使在开发调试阶段，浏览器也能时刻读取到最新的资源映射表。

### **映射表配置化**

在典型的生产环境部署中，子应用的全部静态资源都被发送到了CDN上，部署在IDC上的几乎就只有资源映射表这一个文件。对于业界常用的容器部署环境，即便一个文件也仍然要占用至少一个容器实例，其CPU、内存、磁盘等资源被严重浪费。

通过优化子应用的部署方式，甚至能够节省出90%的IDC资源。我们设计了一个**主-子应用映射管理系统**（Asset Management System，以下简称*AMS*）。该系统通过对外暴露接口的方式，允许主应用读取到各子应用的资源映射表地址，而该地址不再像以前那样部署在IDC上，而是在CDN上，虽然有一些跨域要求，但配置难度小，可行性很高。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161604630.png)

此方案相当于集中维护了各个子应用的资源映射表地址，不再各自单独部署服务来提供。这样显然能够大幅优化资源占用，只需要少量的存储和计算资源。

该系统的存在还有一个优势，在过去想回滚一个子应用的代码，最少也需要重新部署一次，消耗数分钟的时间。现在只需要在*AMS*系统上调整配置，向主应用输出旧版本的资源映射表即可，数秒内即可完成切换。

对*AMS*的访问增加了一次HTTP请求的开销，但也是可以优化的。例如将其与现有的业务接口合并，或者让*AMS*直接维护资源映射表的内容而不是路径，不再赘述。

### **渐进演进**

虽然实施微前端的目标是解决“巨石应用”等问题，然而在实际等场景中，一个系统从开始建设的时候，常常并不能准确地看到它未来的规模，无法预知到它演变为“巨石应用”的可能性。

如果在技术上不加区分地直接以完整的微前端方案来实施，相比于业务规模则引入了过量的复杂性，影响系统建设初期的效率；如果完全不考虑，未来在拆解成微前端架构时，则会牵一发而动全身。

我们在微前端方案的设计上，实现了一种渐进式的折衷方案，实际编码体验与纯粹的微前端架构等同，有主应用和子应用的概念，每个子应用有独立的目录，有自己的router实例，也要考虑子应用之间的跳转方法。但是，整个项目实际上是一个SPA应用，不仅代码是在一起的，最终也是一同编译、一同部署的。

![图片](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs/640-20240102161739407.png)

虽然和真正的微前端托管方式还有不少的差别，比如依赖是共享的等，但是已经相当接近，只要系统有需要被改造成真正的微前端架构，那么仅需要把各个子应用目录拷贝出去，“自立门户”即可，在源代码层面几乎不需要有太多的修改，从而让本来具有较大成本和风险的重构工作，变得轻而易举。

以这样一种渐进式演进的微前端方案，我们有信心保证一个新的业务在两三年内稳定、高效地迭代开发。

## **成效，前景与展望**

快手运营中台以工作台类业务为主要对象，针对支持团队众多、成员流动性大、业务场景复杂、可维护性要求高等特点，实现了一套可移植的微前端方案，有效解决或者优化了前叙问题，但仍有许多feature缺失和不足。

未来，我们计划首先仍然是夯实现有方案的普适性、健壮性，补齐缺失的部分，比如联合开发的体验和效率问题、应用的嵌套问题、资源的释放问题；其次是面向未来探索更具标准化的解决方案，比如WebComponents在微前端上的应用等等；最后是以此为契机，间接地推动业务工程的技术演进，比如ESM的推广。
