# 算法题

## 数组

### 88. 合并两个有序数组

[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

从后往前遍历  

```javascript
var merge = function(nums1, m, nums2, n) {
		let i=m-1,j=n-1,k=m+n-1;
		while(i>=0||j>=0){
			if(i<0)nums1[k--]=nums2[j--];
			else if (j<0) nums1[k--]=nums1[i--];
			else if(nums1[i]<nums2[j]) nums1[k--]=nums2[j--];
			else nums1[k--]=nums1[i--];
		}
		return nums1;
};
```

### 54. 螺旋矩阵

[54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

```js
var spiralOrder = function (matrix) {
	if (matrix.length === 0) return []
	const res = []
	let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1
	while (top < bottom && left < right) {
		for (let i = left; i < right; i++) res.push(matrix[top][i])   // 上层
		for (let i = top; i < bottom; i++) res.push(matrix[i][right]) // 右层
		for (let i = right; i > left; i--) res.push(matrix[bottom][i])// 下层
		for (let i = bottom; i > top; i--) res.push(matrix[i][left])  // 左层
		right--
		top++
		bottom--
		left++  // 四个边界同时收缩，进入内层
	}
	if (top === bottom) // 剩下一行，从左到右依次添加
		for (let i = left; i <= right; i++) res.push(matrix[top][i])
	else if (left === right) // 剩下一列，从上到下依次添加
		for (let i = top; i <= bottom; i++) res.push(matrix[i][left])
	return res
};
```

### 384. 打乱数组（洗牌算法）

[384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)

```js
class Solution {
    constructor(nums) {
        this.nums = nums;
        // 保存原始数组
        this.original = [...this.nums];
    }
    reset() {
        this.nums = [...this.original];
        return this.nums;
    }
    shuffle() { //洗牌算法
        const len = this.nums.length;
        for (let i = 0; i < len; i++) {
            // 获取区间[i,len-1]范围内的随机整数j
            const j = i + Math.floor(Math.random() * (this.nums.length - i));
            // 交换位置
            [this.nums[i], this.nums[j]] = [this.nums[j], this.nums[i]];
        }
        return this.nums;
    }
}
```

### 48. 旋转图像

[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

```js
var rotate = function (matrix) {
	const n = matrix.length;
	// 先水平翻转
	for (let i = 0; i < n / 2; i++) {
		for (let j = 0; j < n; j++) {
			[matrix[i][j], matrix[n - i - 1][j]] = [matrix[n - i - 1][j], matrix[i][j]]
		}
	}
	// 再对角线翻转
	for (let i = 0; i < n; i++) {
		for (let j = 0; j < i; j++) {
			[matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]
		}
	}
};
```

### 498. 对角线遍历

[498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/)

先上后下

```javascript
var findDiagonalOrder = function (matrix) {
	if (matrix.length < 1) return [];
	let res = [],
		flag = true,  // true-右上 /  false-左下
		i = j = 0,
		n = matrix.length,
		m = matrix[0].length;

	while (i < n && j < m) {
		res.push(matrix[i][j]);
		m = matrix[i].length; // 每行的长度
		if (flag) {
			//  右上移动 i-=1; j+=1 
			i -= 1;
			j += 1;
		} else {
			// 左下移动 i+=1; j-=1
			i += 1;
			j -= 1;
		}
		// 处理边界 -- 转弯
		if (i < 0 || j < 0 || i == n || j == m) {
			if (flag) {
				// 右上
				if (j < m) i = 0; // 上边越界，像右移动
				else {
					// 右边越界，向下移动
					i += 2;
					j--;
				}
			} else {
				// 左下
				if (i < n) j = 0; // 左边越界， 像下移动
				else {
					// 下边越界， 想右移动
					i--;
					j += 2;
				}
			}
			flag = !flag; // 转换方向
		}
	}
	return res;
};
```

先下后上

```javascript

var findDiagonalOrder = function (matrix) {
	if (matrix.length < 1) return [];
	let res = [],
		flag = true,  // true-右上 /  false-左下
		i = j = 0,
		n = matrix.length,
		m = matrix[0].length;

	while (i < n && j < m) {
		res.push(matrix[i][j]);
		m = matrix[i].length; // 每行的长度
		if (flag) {
			// 左下移动 i-=1; j+=1 
				i += 1;
			j -= 1;
		} else {
			// 右上移动 i+=1; j-=1
		i -= 1;
			j += 1;
		}
		// 处理边界 -- 转弯
		if (i < 0 || j < 0 || i == n || j == m) {
			if (flag) {
				// 右上
				if (i < m) j = 0; // 上边越界，像右移动
				else {
					// 右边越界，向下移动
					j += 2;
					i--;
				}
			} else {
				// 左下
				if (j < n) i = 0; // 左边越界， 像下移动
				else {
					// 下边越界， 想右移动
					j--;
					i += 2;
				}
			}
			flag = !flag; // 转换方向
		}
	}
	return res;
};
var mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
console.log(findDiagonalOrder(mat)); 
```

### 二维数组放大

```js
var arr = [
    [0,1],
    [1,0]
];

var newArr = [];
function bigArr(n,k,arr){
    for(let i = 0; i < n;i++){
        for(let j = 0; j < n; j++){
            let temp = arr[i][j];
            // console.log(temp);
            for(let ii = i*k; ii<i*k + k; ii++){
                //newArr[ii] = new Array(n*k);
                for(let jj = j*k; jj <j*k+k; jj++){
                    //newArr[ii] = new Array(n*k);
                    newArr[ii][jj]=temp;
                    // console.log(temp);
                    // console.log('ii:' + ii);
                    // console.log('jj:' + jj);
                    // console.log(newArr[ii][jj]);                   
                }
            }
        }
    }
    return newArr
}
var newA = bigArr(arr.length,3,arr)
console.log('原始数组：' );
console.log(arr);
console.log('放大倍数k:'+ 3);
console.log('放大后的数组:' );
console.log(newA);
```



## 双指针/滑动窗口

### 3. 无重复字符的最长子串

[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

双指针移动 

```javascript
var lengthOfLongestSubstring = function(s) {
 var cnt={};
    var res=0;
    var j=0;
for(let i=0;i<s.length;i++)
    {
        if(s[i] in cnt) cnt[s[i]]++;//存在重复 值加1
        else cnt[s[i]]=1;
        while (cnt[s[i]]>=2)
            {
                cnt[s[j]]--;//相当于删除窗口之外的元素
                j++; //右移
                //cnt[s[j++]]--;
            }
        res=Math.max(res,i-j+1);
    }
    return res;
};
```


15. ### 三数之和

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```js
var threeSum = function(nums) {
		const len=nums.length;
		if(len<3) return [];
		nums.sort((a,b)=>a-b);
		const res=[];
		for(let i=0;i<len-2;i++){
			if(nums[i]>0) break;
			if(i>0&&nums[i]===nums[i-1]) continue;
			let left=i+1,right=len-1;
			while(left<right){
				const sum=nums[i]+nums[left]+nums[right];
				if(sum<0) {left++;continue }
				if(sum>0){right--;continue}
				res.push([nums[i],nums[left],nums[right]]);
                //去重
				while(left<right&&nums[left]===nums[left+1]) left++
                while(left<right&&nums[right]===nums[right-1])  right--
                left++
                right--
			}
            
		}
		return res;
};
```
18. ### 四数之和

[18. 四数之和](https://leetcode.cn/problems/4sum/)

返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` 

```js
var fourSum = function(nums, target) {
    let len = nums.length;
    if(len < 4) return [];

    nums.sort((a, b) => a - b); // 排序
    
    let result = [];
    for(let i = 0; i < len - 3; i++) {
        if(i > 0 && nums[i] === nums[i - 1]) // 去重
            continue;

        for(let j = i + 1; j < len - 2; j++) {
            if(j > i + 1 && nums[j] === nums[j - 1]) // 去重
                continue;

            let left = j + 1; // 左指针初始化
            let right = len - 1; // 右指针初始化

            while(left < right) {
                if(nums[i] + nums[j] + nums[left] + nums[right] > target) {
                    right--; // 如果大于0，右指针左移，让和小一点
                } else if(nums[i] + nums[j] + nums[left] + nums[right] < target) {
                    left++; // 如果小于0，左指针右移，让和大一点
                } else {
                    result.push([nums[i], nums[j], nums[left], nums[right]]);
                    while(left < right && nums[right] === nums[right - 1]) {
                        right--; // 去重
                    }
                    while(left < right && nums[left] === nums[left + 1]) {
                        left++; // 去重
                    }
                    // 找到一个符合条件的四元组了，两指针同时收缩
                    right--;
                    left++;
                }
            }
        }
        
    }
    return result;
};
```

209. ### 长度最小的子数组

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```js
const minSubArrayLen = (s, nums) => {
  let minLen = Infinity;
  let i = 0;
  let j = 0;
  let sum = 0;
  while (j < nums.length) {   // 主旋律是扩张，找可行解
    sum += nums[j];
    while (sum >= s) {        // 间歇性收缩，优化可行解
      minLen = Math.min(minLen, j - i + 1);
      sum -= nums[i];
      i++;
    }
    j++;
  }
  return minLen === Infinity ? 0 : minLen; // 从未找到可行解，返回0
};

```

### 42. 接雨水

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

```js
var trap = function(height) {
    const len = height.length;
    let sum = 0;
    for(let i = 0; i < len; i++){
        // 第一个柱子和最后一个柱子不接雨水
        if(i == 0 || i == len - 1) continue;
        let rHeight = height[i]; // 记录右边柱子的最高高度
        let lHeight = height[i]; // 记录左边柱子的最高高度
        for(let r = i + 1; r < len; r++){
            if(height[r] > rHeight) rHeight = height[r];
        }
        for(let l = i - 1; l >= 0; l--){
            if(height[l] > lHeight) lHeight = height[l];
        }
        let h = Math.min(lHeight, rHeight) - height[i];
        if(h > 0) sum += h;
    }
    return sum;
};

```

### 283. 移动零

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

```js
var moveZeroes = function(nums) {
		if(nums==null){
			return
		}
		let j=0;
		for(let i=0;i<nums.length;i++){
			if(nums[i]!==0){
				let temp=nums[i];
				nums[i]=0;
				nums[j++]=temp;
			}
		}
};
```



## 字符串

### 7. 整数反转

[7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

```javascript
var reverse = function (x) {
	let y = parseInt(x.toString().split("").reverse().join(""));
	if (x < 0)
		y = - y;
	return y > Math.pow(2, 31) - 1 || y < Math.pow(-2, 31) ? 0 : y;
};
```

### 415. 字符串相加

**[415. 字符串相加](https://leetcode-cn.com/problems/add-strings)**

```js
var addStrings = function(num1, num2) {
	if(num1===num2&&num1==='0')return num1
	num1=num1.split('').reverse()
	num2=num2.split('').reverse()
	const len =Math.max(num1.length,num2.length)
	let flag=0
	const result=[]
	for(let i=0;i<len;i++){
		const n1=+num1[i]||0
		const n2=+num2[i]||0
		let sum=n1+n2+flag
		flag=0
		if(sum>9){
			sum-=10
			flag=1  //进位1
		}
		result.push(sum)
	}
	if(flag) result.push(flag)
	return result.reverse().join("")
};
```

### 8. 字符串转换整数 (atoi)

[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

```js
var myAtoi = function (s) {
	let res = 0;
	let maxnum = 2 ** 31 - 1, minnum = (-2) ** 31
		// 正负号，默认正号
		negativeSymbol = 1;
	// 把首尾的空格都去掉
	   s = s.trim();
	for (let i = 0; i < s.length; i++) {
		// 负数
		if (i == 0 && s[i] == "-") {
			negativeSymbol = -1;
			continue;
			// 正数
		} else if (i == 0 && s[i] == "+") continue;
		// 因为空格会被转成0，所以要排除空格的情况，也就是说在数字范围内就加上
		if (s[i] >= 0 && s[i] <= 9 && s[i] != " ") {
			res = res * 10 + (s[i] - 0);
			// 为什么在这里就判断呢，因为这里如果就溢出的话，就直接跳出，不需要再后面无意义的计算了
			if (res * negativeSymbol <= minnum  ) return minnum;
			else if (res * negativeSymbol >= maxnum) return maxnum;
		} else break;
	}
	return res * negativeSymbol;
};
```

### 14. 最长公共前缀

[14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```js
var longestCommonPrefix = function(strs) {
		if(!strs.length) return "";
		res=strs[0]; //选定第一个为基准
		for(str of strs){
			for(let i=0;i<res.length;i++){
				if(str[i]!==res[i]){ //如果不相等
					res = res.slice(0, i);
				break;
			}
		}
		}
		return res;
};
```

### 43. 字符串相乘

[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

```js
var multiply = function (num1, num2) {
	if (num1 === '0' || num2 === '0') {
		return '0'
	}
	var l1 = num1.length, l2 = num2.length, p = new Array(l1 + l2).fill(0)
	for (var i = l1; i--;) {
		for (var j = l2; j--;) {
			var tmp = num1[i] * num2[j] + p[i + j + 1]
			p[i + j + 1] = tmp % 10
			p[i + j] += 0 | tmp / 10
		}
	}
	while (p[0] === 0) {
		p.shift()
	}
	return p.join('')
};
```



## 链表

### 206. 反转链表

[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```js
function ListNode(val, next) {
      this.val = (val===undefined ? 0 : val)
     this.next = (next===undefined ? null : next)
 }

var reverseList = function(head) {
	if(!head||!head.next) return head;
	let item =head;   
	let prev=null;   // prev   item    
	let next=item;
	while(item){
		next=item.next;    //  先把当前head的后一个存起来
        item.next=prev;   //   然后再把head的下一个指向前面  
		prev=item		//  整体后移 相当于进行了迭代 prev现在是之前的item	
		item=next         //    之前的item为item原来的后一个
	}
	return prev
};
```

### 92. 反转链表 II

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

```js
var reverseBetween = function (head, m, n) {
	// 用来记住整个链表的头节点位置
	let res = new ListNode(0)
	res.next = head
	// 找到需要反转的位置
	let pre = res
	for (let i = 1; i < m; ++i) {
		pre = pre.next
	}
	// 将head指向要反转的链表部分的头部   利用三个节点
	head = pre.next
	for (let i = m; i < n; ++i) {
		let nxt = head.next
		// nxt 节点要被放到反转部分的头部，所以将head的next指向它的下下个节点
		head.next = head.next.next
		// 将nxt放到头部，pre.next指向的是反转部分的头部节点
		nxt.next = pre.next
		// 重新将pre指向反转部分的头部 向前
		pre.next = nxt
	}
	return res.next
};
```

### 141. 环形链表

[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

hash表

```javascript
var hasCycle = (head) => {
    let map = new Map();
    while (head) {
        if (map.has(head)) return true;//如果当前节点在map中存在就说明有环
        map.set(head, true);//否则就加入map
        head = head.next;//迭代节点
    }
    return false;//循环完成发现没有重复节点，说明没环
};
```

双指针

```js
var hasCycle = function(head) {
    if(head === null) return false
    let slow = head, fast = head.next
    while(fast && fast.next) {
        if (slow.next === fast.next.next) return true
        slow = slow.next
        fast = fast.next.next
    }
    return false
};
```

### 142. 环形链表 II

[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。

```js
var detectCycle = function (head) {
	// 快慢指针初始化指向 head
	let slow = head;
	let fast = head;
	// 快指针走到末尾时停止
	while (fast && fast.next) {
		// 慢指针走一步，快指针走两步
		slow = slow.next;
		fast = fast.next.next;
		// 快慢指针相遇，说明含有环
		if (slow == fast) {
			// 任一一节点指向头节点
			fast = head;
			// 同步向前进
			while (fast != slow) {
				fast = fast.next;
				slow = slow.next;
			}
			// 返回入口节点
			return fast;
		}
	}
	// 不包含环
	return null;
};
```

### 21. 合并两个有序链表

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```js
var mergeTwoLists = function (l1, l2) {
	if (l1 === null) {
		return l2;
	} else if (l2 === null) {
		return l1;
	} else if (l1.val < l2.val) {
		l1.next = mergeTwoLists(l1.next, l2);
		return l1;
	} else {
		l2.next = mergeTwoLists(l1, l2.next);
		return l2;
	}
};
```

### 23. 合并K个升序链表

[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```js
var mergeKLists = function (lists) {
  // 当是空数组的情况下
  if (!lists.length) {
    return null;
  }
  // 合并两个排序链表
  const merge = (head1, head2) => {
    let dummy = new ListNode(0);
    let cur = dummy;
    // 新链表，新的值小就先接谁
    while (head1 && head2) {
      if (head1.val < head2.val) {
        cur.next = head1;
        head1 = head1.next;
      } else {
        cur.next = head2;
        head2 = head2.next;
      }
      cur = cur.next;
    }
    // 如果后面还有剩余的就把剩余的接上
    cur.next = head1 == null ? head2 : head1;
    return dummy.next;
  };
  const mergeLists = (lists, start, end) => {
    // base case  只有一个链接的情况
    if (start + 1 == end) {
      return lists[start];
    }
    // 输入的k个排序链表，可以分成两部分，前k/2个链表和后k/2个链表
    // 如果将这前k/2个链表和后k/2个链表分别合并成两个排序的链表，再将两个排序的链表合并，那么所有链表都合并了
    let mid = start + ((end - start) >> 1);
    let head1 = mergeLists(lists, start, mid);
    let head2 = mergeLists(lists, mid, end);
    return merge(head1, head2);
  };
  // 前闭后开
  return mergeLists(lists, 0, lists.length);
};
```

### 剑指 Offer 22. 链表中倒数第k个节点

[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

```js
var getKthFromEnd=function(head,k){
	let slow=head
	while(k--){
		head=head.next
	}
	while(head){
		slow=slow.next
		head=head.next
	}
	return slow

}
```

### 160. 相交链表

[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```javascript
var getIntersectionNode = function (headA, headB) {
	let a = headA,
		b = headB;
	while (a != b) {
		// a 走一步，如果走到 headA 链表末尾，转到 headB 链表
		a = a != null ? a.next : headB;
		// b 走一步，如果走到 headB 链表末尾，转到 headA 链表
		b = b != null ? b.next : headA;
	}
	return a;
};
```

### 25. K 个一组翻转链表

[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```js

var reverseKGroup = function (head, k) {
	if (!head) return null;
	let start = head, end = head;

	for (let i = 0; i < k; i++) {
		// 如果在还没遍历到第 k 个，end 空了，即 head 链表个数不满足 k 个，直接返回原链表
		if (!end) {
			return head;
		} else {
			end = end.next;
		}
	}

	let newHead = reverse(start, end); // 左闭右开区间
	start.next = reverseKGroup(end, k); // 翻转以后，原本的 start 指向的结点，变到了 end 的前一个，直接 start.next 继续递归翻转后续的就行
	return newHead;
};

// 反转区间 [a, b) 的元素，注意是左闭右开
function reverse(head, end) {
	let p = head, q, newHead; // p 在前面，q 跟在 p 的后面
	while (p !== end) {
		q = p; // q 赋值会原链表 p 的位置
		p = p.next; // p 继续向后遍历
		q.next = newHead;
		newHead = q;
	}
	return newHead;
};
```

### 19. 删除链表的倒数第 N 个结点

[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

先后指针：快指针先走n-1步后慢指针再开始从头节点开始走。当快指针走到最后一个结点的时候，慢指针就走到了倒数第N个结点。

```js
var removeNthFromEnd = function(head, n) {
  // 先指针先走n-1步
  let fast = head;
  for(let i=1; i<=n-1; i++) {
    fast = fast.next;
  }
  let slow = head;
  // 缓存要删除结点的前一个结点
  let pre = null;
  while(fast.next) {
    pre = slow;
    fast = fast.next;
    slow = slow.next;
  }
  // 如果要删除的结点是第一个结点的话，则直接返回slow.next
  if(pre === null) {
    return slow.next;
  }
  else {
    pre.next = slow.next;
  }
  return head;
}

```

### 2. 两数相加

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表

```js
var addTwoNumbers = function (l1, l2) {
	let head = null, tail = null;
	let carry = 0;
	while (l1 || l2) {
		const n1 = l1 ? l1.val : 0;
		const n2 = l2 ? l2.val : 0;
		const sum = n1 + n2 + carry;
		if (!head) {
			head = tail = new ListNode(sum % 10);
		} else {
			tail.next = new ListNode(sum % 10);
			tail = tail.next;
		}
		carry = Math.floor(sum / 10);
		if (l1) {
			l1 = l1.next;
		}
		if (l2) {
			l2 = l2.next;
		}
	}
	if (carry > 0) {
		tail.next = new ListNode(carry);
	}
	return head;
};
```

### 143. 重排链表

[143. 重排链表](https://leetcode.cn/problems/reorder-list/)

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```js
var reorderList = function(head) {
    if(!head.next) return head;

    let slow = head, fast = head.next; // slow 为第一个结点开始，fast 为第二个结点开始，这样结点总个数奇数或偶数都很好兼容
    // fast 走两步，不能一次性走两步，要一步一步走
    while(fast && fast.next) {
        slow = slow.next;
        fast = fast.next;
        // 对于 fast 第二步，需要先判断，如果 fast 后面还可以再走一步，才往后走
        if(fast.next) {
            fast = fast.next;
        }
    }

    // 现在 slow 和 fast 之间就是要翻转的部分了 (slow, fast]
    let newHead = null, p = slow.next, q;
    slow.next = null; // 前半部分和后半部分断开联系
    while(p) {
        q = p;
        p = p.next;
        q.next = newHead;
        newHead = q;
    }

    // 现在 newHead 就是后半段翻转后的样子，然后接下来跟前半部分 依次 插入新链表
    let resultHead = new ListNode(0), now = resultHead, flag = true;
    slow = head, fast = newHead;
    while(slow || fast) {
        // 通过 flag 控制现在插入 前半部分 还是 后半部分
        if(flag) {
            now.next = slow;
            slow = slow.next;
        } else {
            now.next = fast;
            fast = fast.next;
        }
        now = now.next;
        flag = !flag;
    }
    return resultHead.next;
};
```

### 82. 删除排序链表中的重复元素 II

[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

慢指针指向已确认的无重复元素的最后一项，快指针初始状态下指向慢指针的next，内循环后应该指向重复元素的最后一项。

若内循环退出后，快指针仍然指向next，说明此处没有重复元素，两个指针同时后移。

```js
var deleteDuplicates = function(head) {
    let dummy = {next: head};
    let fast = head, slow = dummy;
    while(fast){
        while(fast.next && fast.next.val == fast.val){
            fast = fast.next;
        }
        if(slow.next != fast){
            slow.next = fast.next;
        }else{
            slow = slow.next;
        }
        fast = fast.next;
    }
    return dummy.next;
};

```



## 二叉树

### 前中后序遍历(速记323)

#### 前序遍历

```javascript
var preorderTraversal = function(root) {
    const res =[];
    const stack = [];
    while (root || stack.length){
      while(root){
        res.push(root.val);
        stack.push(root);
        root = root.left;
      }
      root = stack.pop();
      root = root.right;
    }
    return res;
};
```



```js
// 迭代的写法：
var preorderTraversal = function(root) {
  if(!root){
       return [];
    }
    var result = []
    var stack = [root]
    while(stack.length!==0){
       var top = stack.pop();
       if(top.right){
          stack.push(top.right);
       }
       if(top.left){
          stack.push(top.left);
       }
       result.push(top.val);
    }
    return result;
};

// 递归的写法：
var preorderTraversal = function(root) {
  if(!root){
    return [];
  }
  var result = []
  var preorderTraversalNode = (node) => {
      if(node) {
          result.push(node.val)
          preorderTraversalNode(node.left)
          preorderTraversalNode(node.right)
       }
   }
  preorderTraversalNode(root)
  return result
};
```



#### 中序遍历

```javascript
const inorderTraversal = (root) => {
    if(!root) return [];
  const res = [];
  const stack = [];
  while(root || stack.length){
      while(root){
          stack.push(root)
          root = root.left;
      }
     root = stack.pop();
     res.push(root.val);
     root = root.right;
  }
  return res;
};

// 递归的实现
var inorderTraversal = function(root) {
    if(!root){
       return [];
    }
    var result = []
    var inorderTraversalNode = (node) => {
        if(node) {  
            inorderTraversalNode(node.left)
            result.push(node.val)
            inorderTraversalNode(node.right)
         }
     }
    inorderTraversalNode(root)
    return result
};
```

#### 后序遍历

```javascript
var postorderTraversal = function(root) {
    const res =[];
    const stack = [];
    while (root || stack.length){
      while(root){
        stack.push(root);
        res.unshift(root.val);
        root = root.right;
      }
      root = stack.pop();
      root = root.left;
    }
    return res;
};

```



```js
// 迭代的实现：
var postorderTraversal = function(root) {
    if(!root){
       return [];
    }
    var result = []
    var stack = [root]
    while(stack.length!==0){
       var top = stack.pop();
       result.unshift(top.val);
       if(top.left){
          stack.push(top.left);
       }
       if(top.right){
          stack.push(top.right);
       }
     
    }
    return result;
};

// 递归的实现
var postorderTraversal = function(root) {
    if(!root){
       return [];
    }
    var result = []
    var postorderTraversalNode = (node) => {
        if(node) {  
            postorderTraversalNode(node.left)
            result.push(node.val)
            postorderTraversalNode(node.right)
         }
     }
    postorderTraversalNode(root)
    return result
};
```



### 102.二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```javascript
var levelOrder = function(root) {
    let res=[],queue=[]
    queue.push(root)
    if(root===null){
        return res
    }
    while(queue.length!==0){
        let length=queue.length
        let curLevel=[]
        for(let i=0;i<length;i++){
            let node=queue.shift()
            curLevel.push(node.val)
            node.left&&queue.push(node.left)
            node.right&&queue.push(node.right)
        }
        res.push(curLevel)
    }
    return res;
};
```



### 107.二叉树的层序遍历 II

[107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

DFS

```js
var levelOrderBottom = function(root) {
    let res = []
    let queue = []
    if (root) {
        let level = 0
        queue.push({ node: root, level })
        while (queue.length) {
            const item = queue.shift()
            const node = item.node
            const level = item.level
            if (level === res.length) {
                res.unshift([])
            }
            res[0].push(node.val)
            node.left && queue.push({ node: node.left, level: level + 1 })
            node.right && queue.push({ node: node.right, level: level + 1 })
        }
    }
    return res
};

```

BFS

```js
var levelOrderBottom = function(root) {
    const res = []
    if (root) {
        const queue = [root]
        while (queue.length) {
            const len = queue.length
            const temp = []
            for (let i = 0; i < len; i++) {
                const node = queue.shift()
                temp.push(node.val)
                node.left && queue.push(node.left)
                node.right && queue.push(node.right)
            }
            res.unshift(temp)
        }
    }
    return res
};

```



### 103. 二叉树的锯齿形层序遍历

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

使用广度优先遍历的方式，始终从左往右遍历，然后锯齿形的结果通过结果的从前压入和从后压入实现。

```js
var zigzagLevelOrder = function(root) {
    let queue = []
    let ans = []
    let level = 0

    // 空树，直接返回ans
    if(root == null) {
        return ans
    }

    queue.push(root)

    while(queue.length) {
        let length = queue.length
        let isToLeft = level % 2 == 1 // 顺序是否从右到左
        let levelList = []

        for(let i = 0 ; i < length; ++ i) {
            let node = queue.shift() // 和普通的广度优先遍历一样使用队列，先进先出
            console.log('node: ', node)

            isToLeft
            ? levelList.unshift(node.val) // 该层从右往左，从数组前面压入node.val
            : levelList.push(node.val) // 该层从左往右，从数组前面压入node.val

            // 子节点仍然和普通的广度优先遍历一样，从左往右压入队列中
            if(node.left != null) {
                queue.push(node.left)
            }
            if(node.right != null) {
                queue.push(node.right)
            }
        }

        ans[level++] = levelList // 保存该层结果，level自增1
        

    }

    return ans

};
```

### 958. 二叉树的完全性检验

[958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

 完全二叉树通过层序遍历最后的子节点都是null 如果出现了null但又出现了真实节点，直接返回false

```js
var isCompleteTree = function(root) {
    let queue=[root];
		let end=false
		while(queue.length){
			let size=queue.length;
			for(let i=0;i<size;i++){
				let cur=queue.shift()
				if(cur==null) end=true
				else{
					if(end) return false
					queue.push(cur.left)
					queue.push(cur.right)
				}
			}
		}
		return true
};
```

### 124. 二叉树中的最大路径和

[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```javascript
const maxPathSum = (root) => {
    let maxSum = Number.MIN_SAFE_INTEGER;//初始化最大路径和

    const dfs = (root) => {
        if (root == null) {//遍历节点是null 返回0
           return 0;
        }
        const left = dfs(root.left);   //递归左子树最大路径和
        const right = dfs(root.right); //递归右子树最大路径和
        maxSum = Math.max(maxSum, left + root.val + right);      //更新最大值
      	//返回当前子树的路径和 分为走左边、右边、不动 3种情况
        const pathSum = root.val + Math.max(0, left, right);
        return pathSum < 0 ? 0 : pathSum;
    };
    dfs(root);
    return maxSum; 
};
```

### 543. 二叉树的直径

[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点

经过一个node，其左右子树的最大深度之和 + 1（二叉树的根节点深度为0）
定义一个递归函数 depth(node)
计算 node 为起点的 路径经过节点数 res
函数返回该节点为 根的子树的深度

**时间复杂度：O(n)** n为**二叉树的节点** 遍历n
**空间复杂度：O(Height)** 常数变量 递归的深度为**二叉树的高度**

```js
var diameterOfBinaryTree = function(root) {
    let res = 0
    depth(root)
    return res
    function depth (node) {
        if (!node) return 0 // 节点不存在返回0
        let left = depth(node.left) // left为左子树的深度
        let right = depth(node.right)//right 为右子树的深度
        res = Math.max(left + right, res) //计算l+r 更新res
        return Math.max(left, right)+1 //返回该节点为根的子树的深度
    }
};
```

### 101. 对称二叉树

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)



### 226. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```js
function invertTree(root){
	if(!root) return null
	const queue=[root]
	while(queue.length){
		const node=queue.shift()

		const temp=node.right;
		node.right=node.left;
		node.left=temp;
		
		node.left&&queue.push(node.left)
		node.right&&queue.push(node.right)

	}
	return root
}
```

### 112. 路径总和

[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

#### dfs深度优先遍历

1.定义一个res为false
2.进行dfs深度遍历 一直向下找 找到叶子节点并且之前经过的节点路径和==targetSum时便改变res为true
3.返回res 如果有符合的路径和那么res就会被改变返回值为true 如果没有路径和那么返回的就是一开始的res=false

```js
var hasPathSum = function(root, targetSum) {
        if(!root) return 0
        let res = false
        const dfs = (root,sum)=>{
        if(!root) return
        if(sum==targetSum && (!root.left && !root.right) ){
            res = true
        }
        if(root.left)  dfs(root.left,sum+root.left.val)
        if(root.right)  dfs(root.right,sum+root.right.val)
        }
        dfs(root, root.val)
        return res
};
```

//时间复杂度为O(n) 因为深度遍历了节点
//空间复杂度为O(n) 这里使用了递归存在函数调用堆栈 n就是这个栈的高度 在最坏的情况下n为n 最好的情况下n为logn

```js
var hasPathSum = function(root, targetSum) {
	const traversal = (node, cnt) => {
		if(cnt===0&&!node.left&&!node.right) return true
		if(!node.left&&!node.right) return false
		if(node.left&&traversal(node.left,cnt-node.left.val)) return true
		if(node.right&&traversal(node.right,cnt-node.right.val)) return true
		return false

	}
	if(!root) return false
	return traversal(root,targetSum-root.val)
};
```



#### bfs广度优先遍历

1.进行bfs时 使用队列保存到达每一个节点时的路径和 如果该路径和恰好等于targetSum并且无子节点那么就输出true
2.如果循环结束后都没有return true 那么说明没有路径和等于targetSum 直接在最后返回false

```js
var hasPathSum = function(root, targetSum) {
    if (!root) return 0
    const stack = [[root, root.val]]
    while (stack.length) {
        const [p,l] = stack.shift()
        if(l == targetSum && !p.left && !p.right ) return true
        if (p.left) stack.push([p.left,l+p.left.val])
        if (p.right) stack.push([p.right, l+p.right.val])
    }
    return false
};

```

#### 递归

观察我们可以发现 targetSum应该等于根节点的val加上其某条路径上面的所有子节点的val和 故依次递推如果存在某条路径和等于targetSum 那么这条路径上面的叶子节点的值应该等于targetSum减去除叶子节点外的节点值之和

```js
var hasPathSum = function(root, targetSum) {
    if(!root) return false
    if(targetSum==root.val&&!root.left&&!root.right) return true
    return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val)
};

```

129. ### 求根节点到叶节点数字之和

[129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

```js
var sumNumbers = function(root) {
    const dfs=(root,path)=>{
        if(root==null) return 0;
        path=path*10+root.val
        if(!root.left&&!root.right) return path
        return dfs(root.left,path)+dfs(root.right,path)
    }
    return dfs(root, 0);
};
```

### 104. 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```js
var maxDepth = function (root) {
	//使用递归的方法 递归三部曲
	//1. 确定递归函数的参数和返回值
	const getdepth = function (node) {
		//2. 确定终止条件
		if (node === null) {
			return 0;
			
		}
		//3. 确定单层逻辑
		let leftdepth = getdepth(node.left);
		let rightdepth = getdepth(node.right);
		let depth = 1 + Math.max(leftdepth, rightdepth);
		return depth;

	}
	return getdepth(root);

};
```

### 105. 从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```js
var buildTree = (preorder, inorder) => {

  //当preorder和inorder均为空的时候说明已经到了空节点
  if (!preorder.length || !inorder.length) return null;

  //创建根节点 -> preorder[0]
  let node = new TreeNode(preorder[0]);

  //找到preoder[0]对应inorder中的位置
  let index = inorder.indexOf(preorder.shift());

  //左右子树递归
  node.left = buildTree(preorder, inorder.slice(0, index));
  node.right = buildTree(preorder, inorder.slice(index + 1));

  //返回根节点
  return node;
};

```

### 199. 二叉树的右视图

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```js
var rightSideView = function(root) {
		const res=[]
		const dfs=(root,depth)=>{
		if(!root) return null
		if(depth===res.length){
			res.push(root.val)
		}
		depth++		
		dfs(root.right,depth)   //顺序不能变 右边则要在前面  同一层优先选右边
		dfs(root.left,depth)
		
		
	}
	dfs(root,0)
	return res
};
```

### 230. 二叉搜索树中第K小的元素

[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

使用中序遍历二叉搜索树，得到升序排序数组，然后直接返回数组中第k小的元素即可

```js
var kthSmallest = function(root, k) {
    const res = [];
    // 看到是二叉搜索树应该想到使用中序遍历得到树节点排序好的升序数组
    function traversal(node){
        if (node){
            traversal(node.left);
            res.push(node.val);
            traversal(node.right);
        }
    }
    traversal(root);
    // 输出升序数组第k个最小的元素 下标为 k - 1
    return res[k - 1];
};

```

### 236. 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）

```js
var lowestCommonAncestor = function(root, p, q) {
    const travelTree=function(root,p,q){
			if(root===null||root===p||root===q){
				return root
			}
			let left=travelTree(root.left,p,q)
			let right =travelTree(root.right,p,q)
			if (left !== null && right !== null) {//如果在某一个节点的左右子树都能找到p和q说明这个节点就是公共祖先
				return root
			}
			if(left===null){
				return right
			}
			return left
		}
		return travelTree(root,p,q)
};
```



##  单调栈

### 20. 有效的括号

[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```javascript
var isValid = function (s) {
	let m = s.length
	if (m % 2 !== 0) return false
	let map = new Map([
		['{', '}'],
		['(', ')'],
		['[', ']']
	])
	let stk = []
	for (ch of s) {
		if (map.has(ch)) {
			stk.push(ch)
			//console.log(stk);
		} else {
			if (map.get(stk[stk.length - 1]) !== ch || stk.length == 0) return false
			else stk.pop()
		}
	}
	if (stk.length == 0) return true
	else return false
};
```

### 739. 每日温度

[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

```javascript
const dailyTemperatures = (T) => {
	const res = new Array(T.length).fill(0)
	const stack = []
	for (let i = T.length - 1; i >= 0; i--) {
		while (stack.length && T[i] >= T[stack[stack.length - 1]]) {
			stack.pop()
		}
		if (stack.length) {
			res[i] = stack[stack.length - 1] - i
		}
		stack.push(i)
	}
	return res
}
```

224. ### 基本计算器

[224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

匹配到加减号 加号把符号栈最后一位赋值给sign 减号取反 每次匹配到(将当前sign压入符号栈，匹配到)出栈 匹配到数字时 一直匹配直到不是数字时，res+=当前数字*sign

```js
var calculate = function(s) {
		let str=s.replaceAll(' ','')
		let sign=1;
		let ops=[1]
		let i=0,res=0;
		while(i<str.length){
			if(str[i]==='+'){
				sign=ops[ops.length-1]
			}else if(str[i]==='-'){
				sign=-ops[ops.length-1];
			}else if(str[i]==='('){
				ops.push(sign)
			}else if(str[i]===')'){
				ops.pop()
			}else{
				let num=''
				while(i<str.length&&!(isNaN(Number(str[i])))){
					num+=str[i]
					i++;
				}
				i--;
				res+=sign*Number(num)
			}
			i++
		}
			return res
			
	}
```

### 232. 用栈实现队列

[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）

```js
/* 
使用两个栈，s1中存储的是后入队的元素，s2中存储的是先入队的元素
入队时，元素默认存储在s1。
出队时，默认从s2进行出栈操作，如果s2为空，则将s1中元素转移到s2。
如果s2有值，则队首在s2的栈顶。否则，队首在top。
由于s1的元素只有在pop时才会转移到s2，因此只有两个栈都为空时，队列才为空。


*/
var MyQueue = function() {
	this.s1=[]
	this.s2=[]
	this.top=null
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
		if(!this.s1.length){
			this.top=x
		}
		this.s1.push(x)
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
		if(this.s2.length){
			return this.s2.pop()
		}
		while(this.s1.length){
			this.s2.push(this.s1.pop())
		}
		return this.s2.pop()
};	

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
	// 如果s2中有元素，则栈顶即为队首
	if (this.s2.length) {
		return this.s2[this.s2.length - 1];
	}

	// s2中无元素，则此时队首在top
	return this.top;


};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
	// 由于s1的元素只有在pop时才会转移到s2，因此判空时要两个栈一起判断
	return !this.s1.length && !this.s2.length;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```



## 排序

### 快速排序

```javascript
const partition=(arr)=>{
    let x=arr[0]
    let length=arr.length
    let i=0
    let j=length-1
    while(i<j){
        // 先从后往前找小的, 没找到继续找
        while(i<j&&arr[j]>x){
            j--;
        }    
        // 找到了，将a[j]值填入坑里, a[j]又变成了坑
        if(i<j){
            arr[i]=arr[j]
        }
        // 然后从前往后找大的，没找到继续找
        while(i<j&&arr[i]<x){
            i++
        }    
        // 找到了，将值填入之前的坑里
        if(i<j){
            arr[j]=arr[i];
        }
    }
    a[i]=x;
    return arr;

}
const a = [2, 1, 3, 6, 4, 5, 9, 8, 7];
let result = partition(a);
console.log(result);
```

### 215. 数组中的第K个最大元素

[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

其实没有必要全部排序，可以利用快速排序的 partition 操作，找到第 K 个最大元素。

每进行一次快速排序的 partition 操作，就能找到这次我们选中的基准值排序之后的正确位置。

如果它的位置刚好是排序之后第 K 个最大元素的位置，即 len - k，我们直接得到了答案；
因为进行 partition 操作之后，位于基准值之前的元素都要小于基准值，位于基准值之后的元素都要大于等于基准值。

如果它的位置小于排序之后第 K 个最大元素的位置，我们就去它之后寻找第 K 个最大元素；
如果它的位置大于排序之后第 K 个最大元素的位置，我们就去它之前寻找第 K 个最大元素；

分治选择排序，然后修正位置

```javascript
var findKthLargest = function (nums, k) {
  const len = nums.length;
  const targetIndex = len - k;
  let left = 0,right = len - 1;

  while (left < right) {
    const index = partition(nums, left, right);
    if (index === targetIndex) {
      return nums[index];
    } else if (index < targetIndex) {
      left = index + 1;
    } else {
      right = index - 1;
    }
  }

  return nums[left];
};

function partition(nums, start, end) {
  const povit = nums[start];
  while (start < end) {
    while (start < end && nums[end] >= povit) {
      end--;
    }
    nums[start] = nums[end];
    while (start < end && nums[start] < povit) {
      start++;
    }
    nums[end] = nums[start];
  }
  nums[start] = povit;
  return start;
}
```

### 165. 比较版本号

[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)

```javascript
var compareVersion = function (version1, version2) {
	let v1 = version1.split(".");
	let v2 = version2.split(".");
	let len = Math.max(v1.length, v2.length)
	for (let i = 0; i <len ; i++) {
		let tempV1 = Number(v1[i] ?? 0)
		let tempV2 = Number(v2[i] ?? 0)
		if (tempV1 > tempV2) return 1;
		if (tempV1 < tempV2) return -1;
		// 如果相等则跳过继续进行循环
	}
	
	return 0;
};
```

### 215. 数组中的第K个最大元素

[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

快排法

```js
var findKthLargest = function (nums, k) {
  const len = nums.length;
  const targetIndex = len - k;
  let left = 0,
    right = len - 1;

  while (left < right) {
    const index = partition(nums, left, right);
    if (index === targetIndex) {
      return nums[index];
    } else if (index < targetIndex) {
      left = index + 1;
    } else {
      right = index - 1;
    }
  }

  return nums[left];
};

function partition(nums, start, end) {
  const povit = nums[start];
  while (start < end) {
    while (start < end && nums[end] >= povit) {
      end--;
    }
    nums[start] = nums[end];
    while (start < end && nums[start] < povit) {
      start++;
    }
    nums[end] = nums[start];
  }
  nums[start] = povit;
  return start;
}

```

56. 合并区间

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

```js
var merge = function(intervals) {
		intervals.sort((a,b)=>a[0]-b[0])
		let prev=intervals[0]
		let result=[]
		for(let i=0;i<intervals.length;i++){
			let cur=intervals[i]
			if(cur[0]>prev[1]){
				result.push(prev)
				prev=cur
			}else{
				prev[1]=Math.max(cur[1],prev[1])
			}
		}
		result.push(prev)
		return result
};
```

### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列

-   例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
-   类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。

思路：从后往前遍历 如果遇到后一个大于前一个就跳出 并记录下标j

然后再对j~length 进行遍历  如果发现比之前大的就进行一个交换  大的数换到前面

j右边的数进行翻转，使得变大的幅度小一些

```js
var nextPermutation = function(nums) {
    let j = -1;
    for(let i = nums.length - 2 ; i >= 0; i --) {
        if(nums[i] < nums[i + 1]) {
            j = i;
            break;
        }
    }
    if(j == -1) 
      //如果 j = -1，说明是递减排列
        nums.reverse();
    else {
        for(let i = nums.length - 1; i > j; i --) {
            if(nums[i] > nums[j]) {
                [nums[i], nums[j]] = [nums[j], nums[i]];
                break;
            }
        }
        let i = j + 1, k = nums.length - 1;
        while(i < k) {
            [nums[i], nums[k]] = [nums[k], nums[i]];
            i ++, k --;
        }
    }
};
```

### [148. 排序链表](https://leetcode.cn/problems/sort-list/)

```js
// 归并排序
var sortList = function (head) {
  if (!head || head.next === null) return head;
  // 使用快慢指针找到中间节点
  let slow = head,
    fast = head.next;
  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
  }
  // 将链表分成两半并返回后半部分链表的头节点
  let newList = slow.next;
  slow.next = null;

  // 对前后两个链表进行排序
  let left = sortList(head);
  let right = sortList(newList);
  // 将排序好的两个有序链表合并为一个链表
  let res = new ListNode(-1);
  let nHead = res;
  // 合并链表只需要调整指针的指向
  // 两个链表哪个节点的值小就先指向它
  while (left !== null && right !== null) {
    if (left.val < right.val) {
      nHead.next = left;
      left = left.next;
    } else {
      nHead.next = right;
      right = right.next;
    }
    nHead = nHead.next;
  }
  nHead.next = left === null ? right : left;
  return res.next;
};
```

### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

先将两数组排序，然后根据两数组长度判断，中位数取一个还是两个平均值，返回结果。

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

```js
var findMedianSortedArrays = function(nums1, nums2) {
    let len1 = nums1.length;
    let len2 = nums2.length;
    let middle;
    let flag;
    if ((len1 + len2) % 2 === 0) {
        middle = parseInt((len1+len2)/2);
        flag = 0;
    } else {
        middle = parseInt((len1+len2)/2) + 1;
        flag = 1;
    }
    let i=0, j=0;
    let arr = [];
    while(i < len1 && j < len2) {
        if (nums1[i] < nums2[j]) {
            arr.push(nums1[i]);
            i++;
        } else {
            arr.push(nums2[j]);
            j++;
        }
    }
    if (i === len1) {
        arr = arr.concat(nums2.slice(j));
    }

    if (j === len2) {
        arr = arr.concat(nums1.slice(i));
    }

    if (flag === 0) {
        return parseFloat((arr[middle-1] + arr[middle]) / 2);
    } else {
        return arr[middle-1];
    }
};

```

### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

1.首先将nums[i]放到对应的位置，如nums[0] = 1，nums[1] = 2，....，nums[6] = 7
2.然后遍历交换位置之后的数组，判断是否是对应位置，若不是，则直接返回当前索引值 + 1；若全都是，则直接返回nums.length + 1即可

```js
var firstMissingPositive = function(nums) {
    for(let i = 0; i < nums.length; i++) {
      	// 循环nums，当前元素在(0,nums.length]之间，并且nums[nums[i]-1] != nums[i]，则交换位置
        while(nums[i] > 0 && nums[i] <= nums.length && nums[nums[i]-1] != nums[i]) {
            const temp = nums[nums[i]-1];
            nums[nums[i]-1] = nums[i];
            nums[i] = temp;
        }
    }
    for(let i = 0; i < nums.length; i++) {// 循环交换位置之后的数组，判断第一个缺失的正数
        if(nums[i] != i+1) {
            return i+1;
        }
    }
	// [1,2,3]
    return nums.length + 1;
};

```

## 分治

### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

```js
var search = function (nums, target) {
	let l = 0, r = nums.length - 1;
	while (l <= r) {
		let mid = (l + r) >> 1;
		if (nums[mid] === target) return mid;
		let isSmall = nums[mid] < target;
		l = isSmall ? mid + 1 : l;
		r = isSmall ? r : mid - 1;
	}

	return -1;
};
```

### [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

```javascript
var peakIndexInMountainArray = function(arr) {
  let left = 1,
    right = arr.length - 1;
  // 左闭右闭区间
  while (left <= right) {
    // 中间值  下面这样写是防止大数情况下溢出
    let mid = left + ((right - left) >> 1);
    // 如果这个数字比它前后两个数字都大
    if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {
      return mid;
    }
    // 如果这个数字比它前一个数字大，但比后一个数字小，那么这个数字位于数组递增的部分，
    // 数组的最大值一定在它的后面
    if (arr[mid] > arr[mid - 1]) {
      left = mid + 1;
    } else {
      // 如果这个数字比它前一个数字小，但比后一个数字大，那么这个数字位于数组递减的部分，
      // 数组的最大值一定在它的前面
      right = mid - 1;
    }
  }
  return -1;
};
```

### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

```js
var mySqrt = function(x) {
	let left=1,right=x;
	while(left<=right){
		let mid=left+((right-left)>>1)
		if(mid<=x/mid){
			if(mid+1>x/(mid+1)){
				return mid
			}
			left=mid+1
		}else{
			right=mid-1
		}
	}
	return 0;
};
```



## 递归

### 递归求1-100的和

```js
//正常递归
function sum(n){
	if(n == 1){
		return 1;
	   }
	return sum(n - 1) + n;
}
console.log(sum(100));


//尾递归
function add (n,sum){
    if(n<=0) return sum
    return add(n-1,n+sum)
}
add(100,0)
```

### 200. 岛屿数量

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

#### dfs:

思路：循环网格，深度优先遍历每个坐标的四周，注意坐标不要越界，遇到陆地加1，并沉没四周的陆地，这样就不会重复计算
复杂度：时间复杂度O(mn), m和n是行数和列数。空间复杂度是O(mn),最坏的情况下所有网格都需要递归，递归栈深度达到m * n

```js
const numIslands=(grid)=>{
	let count=0;
	for(let i=0;i<grid.length;i++){
		for(let j=0;j<grid[0].length;j++){
			if(grid[i][j]=='1'){
				count++;
				turnZero(i,j,grid)
			}
		}
	}
	return count
}
function turnZero(i,j,grid){
	if(i<0||i>=grid.length||j<0||j>=grid[0].length||grid[i][j]==='0')  return 
	grid[i][j]='0';
	turnZero(i,j+1,grid)
	turnZero(i,j-1,grid)
	turnZero(i+1,j,grid)
	turnZero(i-1,j,grid)
}
```

#### bfs:

思路：循环网格，广度优先遍历坐标的四周，遇到陆地加1，沉没四周的陆地，不重复计算陆地数
复杂度：时间复杂度O(mn),m和n是行数和列数。空间复杂度是O(min(m，n)),队列的长度最坏的情况下需要能容得下m和n中的较小者

```js
const numIslands=(grid)=>{
	let count=0
	let queue=[]
	for(let i=0;i<grid.length;i++){
		for(let j=0;j<grid[0].length;j++){
			if(grid[i][j]==='1'){
				count++
				grid[i][j] = '0' // 做标记，避免重复遍历
				queue.push([i, j]) //加入队列
				turnZero(queue, grid)
			}
		}
	}
	return count
}

function turnZero(queue,grid){
	const dirs=[[0,1],[1,0],[0,-1],[-1,0]] //上 右 下 左
	while(queue.length){
		const cur=queue.shift()
		for (const dir of dirs) {  //四个方向广度优先扩散
			const x=cur[0]+dir[0]
			const y=cur[1]+dir[1]
			if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] !== '1') {
				continue
			}//检查坐标合法性
			grid[x][y]='0' //沉迷陆地
			queue.push([x,y])
		}
	}
}
```



### 695. 岛屿的最大面积

[695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

#### dfs

```js
var maxAreaOfIsland = function(grid) {
		let row =grid.length,col=grid[0].length
		function dfs(x,y){
		if(x<0||x>=row||y<0||y>=col||grid[x][y]===0) return 0
			grid[x][y]=0
			let ans=1,dx=[-1,1,0,0],dy=[0,0,1,-1]
			for(let i=0;i<dx.length;i++){
				ans+=dfs(x+dx[i],y+dy[i])
			}
			return ans
		}
		let res=0
		for(let i=0;i<row;i++){
			for(let j=0;j<col;j++){
				res=Math.max(res,dfs(i,j))
			}
		}
		return res
};

var maxAreaOfIsland = function(grid) {
    let max = 0;
    let count = 0;
    function dfs(row, col) {
        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] === 0) {
            return 0;
        }
        grid[row][col] = 0;
        count = 1
        count += dfs(row+1, col)
        count += dfs(row-1, col)
        count += dfs(row, col+1)
        count += dfs(row, col-1)
        return count;
    }
    for(let i = 0; i < grid.length; i++) {
        for(let j = 0; j < grid[0].length; j++){
            if(grid[i][j] === 1) {
                max = Math.max(max, dfs(i, j))
            }
        }
    }
    return max;
};

```

#### BFS

```js
var maxAreaOfIsland = function(grid) {
  const m = grid.length;
  const n = grid[0].length;
  let maxArea = 0;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] === 1) {
        const queue = [[i, j]];
        grid[i][j] = 0;
        let area = 0;
        while (queue.length) {
          const [curI, curJ] = queue.shift();
          area++;
          [[-1, 0], [0, 1], [1, 0], [0, -1]].forEach(item => {
            const x = curI + item[0];
            const y = curJ + item[1];
            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] === 1) {
              queue.push([x, y]);
              grid[x][y] = 0;
            }
          });
        }
        maxArea = Math.max(maxArea, area);
      }
    }
  }
  return maxArea;
};
```



### 22. 括号生成

[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

```js
var generateParenthesis = function(n) {
		const res=[];
		var dfs=(LRemain,RRemain,str)=>{
			if(str.length==2*n){
				res.push(str);
				return;
			}
			//裁剪
			if(LRemain>0){
				dfs(LRemain-1,RRemain,str+"(");

			}
			if(LRemain<RRemain){
				dfs(LRemain,RRemain-1,str+")");
			}
		}
		dfs(n,n,"");
		return res;
};
```

## 回溯

### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```javascript
var permute = function(nums) {
	const res=[],path=[];
	backtracking(nums,nums.length,[]);
	return res;
	
	function backtracking(n,k,used){
		if(path.length===k){
			res.push(Array.from(path));
			return ;
		}
		for(let i=0;i<k;i++){
			if(used[i]) continue;
			path.push(n[i]);
			used[i]=true;
			backtracking(n,k,used);
			path.pop();
			used[i]=false;
		}
	}
};
```

### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```js
var restoreIpAddresses = function (s) {
		const res=[],path=[];
		backtracking(0,0)
		return res;
		function backtracking(i){
			const len=path.length;
			if(len>4) return
			if(len===4&&i===s.length){
				res.push(path.join("."));
				return
			}
			for(let j=i;j<s.length;j++){
				const str=s.substr(i,j-i+1)
				if(str.length>3||+str>255) break;
				if(str.length>1&&str[0]==='0') break;
				path.push(str)
				backtracking(j+1)
				path.pop()
			}
		}

}
```

## 贪心









## 动态规划

### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```javascript
var climbStairs = function (n) {
	if (n <= 1) return n;
	a = 1;
	b = 2;
	for (let i = 3; i <= n; i++) {
		sum = a + b;
		a = b;
		b = sum;
	}
	return b;
}
```

### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

````js
var fib = function(n) {
    let n1 = 0, n2 = 1, sum;
    for(let i = 0; i < n; i++){
        sum = (n1 + n2) % 1000000007;
        n1 = n2;
        n2 = sum;
    }
    return n1;
};

````

### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

https://github.com/lzxjack/coding-interviews

```js
var lastRemaining = function(n, m) {
    let now = 0;
    for(let i = 2; i <= n; i++) {
        now = (now + m) % i;
    }
    return now;
};
```



### 5. 最长回文子串

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

```js
var longestPalindrome = function(s) {
		let n=s.length
		let res=''
		let dp=Array.from(new Array(n),()=>new Array(n).fill(false))
		for(let i=n-1;i>=0;i--){
			for(let j=i;j<n;j++){
				dp[i][j]=s[i]===s[j]&&(j-i<2||dp[i+1][j-1])
				if(dp[i][j]&&j-i+1>res.length){
					res=s.substring(i,j+1)
				}
			}
		}
		return res
};
```

### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

```js
var uniquePaths = function(m, n) {
	const dp=Array(m).fill().map(()=>Array(n).fill(1));
	for(let i=0;i<m;i++){
		dp[i][0]=1;
	}
	for(let i=0;i<n;i++){
		dp[0][i]=1;
	}
	for(let i=1;i<m;i++){
		for(let j=1;j<n;j++){
            //要么从左 要么从上 来继承状态
			dp[i][j]=dp[i-1][j]+dp[i][j-1];
		}
	}
	return dp[m-1][n-1];
}
```



### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```js
const minPathSum = grid => {
	const [m, n] = [grid.length, grid[0].length];
	const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

	dp[0][0] = grid[0][0];
	for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
	for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];

	for (let i = 1; i < m; i++) {
		for (let j = 1; j < n; j++) {
			dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
		}
	}
	return dp[m - 1][n - 1];
};
```



### 121. 买卖股票的最佳时机

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**限定交易次数 k=1**

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润

```js
var maxProfit = function(prices) {
	const len=prices.length
	const dp = new Array(len).fill([0,0])
	  dp[0][0] = 0; // 持有现金
    dp[0][1] = -prices[0]; // 持有股票
	for (let i = 1; i < prices.length; i++){
    
		dp[i][0]=Math.max(dp[i-1][0],-prices[i]);  //不持有股票 保持前一天现状 前一天就卖掉  或者今天卖了
		dp[i][1]=Math.max(dp[i-1][1],prices[i]+dp[i-1][0])   //持有股票 手里没钱
	}
	return dp[len-1][1]
};
```

状态压缩  `dp[i]` 只和 `dp[i - 1]` 有关，去掉一维

```js
//时间复杂度O(n) 空间复杂度O(1)
const maxProfit = function (prices) {
    let n = prices.length;
    let dp = Array.from(new Array(n), () => new Array(2));
    dp[0] = 0;
    dp[1] = -prices[0];
    for (let i = 1; i < n; i++) {
        dp[0] = Math.max(dp[0], dp[1] + prices[i]);
        dp[1] = Math.max(dp[1], -prices[i]);
    }
    return dp[0];
};


const maxProfit = function (prices) {
    let n = prices.length;
    let sell = 0;
    let buy = -prices[0];
    for (let i = 1; i < n; i++) {
        sell = Math.max(sell, buy + prices[i]);
        buy = Math.max(buy, -prices[i]);
    }
    return sell;
};
```

贪心

```js
var maxProfit = function (prices) {
	let lowerPrice = prices[0];// 重点是维护这个最小值（贪心的思想） 
	let profit = 0;
	for (let i = 0; i < prices.length; i++) {
		lowerPrice = Math.min(lowerPrice, prices[i]);// 贪心地选择左面的最小价格
		profit = Math.max(profit, prices[i] - lowerPrice);// 遍历一趟就可以获得最大利润
	}
	return profit;
};
```



### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

**交易次数无限制 k = +infinity**

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多 只能持有 一股 股票**。你也可以先购买，然后在 同一天 出售

状态：持有现金`dp[i][0]`、持有股票`dp[i][1]`；
如果持有现金，则可能昨天也持有现金`dp[i-1][0]`或者昨天持有股票并卖出，取得收益

`dp[i-1][1]+prices[i]`;
如果持有股票，则可能昨天也持有股票`dp[i-1][1]`或者昨天花掉现金，买入股票

`dp[i-1][0]-prices[i]`;

```js
var maxProfit = function(prices) {
    var dp = [
        []
    ];
    if(prices<1){
        return 0;
    }
    dp[0][0] = 0; // 持有现金
    dp[0][1] = -prices[0]; // 持有股票
    for (var i = 1; i < prices.length; i++) {
        if (!dp[i]) {
            dp[i] = [];
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[prices.length - 1][0]
};
```

状态压缩

```js
const maxProfit = function (prices) {
    let n = prices.length;
    let dp = Array.from(new Array(n), () => new Array(2));
    dp[0] = 0;
    dp[1] = -prices[0];
    for (let i = 1; i < n; i++) {
        dp[0] = Math.max(dp[0], dp[1] + prices[i]);
        dp[1] = Math.max(dp[1], dp[0] - prices[i]);
    }
    return dp[0];
};


//语意化
const maxProfit = function (prices) {
    let n = prices.length;
    let sell = 0;
    let buy = -prices[0];
    for (let i = 1; i < n; i++) {
        sell = Math.max(sell, buy + prices[i]);
        buy = Math.max(buy, sell - prices[i]);
    }
    return sell;
};
```



### [516.最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

```js
var longestPalindromeSubseq=function(s){
	const n=s.length
	const dp=new Array(n).fill(0).map(()=>new Array(n).fill(0))
	for(let i=0;i<n;i++){
		dp[i][i]=1
	}
	for(let i=n-1;i>=0;i--){
		for(let j=i+1;j<n;j++){
			if(s[i]=s[j]){
				dp[i][j]=dp[i+1][j-1]+2   //如果左右端点的相等 直接通过内层状态进行转移
			}else{
				dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1])  //不相等  则进行左右各选取一个进行状态结果比较
			}
		}
	}
	return dp[0][n-1]
}
```



### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目

```js
var countSubstrings=function(s){
	const n=s.length;
	let ans=0;
	let dp=Array.from(Array(n),()=>Array(n).fill(false))
	for(let j=0;j<n;j++){
		for(let i=0;i<=j;i++){
			if(s[i]===s[j]){
				if(j-i<2){
					dp[i][j]=true
				}else{
					dp[i][j]=dp[i+1][j-1]
				}
				ans+=dp[i][j]?1:0
			}
		}
	}
	return ans
}
```



### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```js
var lengthOfLIS = function (nums) {
  const dp = new Array(nums.length).fill(1);
  for (let i = 0; i < nums.length; i++) {
    // i与i前面的元素比较
    for (let j = 0; j < i; j++) {
      // 找比i小的元素，找到一个，就让当前序列的最长子序列长度加1
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  // 找出最大的子序列
  return Math.max(...dp);
};
```

### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```js
var coinChange = function(coins, amount) {
	let dp=new Array(amount+1).fill(Infinity)
	dp[0]=0
	for(let i=1;i<=amount;i++){
		for(let coin of  coins){
			if(i-coin>=0){
				dp[i]=Math.min(dp[i],dp[i-coin]+1)
			}
		}
	}
	return dp[amount]===Infinity?-1:dp[amount]
};
```



### [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

```js
var findLength = function(nums1, nums2) {
		const m=nums1.length;
		const n=nums2.length;
		const dp=new Array(m+1)
		for(let i=0;i<=m;i++){
			dp[i]=new Array(n+1).fill(0)
		}
		let res=0
		for(let i=1;i<=m;i++){
			for(let j=1;j<=n;j++){
				if(nums1[i-1]===nums2[j-1]){
					dp[i][j]=dp[i-1][j-1]+1
				}
				res=Math.max(dp[i][j],res)
			}
		}
		return res
};
```



### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

```js
const minimumTotal = (triangle) => {
	const h = triangle.length;
	// 初始化dp数组
	const dp = new Array(h);
	for (let i = 0; i < h; i++) {
		dp[i] = new Array(triangle[i].length);
	}

	for (let i = h - 1; i >= 0; i--) { // 自底而上遍历
		for (let j = 0; j < triangle[i].length; j++) { // 同一层的
			if (i == h - 1) {  // base case 最底层
				dp[i][j] = triangle[i][j];
			} else { // 状态转移方程，上一层由它下面一层计算出
				dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];
			}
		}
	}
	return dp[0][0];
};
```



### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**在当前位置 `n` 房屋可盗窃的最大值，要么就是 `n-1` 房屋可盗窃的最大值，要么就是 `n-2` 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值**

```js
var rob = function(nums) {
    const len = nums.length;
    if(len == 0)
        return 0;
    const dp = new Array(len + 1);
    dp[0] = 0;
    dp[1] = nums[0];
    for(let i = 2; i <= len; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
    }
    return dp[len];
};
```

### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

```js
var longestCommonSubsequence=(text1,text2)=>{
	let m=text1.length,n=text2.length
	let dp=Array(m+1).fill(0).map(()=>Array(n+1).fill(0))
	for(let i=1;i<=m;i++){
		for(let j=1;j<=n;j++){
			if(text1[i-1]===text2[j-1]){
				dp[i][j]=dp[i-1][j-1]+1
			}else {
				dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1])
			}
		}
	}
	return dp[m][n]
}
```



## 设计数据结构

### [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

```javascript
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.map = new Map();
    this.capacity = capacity;
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if(this.map.has(key)){
        let value = this.map.get(key);
        this.map.delete(key); // 删除后，再 set ，相当于更新到 map 最后一位
        this.map.set(key, value);
        return value
    } else {
        return -1
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    // 如果已有，那就要更新，即要先删了再进行后面的 set
    if(this.map.has(key)){
        this.map.delete(key);
    }
    this.map.set(key, value);
    // put 后判断是否超载
    if(this.map.size > this.capacity){
        this.map.delete(this.map.keys().next().value);
    }

};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */

```

### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)
