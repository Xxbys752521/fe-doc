# 算法题

## 数组

### 88. 合并两个有序数组

[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

从后往前遍历  

```javascript
var merge = function(nums1, m, nums2, n) {
		let i=m-1,j=n-1,k=m+n-1;
		while(i>=0||j>=0){
			if(i<0)nums1[k--]=nums2[j--];
			else if (j<0) nums1[k--]=nums1[i--];
			else if(nums1[i]<nums2[j]) nums1[k--]=nums2[j--];
			else nums1[k--]=nums1[i--];
		}
		return nums1;
};
```

### 54. 螺旋矩阵

[54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

```js
var spiralOrder = function (matrix) {
	if (matrix.length === 0) return []
	const res = []
	let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1
	while (top < bottom && left < right) {
		for (let i = left; i < right; i++) res.push(matrix[top][i])   // 上层
		for (let i = top; i < bottom; i++) res.push(matrix[i][right]) // 右层
		for (let i = right; i > left; i--) res.push(matrix[bottom][i])// 下层
		for (let i = bottom; i > top; i--) res.push(matrix[i][left])  // 左层
		right--
		top++
		bottom--
		left++  // 四个边界同时收缩，进入内层
	}
	if (top === bottom) // 剩下一行，从左到右依次添加
		for (let i = left; i <= right; i++) res.push(matrix[top][i])
	else if (left === right) // 剩下一列，从上到下依次添加
		for (let i = top; i <= bottom; i++) res.push(matrix[i][left])
	return res
};
```

### 384. 打乱数组（洗牌算法）

[384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)

```js
class Solution {
    constructor(nums) {
        this.nums = nums;
        // 保存原始数组
        this.original = [...this.nums];
    }
    reset() {
        this.nums = [...this.original];
        return this.nums;
    }
    shuffle() { //洗牌算法
        const len = this.nums.length;
        for (let i = 0; i < len; i++) {
            // 获取区间[i,len-1]范围内的随机整数j
            const j = i + Math.floor(Math.random() * (this.nums.length - i));
            // 交换位置
            [this.nums[i], this.nums[j]] = [this.nums[j], this.nums[i]];
        }
        return this.nums;
    }
}
```

### 48. 旋转图像

[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

```js
var rotate = function (matrix) {
	const n = matrix.length;
	// 先水平翻转
	for (let i = 0; i < n / 2; i++) {
		for (let j = 0; j < n; j++) {
			[matrix[i][j], matrix[n - i - 1][j]] = [matrix[n - i - 1][j], matrix[i][j]]
		}
	}
	// 再对角线翻转
	for (let i = 0; i < n; i++) {
		for (let j = 0; j < i; j++) {
			[matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]
		}
	}
};
```

### 498. 对角线遍历

[498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/)

先上后下

```javascript
var findDiagonalOrder = function (matrix) {
	if (matrix.length < 1) return [];
	let res = [],
		flag = true,  // true-右上 /  false-左下
		i = j = 0,
		n = matrix.length,
		m = matrix[0].length;

	while (i < n && j < m) {
		res.push(matrix[i][j]);
		m = matrix[i].length; // 每行的长度
		if (flag) {
			//  右上移动 i-=1; j+=1 
			i -= 1;
			j += 1;
		} else {
			// 左下移动 i+=1; j-=1
			i += 1;
			j -= 1;
		}
		// 处理边界 -- 转弯
		if (i < 0 || j < 0 || i == n || j == m) {
			if (flag) {
				// 右上
				if (j < m) i = 0; // 上边越界，像右移动
				else {
					// 右边越界，向下移动
					i += 2;
					j--;
				}
			} else {
				// 左下
				if (i < n) j = 0; // 左边越界， 像下移动
				else {
					// 下边越界， 想右移动
					i--;
					j += 2;
				}
			}
			flag = !flag; // 转换方向
		}
	}
	return res;
};
```

先下后上

```javascript

var findDiagonalOrder = function (matrix) {
	if (matrix.length < 1) return [];
	let res = [],
		flag = true,  // true-右上 /  false-左下
		i = j = 0,
		n = matrix.length,
		m = matrix[0].length;

	while (i < n && j < m) {
		res.push(matrix[i][j]);
		m = matrix[i].length; // 每行的长度
		if (flag) {
			// 左下移动 i-=1; j+=1 
				i += 1;
			j -= 1;
		} else {
			// 右上移动 i+=1; j-=1
		i -= 1;
			j += 1;
		}
		// 处理边界 -- 转弯
		if (i < 0 || j < 0 || i == n || j == m) {
			if (flag) {
				// 右上
				if (i < m) j = 0; // 上边越界，像右移动
				else {
					// 右边越界，向下移动
					j += 2;
					i--;
				}
			} else {
				// 左下
				if (j < n) i = 0; // 左边越界， 像下移动
				else {
					// 下边越界， 想右移动
					j--;
					i += 2;
				}
			}
			flag = !flag; // 转换方向
		}
	}
	return res;
};
var mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
console.log(findDiagonalOrder(mat)); 
```

### 二维数组放大

```js
var arr = [
    [0,1],
    [1,0]
];

var newArr = [];
function bigArr(n,k,arr){
    for(let i = 0; i < n;i++){
        for(let j = 0; j < n; j++){
            let temp = arr[i][j];
            // console.log(temp);
            for(let ii = i*k; ii<i*k + k; ii++){
                //newArr[ii] = new Array(n*k);
                for(let jj = j*k; jj <j*k+k; jj++){
                    //newArr[ii] = new Array(n*k);
                    newArr[ii][jj]=temp;
                    // console.log(temp);
                    // console.log('ii:' + ii);
                    // console.log('jj:' + jj);
                    // console.log(newArr[ii][jj]);                   
                }
            }
        }
    }
    return newArr
}
var newA = bigArr(arr.length,3,arr)
console.log('原始数组：' );
console.log(arr);
console.log('放大倍数k:'+ 3);
console.log('放大后的数组:' );
console.log(newA);
```



## 双指针/滑动窗口

### 3. 无重复字符的最长子串

[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

双指针移动 

```javascript
var lengthOfLongestSubstring = function(s) {
 var cnt={};
    var res=0;
    var j=0;
for(let i=0;i<s.length;i++)
    {
        if(s[i] in cnt) cnt[s[i]]++;//存在重复 值加1
        else cnt[s[i]]=1;
        while (cnt[s[i]]>=2)
            {
                cnt[s[j]]--;//相当于删除窗口之外的元素
                j++; //右移
                //cnt[s[j++]]--;
            }
        res=Math.max(res,i-j+1);
    }
    return res;
};
```


15. ### 三数之和

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```js
var threeSum = function(nums) {
		const len=nums.length;
		if(len<3) return [];
		nums.sort((a,b)=>a-b);
		const res=[];
		for(let i=0;i<len-2;i++){
			if(nums[i]>0) break;
			if(i>0&&nums[i]===nums[i-1]) continue;
			let left=i+1,right=len-1;
			while(left<right){
				const sum=nums[i]+nums[left]+nums[right];
				if(sum<0) {left++;continue }
				if(sum>0){right--;continue}
				res.push([nums[i],nums[left],nums[right]]);
                //去重
				while(left<right&&nums[left]===nums[left+1]) left++
                while(left<right&&nums[right]===nums[right-1])  right--
                left++
                right--
			}
            
		}
		return res;
};
```
18. ### 四数之和

[18. 四数之和](https://leetcode.cn/problems/4sum/)

返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` 

```js
var fourSum = function(nums, target) {
    let len = nums.length;
    if(len < 4) return [];

    nums.sort((a, b) => a - b); // 排序
    
    let result = [];
    for(let i = 0; i < len - 3; i++) {
        if(i > 0 && nums[i] === nums[i - 1]) // 去重
            continue;

        for(let j = i + 1; j < len - 2; j++) {
            if(j > i + 1 && nums[j] === nums[j - 1]) // 去重
                continue;

            let left = j + 1; // 左指针初始化
            let right = len - 1; // 右指针初始化

            while(left < right) {
                if(nums[i] + nums[j] + nums[left] + nums[right] > target) {
                    right--; // 如果大于0，右指针左移，让和小一点
                } else if(nums[i] + nums[j] + nums[left] + nums[right] < target) {
                    left++; // 如果小于0，左指针右移，让和大一点
                } else {
                    result.push([nums[i], nums[j], nums[left], nums[right]]);
                    while(left < right && nums[right] === nums[right - 1]) {
                        right--; // 去重
                    }
                    while(left < right && nums[left] === nums[left + 1]) {
                        left++; // 去重
                    }
                    // 找到一个符合条件的四元组了，两指针同时收缩
                    right--;
                    left++;
                }
            }
        }
        
    }
    return result;
};
```

209. ### 长度最小的子数组

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```js
const minSubArrayLen = (s, nums) => {
  let minLen = Infinity;
  let i = 0;
  let j = 0;
  let sum = 0;
  while (j < nums.length) {   // 主旋律是扩张，找可行解
    sum += nums[j];
    while (sum >= s) {        // 间歇性收缩，优化可行解
      minLen = Math.min(minLen, j - i + 1);
      sum -= nums[i];
      i++;
    }
    j++;
  }
  return minLen === Infinity ? 0 : minLen; // 从未找到可行解，返回0
};

```

### 42. 接雨水

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

```js
var trap = function(height) {
    const len = height.length;
    let sum = 0;
    for(let i = 0; i < len; i++){
        // 第一个柱子和最后一个柱子不接雨水
        if(i == 0 || i == len - 1) continue;
        let rHeight = height[i]; // 记录右边柱子的最高高度
        let lHeight = height[i]; // 记录左边柱子的最高高度
        for(let r = i + 1; r < len; r++){
            if(height[r] > rHeight) rHeight = height[r];
        }
        for(let l = i - 1; l >= 0; l--){
            if(height[l] > lHeight) lHeight = height[l];
        }
        let h = Math.min(lHeight, rHeight) - height[i];
        if(h > 0) sum += h;
    }
    return sum;
};

```

### 283. 移动零

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

```js
var moveZeroes = function(nums) {
		if(nums==null){
			return
		}
		let j=0;
		for(let i=0;i<nums.length;i++){
			if(nums[i]!==0){
				let temp=nums[i];
				nums[i]=0;
				nums[j++]=temp;
			}
		}
};
```



## 字符串

### kmp算法

#### 什么是KMP算法

说到*KMP*，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。

因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP

#### KMP有什么用

假设现在有一个`文本字符串` **aabaabaaf** 和一个`模板字符串` **aabaaf**，现在要求在`文本串`中找出`模板串`出现的第一个位置 (从0开始)。如果不存在，则返回 -1。

相信很多同学一开始可能都想到双重for循环的暴力解法，遍历`文本串`从下标 *0* 到下标 *5* 时，发现下标5指向的 **b** 与`模板串`中下标5指向的 **f** 不匹配，故又从`文本串`的下标 *1* 重新开始下一轮匹配，此时显然时间复杂度是O(m*n)，*m、n*分别是文本串与模板串的字符串长度。

例子中不难看出，最终答案应该是当我们遍历`文本串`第四轮，即从下标 *3* 开始匹配的字符串与`模板串`相同，但是这样就除了**初始从 \*0\* 匹配** 和**最终从 \*3\* 匹配**外，多了两次从1匹配和从2匹配的多余步骤，那么该怎么通过我们**初始从 \*0\* 匹配**中得到的数据（可以理解为“失败的经验”）中智能的跳过必定失败的遍历步骤呢？

此时我们发现，`文本串`中 *0~2* 位的**aab**是和*3~5* 位一样的，都能与`模板串`前几位匹配上，也就是说我们第一次匹配失败后，第二次完全可以从文本串下标为 *3* 的地方开始第二轮遍历，这就可以帮助我们省略掉了`文本串`中从下标*1*和下标*2*开始访问的，这就是KMP算法的主要思想`当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。`

好了，理解完***KMP算法***的核心思想，我们接下来就来研究它如何*如何记录已经匹配的文本内容* 和 *通过记录跳过多余匹配步骤*，首先，让我们引入两个重要的知识点：***前缀表***和***next数组***

#### 前缀表

##### ***前缀***、***后缀***、***最长公共前后缀***

前缀是指*不包含最后一个字符的所有以第一个字符开头的连续子串*
后缀是指*不包含第一个字符的所有以最后一个字符结尾的连续子串*
例如我们上述`模板串`**aabaaf**中，前缀就包括：a,aa,aab,aaba.aabaa；后缀有：f,af,aaf,baaf,abaaf

那么，我们可以引出我们的`最长公共前后缀(也叫做最长相等前后缀)`：即一个字符串的 *前缀集* 和 *后缀集* 中最长的相等字串。上文中`模板串`**aabaaf**的前后缀集可以看出没有相等字串，所以它的最长相等前后缀为0

如： 字符串a的最长相等前后缀为0(注意字符串的前后缀定义，故单字符没有前后缀）；字符串aa的最长相等前后缀为1；字符串aaa的最长相等前后缀为2；等.....。

##### ***前缀表***

`前缀表：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。`
前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。 这就涉及到计算完整的前缀表:

![image-20221004085142495](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/Imgs/image-20221004085142495.png)解释一下：

- 长度为前1个字符的子串**a**最长相同前后缀的长度为0；
- 长度为前2个字符的子串**aa**最长相同前后缀的长度为1；
- 长度为前3个字符的子串**aab**最长相同前后缀的长度为0；
- 长度为前4个字符的子串**aaba**最长相同前后缀的长度为1；
- 长度为前5个字符的子串**aabaa**最长相同前后缀的长度为2；
- 长度为前6个字符的子串**aabaaf**最长相同前后缀的长度为0。

截至到目前，我们把前缀表算了出来。可以看出模板串与前缀表对应位置的数字表示的就是：*下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。*

##### 前缀表怎么用 / 为什么一定要用前缀表

前缀表为啥就能告诉我们 上次匹配的位置，并跳过去呢？
回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图：
![image-20221004085153704](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/Imgs/image-20221004085153704.png)找到的不匹配的位置，那么此时我们要看它的前一个字符的前缀表的数值是多少。为什么要前一个字符的前缀表的数值呢，

> 下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀和后缀字符串是 子字符串aa ，我们可以通过对称思想，我可以拿模板串当前失败的后缀作为下一轮匹配的前缀（这样就省去了匹配公共前后缀片段的必失败轮次）。因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。

前一个字符的前缀表的数值是2， 所有把下标移动到下标2的位置继续比配（*为什么移到2，因为相同前后缀的原因，后缀段aa肯定在文本串中已经匹配过了，那么我们可以替换为文本串已经匹配过前缀段aa了，也就是说文本串已经匹配成功前缀表数字代表的数量的字符了，即匹配完两个了从下标2第三个匹配起*）。然后就找到了下标2，指向b，继续匹配：如图：![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d73eef8ea1e647c2bc1b572fb582e37e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。

#### next数组

##### 什么是next数组

**next数组**可以理解为就是把抽象的前缀表实例化，我们在做题中同样也是构造next数组来运用前缀表这种方法，而不同的使用next数组的方法因人而异，但原理是一样的只是在最终比较的时候有所出入，我们拿`模板串` **aabaaf**举例：

- 前缀表【0 1 0 1 2 0】作为next数组，比较到**f**跟文本串有出入，回退到上一位的前缀表对应的 *2* 作为下一次匹配的起始下标处
- 前缀表【-1 0 1 0 1 2】作为next数组，就是将第一种的前缀表整体右移，初始值赋予 *-1（或者存储字符串长度）*，比较到**f**跟文本串有出入，直接拿**f**的前缀表对应的数值作为下一次匹配的起始下标处、
- 前缀表【-1 0 -1 0 1 -1】作为next数组，就是将第一种的前缀表*整体-1*，比较到**f**跟文本串有出入，回退到上一位的前缀表对应的*值+1*作为下一次匹配的起始下标处

`那么使用next数组的时间复杂度分析`：其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

暴力的解法显而易见是O(n × m)，所以*KMP在字符串匹配中极大的提高的搜索的效率。*

##### 构造next数组（难点）

**构造next数组**就是对于题中给到的模板串，我们封装一个函数可以算出模板串的前缀表并返回的过程，算出前缀表的过程核心思想就是：`接收模板串作为参数；i指针指向后缀末尾，j指针指向前缀末尾（注意：j还代表i位置之前子串的最长相等前后缀长度），i每次向后移动1位，求出以i指向字符为结尾的子串的最大相同前后缀，作为前缀表此位置next[i]的值`

```js
// 计算前缀表采用第一种方法（不右移也不减一）
const getNext = function(needle){
    let j = 0;   //j初始值从0，第一位开始
    let next = [];
    next[0] = j;  //数组next[0]为0，首位(单位)字符肯定没有前后缀
    for(let i=1; i<needle.length; i++){   //注意i从1开始
        // 前后缀不相同
        while (j>0 && needle[i] !== needle[j]){   //j要保证大于0，回退过程中比较前缀尾j与后缀尾i是否相等
            j = next[j-1];  //j回退到上一位，j到字符串首位还不相等说明当前i作为终止位的字串没有最长相等前后缀，next[i]赋值0
        }
        // 前后缀相同
        if (needle[i] === needle[j]){
            j++; //相同，j此时指向的是前缀字符串（上一级），要同时向后移动j和i准备下一轮匹配（移动i在for循环里）
        }
        next[i] = j;// 将j（前缀的长度）赋给next[i]
    }
    return next;
}
```

对于难点:**为什么j同时表示最长相等前后缀？**

> j是前缀的末尾，也代表着前缀的长度，如果j不断地移进，说明i作为后缀的末尾正在遍历的部分与j作为前缀的末尾正在遍历的部分相同，相同的部分就是“相等前后缀”，那么j代表的数值就是“内容为从0位置开始到i的位置的字符串”的最大相等前后缀长度。

对于难点:**为什么"前后缀不匹配时"，要用while循环持续回退？**

> 首先要知道next数组对应的是前缀表，前缀表也称部分匹配表。该数组中的值代表着该子串中的最长相等前后缀，也是子串中已经匹配好的长度。如next【4】=2，其对应的子串是aabaa，前缀aa和后缀aa已经匹配好了，长度为2，j指针此时也停留在2。
> 每次求next[i]，可看作前缀与后缀的一次匹配，在该过程中就可以用上之前所求的next，若匹配失败，则像模式串与父串匹配一样，将指针j移到next【j-1】上。
> 求next过程实际上只与前一个状态有关：
> 若不匹配，一直往前退到0或匹配为止
> 若匹配，则将之前的结果传递：
> 因为之前的结果不为0时，前后缀有相等的部分，所以j所指的实际是与当前值相等的前缀，可视为将前缀从前面拖了过来，就不必将指针从前缀开始匹配了，所以之前的结果是可以传递的。

##### 使用next数组来做匹配

```js
let haystack = "AAAAAAAAAAAAAAAAAB"
let needle = "AAAAB"

// 计算前缀表采用第一种方法（不右移也不减一）
const getNext = function (needle) {
	let j = 0;   //j初始值从0，第一位开始
	let next = [];
	next[0] = j;  //数组next[0]为0，首位(单位)字符肯定没有前后缀
	for (let i = 1; i < needle.length; i++) {   //注意i从1开始
		// 前后缀不相同
		while (j > 0 && needle[i] !== needle[j]) {   //j要保证大于0，回退过程中比较前缀尾j与后缀尾i是否相等
			j = next[j - 1];  //j回退到上一位，j到字符串首位还不相等说明当前i作为终止位的字串没有最长相等前后缀，next[i]赋值0
		}
		// 前后缀相同
		if (needle[i] === needle[j]) {
			j++; //相同，j此时指向的是前缀字符串（上一级），要同时向后移动j和i准备下一轮匹配（移动i在for循环里）
		}
		next[i] = j;// 将j（前缀的长度）赋给next[i]
	}
	return next;
}
function getAns(haystack, needle) {
	let next = getNext(needle); //获取前缀表next
	let j = 0; //j指针指向模式串起始位置
	for (let i = 0; i < haystack.length; i++) { //i指向文本串起始位置。
		while (j > 0 && haystack[i] !== needle[j]) //不相同，j就要从next数组里寻找下一个匹配的位置
			j = next[j - 1];
		if (haystack[i] === needle[j]) //如果相同，那么i 和 j 同时向后移动：
			j++; // i的增加在for循环里
		if (j === needle.length) //如果j指向了模式串的末尾，那么就说明模式串完全匹配文本串里的某个子串了。
			return (i - needle.length + 1);//返回当前在文本串匹配模式串的位置i减去模式串的长度，就是文本串字符串中出现模式串的第一个位置
	}
	return -1;//文本串中没有匹配的字串，依题返回-1
}
console.log(getAns(haystack, needle)); //13
```

关于***KMP算法***，主要的是理解它的`前缀表思想`: *拿模板串当前匹配失败的后缀作为下一轮匹配的前缀：这样就省去了匹配公共前后缀片段的必失败轮次* 可以带来的对时间复杂度的优化，难点在于如何构造 `next数组`

### 7. 整数反转

[7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

```javascript
var reverse = function (x) {
	let y = parseInt(x.toString().split("").reverse().join(""));
	if (x < 0)
		y = - y;
	return y > Math.pow(2, 31) - 1 || y < Math.pow(-2, 31) ? 0 : y;
};
```

### 415. 字符串相加

**[415. 字符串相加](https://leetcode-cn.com/problems/add-strings)**

```js
var addStrings = function(num1, num2) {
	if(num1===num2&&num1==='0')return num1
	num1=num1.split('').reverse()
	num2=num2.split('').reverse()
	const len =Math.max(num1.length,num2.length)
	let flag=0
	const result=[]
	for(let i=0;i<len;i++){
		const n1=+num1[i]||0
		const n2=+num2[i]||0
		let sum=n1+n2+flag
		flag=0
		if(sum>9){
			sum-=10
			flag=1  //进位1
		}
		result.push(sum)
	}
	if(flag) result.push(flag)
	return result.reverse().join("")
};
```

### 8. 字符串转换整数 (atoi)

[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

```js
var myAtoi = function (s) {
	let res = 0;
	let maxnum = 2 ** 31 - 1, minnum = (-2) ** 31
		// 正负号，默认正号
		negativeSymbol = 1;
	// 把首尾的空格都去掉
	   s = s.trim();
	for (let i = 0; i < s.length; i++) {
		// 负数
		if (i == 0 && s[i] == "-") {
			negativeSymbol = -1;
			continue;
			// 正数
		} else if (i == 0 && s[i] == "+") continue;
		// 因为空格会被转成0，所以要排除空格的情况，也就是说在数字范围内就加上
		if (s[i] >= 0 && s[i] <= 9 && s[i] != " ") {
			res = res * 10 + (s[i] - 0);
			// 为什么在这里就判断呢，因为这里如果就溢出的话，就直接跳出，不需要再后面无意义的计算了
			if (res * negativeSymbol <= minnum  ) return minnum;
			else if (res * negativeSymbol >= maxnum) return maxnum;
		} else break;
	}
	return res * negativeSymbol;
};
```

### 14. 最长公共前缀

[14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```js
var longestCommonPrefix = function(strs) {
		if(!strs.length) return "";
		res=strs[0]; //选定第一个为基准
		for(str of strs){
			for(let i=0;i<res.length;i++){
				if(str[i]!==res[i]){ //如果不相等
					res = res.slice(0, i);
				break;
			}
		}
		}
		return res;
};
```

### 43. 字符串相乘

[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

```js
var multiply = function (num1, num2) {
	if (num1 === '0' || num2 === '0') {
		return '0'
	}
	var l1 = num1.length, l2 = num2.length, p = new Array(l1 + l2).fill(0)
	for (var i = l1; i--;) {
		for (var j = l2; j--;) {
			var tmp = num1[i] * num2[j] + p[i + j + 1]
			p[i + j + 1] = tmp % 10
			p[i + j] += 0 | tmp / 10
		}
	}
	while (p[0] === 0) {
		p.shift()
	}
	return p.join('')
};
```



## 链表

### 206. 反转链表

[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```js
function ListNode(val, next) {
      this.val = (val===undefined ? 0 : val)
     this.next = (next===undefined ? null : next)
 }

var reverseList = function(head) {
	if(!head||!head.next) return head;
	let item =head;   
	let prev=null;   // prev   item    
	let next=item;
	while(item){
		next=item.next;    //  先把当前head的后一个存起来
        item.next=prev;   //   然后再把head的下一个指向前面  
		prev=item		//  整体后移 相当于进行了迭代 prev现在是之前的item	
		item=next         //    之前的item为item原来的后一个
	}
	return prev
};
```

### 92. 反转链表 II

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

```js
var reverseBetween = function (head, m, n) {
	// 用来记住整个链表的头节点位置
	let res = new ListNode(0)
	res.next = head
	// 找到需要反转的位置
	let pre = res
	for (let i = 1; i < m; ++i) {
		pre = pre.next
	}
	// 将head指向要反转的链表部分的头部   利用三个节点
	head = pre.next
	for (let i = m; i < n; ++i) {
		let nxt = head.next
		// nxt 节点要被放到反转部分的头部，所以将head的next指向它的下下个节点
		head.next = head.next.next
		// 将nxt放到头部，pre.next指向的是反转部分的头部节点
		nxt.next = pre.next
		// 重新将pre指向反转部分的头部 向前
		pre.next = nxt
	}
	return res.next
};
```

### 141. 环形链表

[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

hash表

```javascript
var hasCycle = (head) => {
    let map = new Map();
    while (head) {
        if (map.has(head)) return true;//如果当前节点在map中存在就说明有环
        map.set(head, true);//否则就加入map
        head = head.next;//迭代节点
    }
    return false;//循环完成发现没有重复节点，说明没环
};
```

双指针

```js
var hasCycle = function(head) {
    if(head === null) return false
    let slow = head, fast = head.next
    while(fast && fast.next) {
        if (slow.next === fast.next.next) return true
        slow = slow.next
        fast = fast.next.next
    }
    return false
};
```

### 142. 环形链表 II

[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。

```js
var detectCycle = function (head) {
	// 快慢指针初始化指向 head
	let slow = head;
	let fast = head;
	// 快指针走到末尾时停止
	while (fast && fast.next) {
		// 慢指针走一步，快指针走两步
		slow = slow.next;
		fast = fast.next.next;
		// 快慢指针相遇，说明含有环
		if (slow == fast) {
			// 任一一节点指向头节点
			fast = head;
			// 同步向前进
			while (fast != slow) {
				fast = fast.next;
				slow = slow.next;
			}
			// 返回入口节点
			return fast;
		}
	}
	// 不包含环
	return null;
};
```

### 21. 合并两个有序链表

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```js
var mergeTwoLists = function (l1, l2) {
	if (l1 === null) {
		return l2;
	} else if (l2 === null) {
		return l1;
	} else if (l1.val < l2.val) {
		l1.next = mergeTwoLists(l1.next, l2);
		return l1;
	} else {
		l2.next = mergeTwoLists(l1, l2.next);
		return l2;
	}
};
```

### 23. 合并K个升序链表

[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```js
var mergeKLists = function (lists) {
  // 当是空数组的情况下
  if (!lists.length) {
    return null;
  }
  // 合并两个排序链表
  const merge = (head1, head2) => {
    let dummy = new ListNode(0);
    let cur = dummy;
    // 新链表，新的值小就先接谁
    while (head1 && head2) {
      if (head1.val < head2.val) {
        cur.next = head1;
        head1 = head1.next;
      } else {
        cur.next = head2;
        head2 = head2.next;
      }
      cur = cur.next;
    }
    // 如果后面还有剩余的就把剩余的接上
    cur.next = head1 == null ? head2 : head1;
    return dummy.next;
  };
  const mergeLists = (lists, start, end) => {
    // base case  只有一个链接的情况
    if (start + 1 == end) {
      return lists[start];
    }
    // 输入的k个排序链表，可以分成两部分，前k/2个链表和后k/2个链表
    // 如果将这前k/2个链表和后k/2个链表分别合并成两个排序的链表，再将两个排序的链表合并，那么所有链表都合并了
    let mid = start + ((end - start) >> 1);
    let head1 = mergeLists(lists, start, mid);
    let head2 = mergeLists(lists, mid, end);
    return merge(head1, head2);
  };
  // 前闭后开
  return mergeLists(lists, 0, lists.length);
};
```

### 剑指 Offer 22. 链表中倒数第k个节点

[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

```js
var getKthFromEnd=function(head,k){
	let slow=head
	while(k--){
		head=head.next
	}
	while(head){
		slow=slow.next
		head=head.next
	}
	return slow

}
```

### 160. 相交链表

[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```javascript
var getIntersectionNode = function (headA, headB) {
	let a = headA,
		b = headB;
	while (a != b) {
		// a 走一步，如果走到 headA 链表末尾，转到 headB 链表
		a = a != null ? a.next : headB;
		// b 走一步，如果走到 headB 链表末尾，转到 headA 链表
		b = b != null ? b.next : headA;
	}
	return a;
};
```

### 25. K 个一组翻转链表

[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```js

var reverseKGroup = function (head, k) {
	if (!head) return null;
	let start = head, end = head;

	for (let i = 0; i < k; i++) {
		// 如果在还没遍历到第 k 个，end 空了，即 head 链表个数不满足 k 个，直接返回原链表
		if (!end) {
			return head;
		} else {
			end = end.next;
		}
	}

	let newHead = reverse(start, end); // 左闭右开区间
	start.next = reverseKGroup(end, k); // 翻转以后，原本的 start 指向的结点，变到了 end 的前一个，直接 start.next 继续递归翻转后续的就行
	return newHead;
};

// 反转区间 [a, b) 的元素，注意是左闭右开
function reverse(head, end) {
	let p = head, q, newHead; // p 在前面，q 跟在 p 的后面
	while (p !== end) {
		q = p; // q 赋值会原链表 p 的位置
		p = p.next; // p 继续向后遍历
		q.next = newHead;
		newHead = q;
	}
	return newHead;
};
```

### 19. 删除链表的倒数第 N 个结点

[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

先后指针：快指针先走n-1步后慢指针再开始从头节点开始走。当快指针走到最后一个结点的时候，慢指针就走到了倒数第N个结点。

```js
var removeNthFromEnd = function(head, n) {
  // 先指针先走n-1步
  let fast = head;
  for(let i=1; i<=n-1; i++) {
    fast = fast.next;
  }
  let slow = head;
  // 缓存要删除结点的前一个结点
  let pre = null;
  while(fast.next) {
    pre = slow;
    fast = fast.next;
    slow = slow.next;
  }
  // 如果要删除的结点是第一个结点的话，则直接返回slow.next
  if(pre === null) {
    return slow.next;
  }
  else {
    pre.next = slow.next;
  }
  return head;
}

```

### 2. 两数相加

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表

```js
var addTwoNumbers = function (l1, l2) {
	let head = null, tail = null;
	let carry = 0;
	while (l1 || l2) {
		const n1 = l1 ? l1.val : 0;
		const n2 = l2 ? l2.val : 0;
		const sum = n1 + n2 + carry;
		if (!head) {
			head = tail = new ListNode(sum % 10);
		} else {
			tail.next = new ListNode(sum % 10);
			tail = tail.next;
		}
		carry = Math.floor(sum / 10);
		if (l1) {
			l1 = l1.next;
		}
		if (l2) {
			l2 = l2.next;
		}
	}
	if (carry > 0) {
		tail.next = new ListNode(carry);
	}
	return head;
};
```

### 143. 重排链表

[143. 重排链表](https://leetcode.cn/problems/reorder-list/)

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```js
var reorderList = function(head) {
    if(!head.next) return head;

    let slow = head, fast = head.next; // slow 为第一个结点开始，fast 为第二个结点开始，这样结点总个数奇数或偶数都很好兼容
    // fast 走两步，不能一次性走两步，要一步一步走
    while(fast && fast.next) {
        slow = slow.next;
        fast = fast.next;
        // 对于 fast 第二步，需要先判断，如果 fast 后面还可以再走一步，才往后走
        if(fast.next) {
            fast = fast.next;
        }
    }

    // 现在 slow 和 fast 之间就是要翻转的部分了 (slow, fast]
    let newHead = null, p = slow.next, q;
    slow.next = null; // 前半部分和后半部分断开联系
    while(p) {
        q = p;
        p = p.next;
        q.next = newHead;
        newHead = q;
    }

    // 现在 newHead 就是后半段翻转后的样子，然后接下来跟前半部分 依次 插入新链表
    let resultHead = new ListNode(0), now = resultHead, flag = true;
    slow = head, fast = newHead;
    while(slow || fast) {
        // 通过 flag 控制现在插入 前半部分 还是 后半部分
        if(flag) {
            now.next = slow;
            slow = slow.next;
        } else {
            now.next = fast;
            fast = fast.next;
        }
        now = now.next;
        flag = !flag;
    }
    return resultHead.next;
};
```

### 82. 删除排序链表中的重复元素 II

[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

慢指针指向已确认的无重复元素的最后一项，快指针初始状态下指向慢指针的next，内循环后应该指向重复元素的最后一项。

若内循环退出后，快指针仍然指向next，说明此处没有重复元素，两个指针同时后移。

```js
var deleteDuplicates = function(head) {
    let dummy = {next: head};
    let fast = head, slow = dummy;
    while(fast){
        while(fast.next && fast.next.val == fast.val){
            fast = fast.next;
        }
        if(slow.next != fast){
            slow.next = fast.next;
        }else{
            slow = slow.next;
        }
        fast = fast.next;
    }
    return dummy.next;
};

```



## 二叉树

### 前中后序遍历(速记323)

#### 前序遍历

```javascript
var preorderTraversal = function(root) {
    const res =[];
    const stack = [];
    while (root || stack.length){
      while(root){
        res.push(root.val);
        stack.push(root);
        root = root.left;
      }
      root = stack.pop();
      root = root.right;
    }
    return res;
};
```



```js
// 迭代的写法：
var preorderTraversal = function(root) {
  if(!root){
       return [];
    }
    var result = []
    var stack = [root]
    while(stack.length!==0){
       var top = stack.pop();
       if(top.right){
          stack.push(top.right);
       }
       if(top.left){
          stack.push(top.left);
       }
       result.push(top.val);
    }
    return result;
};

// 递归的写法：
var preorderTraversal = function(root) {
  if(!root){
    return [];
  }
  var result = []
  var preorderTraversalNode = (node) => {
      if(node) {
          result.push(node.val)
          preorderTraversalNode(node.left)
          preorderTraversalNode(node.right)
       }
   }
  preorderTraversalNode(root)
  return result
};
```



#### 中序遍历

```javascript
const inorderTraversal = (root) => {
    if(!root) return [];
  const res = [];
  const stack = [];
  while(root || stack.length){
      while(root){
          stack.push(root)
          root = root.left;
      }
     root = stack.pop();
     res.push(root.val);
     root = root.right;
  }
  return res;
};

// 递归的实现
var inorderTraversal = function(root) {
    if(!root){
       return [];
    }
    var result = []
    var inorderTraversalNode = (node) => {
        if(node) {  
            inorderTraversalNode(node.left)
            result.push(node.val)
            inorderTraversalNode(node.right)
         }
     }
    inorderTraversalNode(root)
    return result
};
```

#### 后序遍历

```javascript
var postorderTraversal = function(root) {
    const res =[];
    const stack = [];
    while (root || stack.length){
      while(root){
        stack.push(root);
        res.unshift(root.val);
        root = root.right;
      }
      root = stack.pop();
      root = root.left;
    }
    return res;
};

```



```js
// 迭代的实现：
var postorderTraversal = function(root) {
    if(!root){
       return [];
    }
    var result = []
    var stack = [root]
    while(stack.length!==0){
       var top = stack.pop();
       result.unshift(top.val);
       if(top.left){
          stack.push(top.left);
       }
       if(top.right){
          stack.push(top.right);
       }
     
    }
    return result;
};

// 递归的实现
var postorderTraversal = function(root) {
    if(!root){
       return [];
    }
    var result = []
    var postorderTraversalNode = (node) => {
        if(node) {  
            postorderTraversalNode(node.left)
            result.push(node.val)
            postorderTraversalNode(node.right)
         }
     }
    postorderTraversalNode(root)
    return result
};
```



### 102. 二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```javascript
var levelOrder = function(root) {
    let res=[],queue=[]
    queue.push(root)
    if(root===null){
        return res
    }
    while(queue.length!==0){
        let length=queue.length
        let curLevel=[]
        for(let i=0;i<length;i++){
            let node=queue.shift()
            curLevel.push(node.val)
            node.left&&queue.push(node.left)
            node.right&&queue.push(node.right)
        }
        res.push(curLevel)
    }
    return res;
};
```



### 107. 二叉树的层序遍历 II

[107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

DFS

```js
var levelOrderBottom = function(root) {
    let res = []
    let queue = []
    if (root) {
        let level = 0
        queue.push({ node: root, level })
        while (queue.length) {
            const item = queue.shift()
            const node = item.node
            const level = item.level
            if (level === res.length) {
                res.unshift([])
            }
            res[0].push(node.val)
            node.left && queue.push({ node: node.left, level: level + 1 })
            node.right && queue.push({ node: node.right, level: level + 1 })
        }
    }
    return res
};

```

BFS

```js
var levelOrderBottom = function(root) {
    const res = []
    if (root) {
        const queue = [root]
        while (queue.length) {
            const len = queue.length
            const temp = []
            for (let i = 0; i < len; i++) {
                const node = queue.shift()
                temp.push(node.val)
                node.left && queue.push(node.left)
                node.right && queue.push(node.right)
            }
            res.unshift(temp)
        }
    }
    return res
};

```



### 103. 二叉树的锯齿形层序遍历

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

使用广度优先遍历的方式，始终从左往右遍历，然后锯齿形的结果通过结果的从前压入和从后压入实现。

```js
var zigzagLevelOrder = function(root) {
    let queue = []
    let ans = []
    let level = 0

    // 空树，直接返回ans
    if(root == null) {
        return ans
    }

    queue.push(root)

    while(queue.length) {
        let length = queue.length
        let isToLeft = level % 2 == 1 // 顺序是否从右到左
        let levelList = []

        for(let i = 0 ; i < length; ++ i) {
            let node = queue.shift() // 和普通的广度优先遍历一样使用队列，先进先出
            console.log('node: ', node)

            isToLeft
            ? levelList.unshift(node.val) // 该层从右往左，从数组前面压入node.val
            : levelList.push(node.val) // 该层从左往右，从数组前面压入node.val

            // 子节点仍然和普通的广度优先遍历一样，从左往右压入队列中
            if(node.left != null) {
                queue.push(node.left)
            }
            if(node.right != null) {
                queue.push(node.right)
            }
        }

        ans[level++] = levelList // 保存该层结果，level自增1
        

    }

    return ans

};
```

### 958. 二叉树的完全性检验

[958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

 完全二叉树通过层序遍历最后的子节点都是null 如果出现了null但又出现了真实节点，直接返回false

```js
var isCompleteTree = function(root) {
    let queue=[root];
		let end=false
		while(queue.length){
			let size=queue.length;
			for(let i=0;i<size;i++){
				let cur=queue.shift()
				if(cur==null) end=true
				else{
					if(end) return false
					queue.push(cur.left)
					queue.push(cur.right)
				}
			}
		}
		return true
};
```

### 124. 二叉树中的最大路径和

[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```javascript
const maxPathSum = (root) => {
    let maxSum = Number.MIN_SAFE_INTEGER;//初始化最大路径和

    const dfs = (root) => {
        if (root == null) {//遍历节点是null 返回0
           return 0;
        }
        const left = dfs(root.left);   //递归左子树最大路径和
        const right = dfs(root.right); //递归右子树最大路径和
        maxSum = Math.max(maxSum, left + root.val + right);      //更新最大值
      	//返回当前子树的路径和 分为走左边、右边、不动 3种情况
        const pathSum = root.val + Math.max(0, left, right);
        return pathSum < 0 ? 0 : pathSum;
    };
    dfs(root);
    return maxSum; 
};
```

### 112. 路径总和

[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

#### DFS深度优先遍历

1.定义一个res为false
2.进行dfs深度遍历 一直向下找 找到叶子节点并且之前经过的节点路径和==targetSum时便改变res为true
3.返回res 如果有符合的路径和那么res就会被改变返回值为true 如果没有路径和那么返回的就是一开始的res=false

```js
var hasPathSum = function(root, targetSum) {
        if(!root) return 0
        let res = false
        const dfs = (root,sum)=>{
        if(!root) return
        if(sum==targetSum && (!root.left && !root.right) ){
            res = true
        }
        if(root.left)  dfs(root.left,sum+root.left.val)
        if(root.right)  dfs(root.right,sum+root.right.val)
        }
        dfs(root, root.val)
        return res
};
```

时间复杂度为O(n) 因为深度遍历了节点
空间复杂度为O(n) 这里使用了递归存在函数调用堆栈 n就是这个栈的高度 在最坏的情况下n为n 最好的情况下n为logn

```js
var hasPathSum = function(root, targetSum) {
	const traversal = (node, cnt) => {
		if(cnt===0&&!node.left&&!node.right) return true
		if(!node.left&&!node.right) return false
		if(node.left&&traversal(node.left,cnt-node.left.val)) return true
		if(node.right&&traversal(node.right,cnt-node.right.val)) return true
		return false

	}
	if(!root) return false
	return traversal(root,targetSum-root.val)
};
```



#### BFS广度优先遍历

1.进行bfs时 使用队列保存到达每一个节点时的路径和 如果该路径和恰好等于targetSum并且无子节点那么就输出true
2.如果循环结束后都没有return true 那么说明没有路径和等于targetSum 直接在最后返回false

```js
var hasPathSum = function(root, targetSum) {
    if (!root) return 0
    const stack = [[root, root.val]]
    while (stack.length) {
        const [p,l] = stack.shift()
        if(l == targetSum && !p.left && !p.right ) return true
        if (p.left) stack.push([p.left,l+p.left.val])
        if (p.right) stack.push([p.right, l+p.right.val])
    }
    return false
};

```

#### 递归

观察我们可以发现 targetSum应该等于根节点的val加上其某条路径上面的所有子节点的val和 故依次递推如果存在某条路径和等于targetSum 那么这条路径上面的叶子节点的值应该等于targetSum减去除叶子节点外的节点值之和

```js
var hasPathSum = function(root, targetSum) {
    if(!root) return false
    if(targetSum==root.val&&!root.left&&!root.right) return true
    return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val)
};
```

### 129. 求根节点到叶节点数字之和

[129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

```js
var sumNumbers = function(root) {
    const dfs=(root,path)=>{
        if(root==null) return 0;
        path=path*10+root.val
        if(!root.left&&!root.right) return path
        return dfs(root.left,path)+dfs(root.right,path)
    }
    return dfs(root, 0);
};
```

### 105. 从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```js
var buildTree = (preorder, inorder) => {

  //当preorder和inorder均为空的时候说明已经到了空节点
  if (!preorder.length || !inorder.length) return null;

  //创建根节点 -> preorder[0]
  let node = new TreeNode(preorder[0]);

  //找到preoder[0]对应inorder中的位置
  let index = inorder.indexOf(preorder.shift());

  //左右子树递归
  node.left = buildTree(preorder, inorder.slice(0, index));
  node.right = buildTree(preorder, inorder.slice(index + 1));

  //返回根节点
  return node;
};

```

### 230. 二叉搜索树中第K小的元素

[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

使用中序遍历二叉搜索树，得到升序排序数组，然后直接返回数组中第k小的元素即可

```js
var kthSmallest = function(root, k) {
    const res = [];
    // 看到是二叉搜索树应该想到使用中序遍历得到树节点排序好的升序数组
    function traversal(node){
        if (node){
            traversal(node.left);
            res.push(node.val);
            traversal(node.right);
        }
    }
    traversal(root);
    // 输出升序数组第k个最小的元素 下标为 k - 1
    return res[k - 1];
};

```



### 543. 二叉树的直径

[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点

经过一个node，其左右子树的最大深度之和 + 1（二叉树的根节点深度为0）
定义一个递归函数 depth(node)
计算 node 为起点的 路径经过节点数 res
函数返回该节点为 根的子树的深度

**时间复杂度：O(n)** n为**二叉树的节点** 遍历n
**空间复杂度：O(Height)** 常数变量 递归的深度为**二叉树的高度**

```js
var diameterOfBinaryTree = function(root) {
    let res = 0
    depth(root)
    return res
    function depth (node) {
        if (!node) return 0 // 节点不存在返回0
        let left = depth(node.left) // left为左子树的深度
        let right = depth(node.right)//right 为右子树的深度
        res = Math.max(left + right, res) //计算l+r 更新res
        return Math.max(left, right)+1 //返回该节点为根的子树的深度
    }
};
```

### 101. 对称二叉树

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

递归

```js
var isSymmetric = function (root) {
	if(!root) return true;
	const isMirror=(l,r)=>{
		if(!l&&!r) return true;
		if(l&&r){
			if(l.val===r.val&&isMirror(l.left,r.right)&&isMirror(l.right,r.left)){
				return true
			}
		}
		return false
	}

	return isMirror(root.left,root.right)
}
```

BFS

维护一个队列，起初，根节点（如果存在）的左右子树入列
每次出列一对节点，考察它们俩是否对称
如果不对称，那整个树就不对称，结束BFS，如果对称，则下一对节点入列
哪些情况不对称：
一个为 null 一个不为 null，直接返回 false
都存在，但 root 值不同，直接返回 false

```js
const isSymmetric = (root) => {
  if (root == null) return true; 

  const queue = [];
  queue.push(root.left, root.right);  // 起初入列两个子树

  while (queue.length) {  // 队列清空就结束，没有节点可入列了
    const levelSize = queue.length; // 当前层的节点个数
    for (let i = 0; i < levelSize; i += 2) { // 当前层的节点成对出列
      const left = queue.shift();   
      const right = queue.shift();  // 出列一对节点
      if ((left && right == null) || (left == null && right)) { // 一个存在 一个不存在
        return false;
      }
      if (left && right) { // 两个都存在
        if (left.val != right.val) { // 节点值不同，不对称
          return false;
        }
        queue.push(left.left, right.right); // 推入下一层的一对节点
        queue.push(left.right, right.left); // 推入下一层的一对节点
      }
    }
  }
  return true; // bfs结束，始终没有返回false，则返回真
};
```

```js
var isSymmetric = function(root) {
  let stack = [];
  if (!root) return true;
  stack.push(root.left, root.right);
  while (stack.length > 0) {
    const right = stack.pop();
    const left = stack.pop();
    if (left === null && right === null) {
      // 节点为空什么都不做
    } else if (left && right && left.val === right.val) {
      //左左节点和对称右右节点入栈
      stack.push(left.left);
      stack.push(right.right);
      //左右节点和对称右左节点入栈
      stack.push(left.right);
      stack.push(right.left);
    } else {
      return false;
    }
  }
  return true;
};
```

**栈模拟递归**

```js
var isSymmetric = (root) => {
  if (!root) return true
  let leftStack = [], rightStack = [] // 维护两个栈
  let curLeft = root.left             // 当前的左子树
  let curRight = root.right           // 当前的右子树
  while (curLeft || curRight || leftStack.length || rightStack.length) {
    while (curLeft) {         // 左子树存在
      leftStack.push(curLeft) // 推入leftStack栈
      curLeft = curLeft.left  // 不断将左子树入栈
    }
    while (curRight) {          // 右子树存在
      rightStack.push(curRight) // 推入rightStack栈
      curRight = curRight.right // 不断将右子树压入栈
    }
    if (leftStack.length !== rightStack.length) return false
                                // 栈的高度不相等，说明结构不对称
    curLeft = leftStack.pop()   // 栈顶节点出栈，赋给curLeft
    curRight = rightStack.pop() // 栈顶节点出栈，赋给curRight
    if (curLeft.val !== curRight.val) return false
                                // 两个栈出栈的节点值不相等 不对称
    curLeft = curLeft.right     // 考察左子树的right
    curRight = curRight.left    // 考察右子树的left
  }
  return true
}
```



### 100. 相同的树

[100. 相同的树](https://leetcode.cn/problems/same-tree/)

DFS

```js
function isSameTree(p, q) {
    if (p == null && q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false
    }
    if (p.val !== q.val) {
        return false
    }

    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

BFS

把树节点分别加入队列, 看出队的节点是否一样即可

```js
var isSameTree = function(p, q) {
  let pQ = [p]
  let qQ = [q]
  while(pQ.length && qQ.length){
    let pc = pQ.shift()
    let qc = qQ.shift()
    if(pc && qc && pc.val != qc.val || (!pc && qc || pc && !qc)) return false
    if(pc){
      pQ.push(pc.left)
      pQ.push(pc.right)
    }
    if(qc){
      qQ.push(qc.left)
      qQ.push(qc.right)
    }
  }
  return true
};
```

序列化

```js
var isSameTree = function(p, q) {
  return JSON.stringify(p) === JSON.stringify(q)
};
```



### 637. 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

DFS先递归后计算

将节点和层数作为递归参数，递归终止条件为当前节点不存在。

```js
var averageOfLevels = function(root) {
    const helper = (root, level) => {
        // 如果为空那么结束递归
        if (!root) {
            return
        }
        // 如果当前层还没赋值，那么直接赋值 [root.val]
        // 否则 push root.val
        if (!nodes[level]) {
            nodes[level] = [root.val]
        } else {
            nodes[level].push(root.val)
        }
        // 递归左子树
        helper(root.left, level + 1)
        // 递归右子树
        helper(root.right, level + 1)
    }
    // 节点值保存到这个数组（将来是二维）
    let nodes = []
    // 递归
    helper(root, 0)
    // 求已保存好的每层节点的平均值
    return nodes.map((node) => {
        return node.reduce((prev, curr) => prev + curr) / node.length
    })
};
```

BFS

使用BFS（广度优先遍历），在遍历的过程中，将每层的节点值保存在队列中，然后将所有值出栈并相加。除以当前层的队列的长度就是这一层的平均值。将其放入结果中。重复上述步骤，直到遍历完整棵二叉树，返回最后的结果

```js
var averageOfLevels = function(root) {
    if(!root){
        return []
    }
    const res = []
    const queue = []

    queue.push(root)
    
    while(queue.length){
        const len = queue.length
        let sum = 0
        for(let i = 0; i < len; i++){
            const cur = queue.shift()
            sum += cur.val
            if(cur.left){
                queue.push(cur.left)
            }
            if(cur.right){
                queue.push(cur.right)
            }
        }
        res.push(sum / len)
    }
    return res
};
```

### 199. 二叉树的右视图

[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

1. 层次遍历二叉树；
2. 将每一层的最后一个节点值保存到结果数组

```js
var rightSideView = function(root) {
    //用队列，获取队列每一层最后一个节点
    if(!root) return [];
    let res = []
    let que = []
    que.push(root)
    while(que.length>0){
        let len = que.length;
        for(let i=0;i<len;i++){
            let q = que.shift();
            if(q.left){que.push(q.left)}
            if(q.right){que.push(q.right)}
            if(i==len-1){
                res.push(q.val)
            }
        }
    }
    return res;
};
```

递归实现

```js
// DFS的实现：
var rightSideView = function(root) {
    if(!root) return []
    let res = []
    dfs(root, 0, res)
    return res
};

function dfs(root, level, res){
    if(root){
        if(res.length === level){
            res.push(root.val)
        }

        dfs(root.right, level+1, res)
        dfs(root.left, level+1, res)
    }
}

// BFS的实现：
var rightSideView = function(root) {
    if(!root) return []
    let res = []
    let queue = [root]
    while(queue.length > 0){
        let len = queue.length

        while(len){
            let node = queue.shift()
            if(len === 1){
                res.push(node.val)
            }
            if(node.left){
                queue.push(node.left)
            }
            if(node.right){
                queue.push(node.right)
            }
            len--
        }
    }
    return res
};
```

左视图

1. 层次遍历二叉树；
2. 将每一层的第一个节点值保存到结果数组；

```js
var rightSideView = function(root) {
    //用队列，获取队列每一层最后一个节点
    if(!root) return [];
    let res = []
    let que = []
    que.push(root)
    while(que.length>0){
        let len = que.length;
        for(let i=0;i<len;i++){
            let q = que.shift();
            if(q.left){que.push(q.left)}
            if(q.right){que.push(q.right)}
            if(i==0){ //只需将此处改为：判断是否为当前层的第一个节点
                res.push(q.val)
            }
        }
    }
    return res;
};
```

### 404. 左叶子之和

[404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

DFS

判断该当前节点是否拥有左子树
判断该左子树是否是叶子节点
是的话返回叶子节点的值
递归以上步骤

```js
var sumOfLeftLeaves = function(root) {

    if(!root) return 0
    let val = 0;
    if(root.left&&!root.left.left&&!root.left.right){
        val = root.left.val
    }
    return val+ sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right)
};
```
BFS
维护一个队列去遍历节点。
首先判断root是否存在，再把它入列。
让节点出列，出列就会把它们的左右子节点入列，不同的是，左子节点如果是左叶子节点，则它的节点值要累加给sum。
当队列为空，就遍历完所有节点，sum也累加好了。

```js
const sumOfLeftLeaves = (root) => {
  if (root == null) return 0;
  let sum = 0;
  const queue = [];
  queue.push(root);

  while (queue.length) {
    const cur = queue.shift();
    if (cur.left) {
      if (cur.left.left == null && cur.left.right == null) {
        sum += cur.left.val;
      } else {
        queue.push(cur.left);
      }
    }
    if (cur.right) {
      queue.push(cur.right);
    }
  }
  return sum;
};
```

### 508. 出现次数最多的子树元素和

[508. 出现次数最多的子树元素和](https://leetcode.cn/problems/most-frequent-subtree-sum/)

DFS

**准备几个全局变量：**
mxOcc: 记录出现元素最多的次数。即“maximum occurrence"。
mp：哈希表，用于维护每一个节点元素和出现的次数。
ans：用于记录答案数组。

对于每一个节点，我们**首先递归查询其左子树的和，然后再递归查询其右子树的和，加上这个当前节点本身的值，那么就为该节点的元素和**。
即 cur = dfs(root.left) + dfs(root.right) + root.val。

再计算完当前节点的元素和cur后，将mp中这个元素出现的次数加1。
即 mp[cur] += 1

将该元素和出现的次数与mxOcc做比较。
如果mp[cur] > mxOcc。那么则说明当前元素和的个数是最多的。于是将mxOcc跟新为当前元素和的数量，即mxOcc = mp[cur]，然后重新记录答案数组。ans = [cur]
如果mp[cur] == mxOcc。那么则说明当前元素和的个数刚好达到了最多的出现次数，直接将其元素和加入到答案数组中。ans.append(cur)

返回当前元素和。所有递归完成后直接返回答案数组即可。

```js
var findFrequentTreeSum = function(root) {
    let mxOcc = 0;
    const mp = new Map();
    let ans = [];

    const dfs = (root) => {
        if(!root) return 0;
        const cur = root.val + dfs(root.left) + dfs(root.right);
        mp.set(cur, (mp.get(cur) || 0) + 1);
        if(mp.get(cur) > mxOcc) {
            mxOcc = mp.get(cur);
            ans = [cur];
        } else if(mp.get(cur) == mxOcc) {
            ans.push(cur);
        }
        return cur;
    }
    dfs(root);
    return ans;
};
```



记录每个子树的子树合集，通过最大子树和数筛选出

```js
var findFrequentTreeSum = function(root) {
    let result = {}

    let maxCount = 0

    function dfs(p){
        if(!p){
            return 0
        }
        let leftValue = dfs(p.left)
        let rightValue = dfs(p.right)

        let total = p.val + leftValue+rightValue

        if(total in result){
            result[total]++
        }else{
            result[total] = 1
        }
        if(result[total]>maxCount){
            maxCount = result[total]
        }
        return total
    }

    dfs(root)

    let arr = Object.keys(result).reduce((arr,key)=>{
        let val = result[key]
        if(val === maxCount){
            arr.push(key)
        }

        return arr;
    },[])
    return arr
};
```

### 662. 二叉树最大宽度

[662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

给你一棵二叉树的根节点 `root` ，返回树的 **最大宽度** 。

树的 **最大宽度** 是所有层中最大的 **宽度** 。

0n 1n是js中用于显示大数字的定义，普通的数字超过一定数值会丢失精度，这种方式是专门做大数字的运算用的，要创建`BigInt`，只需要在数字末尾追加`n`即可

DFS

```js
var widthOfBinaryTree = function(root) {
  let maxWidth = 1n
  let map = new Map()

  function dfsFn(node, level, pos) {
    if (!map.has(level)) {
      map.set(level, pos)
    } else {
      let curWidth = pos - map.get(level) + 1n
      if (curWidth > maxWidth) {
        maxWidth = curWidth
      }
    }
    node.left && dfsFn(node.left, level + 1, 2n * pos)
    node.right && dfsFn(node.right, level + 1, 2n * pos + 1n)
    return maxWidth
  }

  return root ? dfsFn(root, 1, 1n) : 0n
};
```



BFS

```js
var widthOfBinaryTree = function(root) {
  let maxWidth = 0n
  // 先进先出
  let queue = []
  if (root) {
    queue.push([root, 1n])
  }
  while (queue.length) {
    let len = queue.length
    let positionArr = []

    for (let i = 0; i < len; i++) {
      // 处理当层
      let node = queue.shift()
      positionArr.push(node[1])
      // 遍历出下层
      if (node[0].left) {
        queue.push([node[0].left, 2n * node[1]])
      }
      if (node[0].right) {
        queue.push([node[0].right, 2n * node[1] + 1n])
      }
    }
    let start = positionArr[0]
    let end = positionArr.pop()
    let result = end - start + 1n
    if (result > maxWidth) {
      maxWidth = result
    }
  }
  return maxWidth
};

```

### 104. 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```js
var maxDepth = function (root) {
	//使用递归的方法 递归三部曲
	//1. 确定递归函数的参数和返回值
	const getdepth = function (node) {
		//2. 确定终止条件
		if (node === null) {
			return 0;
			
		}
		//3. 确定单层逻辑
		let leftdepth = getdepth(node.left);
		let rightdepth = getdepth(node.right);
		let depth = 1 + Math.max(leftdepth, rightdepth);
		return depth;

	}
	return getdepth(root);

};
```

### 111. 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

DFS

```js
const minDepth = (root) => {
    if (root == null) {            // 递归到null节点，返回高度0
        return 0;
    }
    if (root.left && root.right) { // 左右子树都存在，当前节点的高度1+左右子树递归结果的较小值
        return 1 + Math.min(minDepth(root.left), minDepth(root.right));
    } else if (root.left) {        // 左子树存在，右子树不存在
        return 1 + minDepth(root.left);
    } else if (root.right) {       // 右子树存在，左子树不存在
        return 1 + minDepth(root.right);
    } else {                       // 左右子树都不存在，光是当前节点的高度1
        return 1;
    }
};

```

```js
const minDepth = (root) => {
    if (root == null) {
        return 0;
    }
    const left = minDepth(root.left);
    const right = minDepth(root.right);

    if (left > 0 && right > 0) {
        return 1 + Math.min(left, right);
    } else if (left > 0) {
        return 1 + left;
    } else if (right > 0) {
        return 1 + right;
    } else {
        return 1;
    }
};
```

```js
const minDepth = (root) => {
    if (root == null) return 0;

    let depth = 1;  // 当前子树的深度，有1保底 (根节点高度)

    if (root.left && root.right) { // 左右子树都存在
        depth += Math.min(minDepth(root.left), minDepth(root.right));
    } else if (root.left) {
        depth += minDepth(root.left);
    } else if (root.right) {
        depth += minDepth(root.right);
    } else {                    // 左右子树都不存在
        depth += 0;
    }
    return depth; // 返回整棵树的计算结果
};
```

```js
const minDepth = (root) => {
    if (root == null) {
        return 0;
    }
    let depth = Infinity; // 当前子树的深度

    if (root.left) { // 左子树存在，用1+左子树的最小深度去刷新depth
        depth = Math.min(depth, 1 + minDepth(root.left));
    }
    if (root.right) { // 由子树存在，用1+右子树的最小深度去刷新depth
        depth = Math.min(depth, 1 + minDepth(root.right));
    }
    if (root.left == null && root.right == null) { // 都不存在
        depth = 1;   
    }
    return depth;
};

```

BFS

一层层遍历，一旦发现当前层的某个节点没有子节点，说明当前处在最小深度。

```js
const minDepth = (root) => {
    if (root == null) return 0;

    const queue = [root]; // 根节点入列
    let depth = 1;        // 当前层的深度

    while (queue.length) { // 直到清空队列
        const levelSize = queue.length; // 当前层的节点个数
        for (let i = 0; i < levelSize; i++) { // 遍历 逐个出列
            const cur = queue.shift();  // 出列
            if (cur.left == null && cur.right == null) { // 如果没有孩子，直接返回所在层数
                return depth;
            }
            if (cur.left) queue.push(cur.left); // 有孩子，让孩子入列
            if (cur.right) queue.push(cur.right);
        }
        depth++; // 肯定有下一层，如果没有早就return了
    }
};
```



### 513. 找树左下角的值

[513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

DFS

二叉树递归框架代码是先递归左子树，后递归右子树，所以到最大深度时第一次遇到的节点就是左下角的节点。

```js
var findBottomLeftValue = function(root) {

  let curMaxDepth = -1, curVal = 0

  var dfs = function(root, curDepth){
    if(!root) return null;
    if(curDepth > curMaxDepth){
      curMaxDepth = curDepth
      curVal = root.val
    }

    dfs(root.left, curDepth+1)
    dfs(root.right, curDepth+1)
  }

  dfs(root, 0)
  return curVal
};

var findBottomLeftValue = function (root) {
  // 记录二叉树的最大深度
  let maxDepth = 0;
  // 记录 dfs 递归遍历到的深度
  let depth = 0;
  let res = null;
  const dfs = (root) => {
    if (root == null) return null;
    // 前序遍历位置
    depth++;
    if (depth > maxDepth) {
      // 到最大深度时第一次遇到的节点就是左下角的节点
      maxDepth = depth;
      res = root;
    }
    dfs(root.left);
    dfs(root.right);
    depth--;
  };
  dfs(root);
  return res.val;
};
```

BFS

```js
var findBottomLeftValue = function(root) {
  if(!root) return null;
  const queue = [root]
  let mostLeft = null;
  while(queue.length > 0){
    let curLevelSize = queue.length
//因为是层序遍历，所以每次层的queue的第一个必然是最左边的节点
    mostLeft = queue[0]
    for(let i = 0; i < curLevelSize; i++){
      const curNode = queue.shift();

      curNode.left && queue.push(curNode.left)
      curNode.right&& queue.push(curNode.right)
    }
  }

  return mostLeft.val
};
```



### 222. 完全二叉树的节点个数

[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

DFS

```js
var countNodes=function(root){
	if(!root) return 0
	let count=1
	const dfs=(node)=>{
		if(node.left){
			count++
			dfs(node.left)
		}
		if(node.right){
			count++;
			dfs(node.right)
		}
	}
	dfs(root)
	return count
}
```

简化DFS

```js
function countNodes(root) {
	const dfs = (root, step) => {
		if (!root) return 0;
		const left = dfs(root.left, step + 1);
		const right = dfs(root.right, step + 1);
		return left + right + 1;
	}
	return dfs(root, 0);
};
```

BFS

```js
const countNodes=function(root){
   if(!root) return 0
	 let queue=[root]
	 let count=1
	 while(queue.length){
		let node=queue.pop()
		if(node.left){
			queue.push(node.left)
			count++
		}
		if(node.right){
			queue.push(node.right)
			count++
		}

	 }
	 return count
}
```

### 654. 最大二叉树

[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

创建一个根节点，其值为 nums 中的最大值。
递归地在最大值 左边 的 子数组前缀上 构建左子树。
递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。

DFS

递归
找出最大值
分出左-最大值-右三个部分

```js
var constructMaximumBinaryTree = function(nums) {
    if (!nums.length) {
        return null
    }
    
    let max = nums.reduce((init, curr) => {
        init = init < curr ? curr : init
        return init
    }, 0)
    
    let maxIdx = nums.indexOf(max)
    let left = nums.slice(0, maxIdx)
    let right = nums.slice(maxIdx + 1)
    
    let root = new TreeNode(max)
    root.left = constructMaximumBinaryTree(left)
    root.right = constructMaximumBinaryTree(right)
    
    return root   
}
```

### 110. 平衡二叉树

#### 自顶向下（暴力法）

解题思路： 自顶向下的比较每个节点的左右子树的最大高度差，如果二叉树中每个节点的左右子树最大高度差小于等于 1 ，即每个子树都平衡时，此时二叉树才是平衡二叉树

```js
var isBalanced = function (root) {
  if(!root) return true
  return Math.abs(depth(root.left) - depth(root.right)) <= 1
        && isBalanced(root.left)
        && isBalanced(root.right)
}
var depth = function (node) {
    if(!node) return -1
    return 1 + Math.max(depth(node.left), depth(node.right))
}
```


复杂度分析：

时间复杂度：O(nlogn)，计算 depth 存在大量冗余操作
空间复杂度：O(n)

#### 自底向上（优化）

解题思路： 利用后续遍历二叉树（左右根），从底至顶返回子树最大高度，判定每个子树是不是平衡树 ，如果平衡，则使用它们的高度判断父节点是否平衡，并计算父节点的高度，如果不平衡，返回 -1 。

遍历比较二叉树每个节点 的左右子树深度：

比较左右子树的深度，若差值大于 1 则返回一个标记 -1 ，表示当前子树不平衡
左右子树有一个不是平衡的，或左右子树差值大于 1 ，则二叉树不平衡
若左右子树平衡，返回当前树的深度（左右子树的深度最大值 +1 ）
代码实现：

```js
var isBalanced = function (root) {
    return balanced(root) !== -1
};
var balanced = function (node) {
    if (!node) return 0
    const left = balanced(node.left)
    const right = balanced(node.right)
    if (left === -1 || right === -1 || Math.abs(left - right) > 1) {
        return -1
    }
    return Math.max(left, right) + 1
}
```


复杂度分析：

时间复杂度：O(n)
空间复杂度：O(n)

### 226. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```js
function invertTree(root){
	if(!root) return null
	const queue=[root]
	while(queue.length){
		const node=queue.shift()

		const temp=node.right;
		node.right=node.left;
		node.left=temp;
		
		node.left&&queue.push(node.left)
		node.right&&queue.push(node.right)

	}
	return root
}
```

### 617. 合并二叉树

[617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

DFS

直接在t1上修改

进行值相加, 然后就是左跟左, 右跟右合, 递归下去, 注意下递归终止条件就行了

```js
var mergeTrees = function(t1, t2) {
    if(!t1 && t2){
        return t2
    }
    if(t1 && !t2 || !t1 && !t2){
        return t1
    }

    t1.val += t2.val
    t1.left = mergeTrees(t1.left, t2.left)
    t1.right = mergeTrees(t1.right, t2.right)
    return t1
};
```

BFS

整一个队列先把两个节点都放入队列, 然后取出节点累加, 再看它们的左右节点,

如果都存在, 就继续放入队列中

如果1不存在但2存在, 就把2的值赋给1, 因为最后是返回t1的, 我们都把值合并到t1上

```js
var mergeTrees = function(t1, t2) {
  if( !t1 || !t2 ) return t1 || t2
  let queue = [ [t1, t2] ]
  while( queue.length ) {
    let [ h1, h2 ] = queue.shift()
    let { left: l1, right: r1 } = h1
    let { left: l2, right: r2 } = h2
    // 两个都存在则值累计
    if( h1 && h2 ) h1.val += h2.val
    if( l1 && l2 ) queue.push( [l1, l2] )
    if( r1 && r2 ) queue.push( [r1, r2] )
    // 1不存在 且 2存在,  则把 2的值赋给 1
    if( !l1 && l2 ) h1.left = h2.left
    if( !r1 && r2 ) h1.right = h2.right
  }
  return t1
};
```

### 114. 二叉树展开为链表

[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。



将树的right树替换为left树
将left树的最右节点的 right 指向当前树的right树 （因为left树经过处理后后变成了只有right节点的链表 需要链表的尾部指向right树）
递归此操作

```js
var flatten = function(root) {
    // 递归终止条件
    if (root === null) return null;
    
    // 分别递归左右节点
    const left = root.left;
    const right = root.right;
    flatten(left)
    flatten(right);
    
    // 将树的right节点替换为left节点
    root.right = root.left;
    root.left = null;

    // 循环 找到最右的节点
    while (root.right) root = root.right;
    // 最右的节点 指向 right 节点
    root.right = right;
};
```

**右子树转成的单链表，只要获取它的头结点，等左子树生成的链表生成好，接到它的尾节点**
**左子树生成的单链表，处理稍微复杂一点**
要获取它的头结点，它要接到**根节点的right**
要获取它的尾节点，通过一直找右节点，找到尾节点，供连接
左子树生成的链表两端都接好后，root.left 要置为 null，不然 root 还拖着个左子树

```js
const flatten = (root) => {
  const helper = (root) => {       // 将当前子树转成一个单链表
    if (root == null) return null; // 遍历到null节点 返回null节点
    if (root.right) {              // 先生成右子树的单链表
      helper(root.right);
    }
    if (root.left) {               // 如果有左子树，生成单链表然后搬运过去
      const leftFirst = helper(root.left); // 生成单链表，并获取头结点
      let leftLast = leftFirst;    // leftEnd是单链表的尾节点
      while (leftLast.right) {     // 一直找右节点，获取到单链表的尾节点
        leftLast = leftLast.right;
      }
      leftLast.right = root.right; // 尾节点后面接左子树展平后的单链表
      root.right = leftFirst;      // 根节点的right改成leftFirst
      root.left = null;            // root.left置为null
    }
    return root; // 返回出当前子树转成的单链表
  };
  helper(root);  // 原地修改，不用返回
};
```

### 105. 从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

前序遍历：根-左-右
中序遍历：左-根-右
先用前序遍历找根节点，在用根节点去中序遍历确定左右子树
递归  注意退出递归条件

```js
var buildTree = function(preorder, inorder) {
  // 退出递归条件
  if (!inorder.length) {
    return null
  }
  let temp = preorder[0]  // 根节点
  let mid = inorder.indexOf(temp) // 根节点在中序遍历中的下标
  let root = new TreeNode(temp)
  // 根在中序的mid，那左子树个数就有mid个
  // 前序里截取从第1个到第mid+1个是左子树，中序里第0个到第mid个是左子树
  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid))
  // 前序里截取从第mid+1个到最后是右子树，中序里第mid个到最后是右子树
  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1))
  return root
};
```

优化

字符串截取存在性能消耗，没必要每次都切割。用两个指针表示即可。递归函数传指针。

- indexOf 的使用导致每次递归都花 O(n) 的时间定位根节点的位置，不理想。
- 提前把 inorder 的元素和索引存到哈希表中，用空间换取时间。

```js
const buildTree = (preorder, inorder) => {
  const map = new Map();
  for (let i = 0; i < inorder.length; i++) {
    map.set(inorder[i], i);
  }
  const helper = (p_start, p_end, i_start, i_end) => {
    if (p_start > p_end) return null;
    let rootVal = preorder[p_start];    // 根节点的值
    let root = new TreeNode(rootVal);   // 根节点
    let mid = map.get(rootVal);         // 根节点在inorder的位置
    let leftNum = mid - i_start;        // 左子树的节点数
    root.left = helper(p_start + 1, p_start + leftNum, i_start, mid - 1);
    root.right = helper(p_start + leftNum + 1, p_end, mid + 1, i_end);
    return root;
  };
  return helper(0, preorder.length - 1, 0, inorder.length - 1);
};
```



### 106. 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)


中序遍历：左-根-右

后序遍历：左-右-根

先用后序遍历找根节点，在用根节点去中序遍历确定左右子树
递归  注意退出递归条件

```js
var buildTree=function (inorder,postorder){
	if(!inorder.length) return null;
	const rootVal=postorder.pop()
	let rootIndex=inorder.indexOf(rootVal)
	const root=new TreeNode(rootVal)
	root.left = buildTree(inorder.slice(0, rootIndex), postorder.slice(0, rootIndex))
	root.right = buildTree(inorder.slice(rootIndex + 1), postorder.slice(rootIndex))
	return root;
}
```

优化

```js
const buildTree = (inorder, postorder) => {
  const map = {};
  for (let i = 0; i < inorder.length; i++) { // 将节点值在inorder数组中的位置提前存入map
    map[inorder[i]] = i;
  }
  // 根据iStart到iEnd的inorder数组，和从pStart到pEnd的postorder数组构建当前子树
  const helper = (iStart, iEnd, pStart, pEnd) => { 
    if (pStart > pEnd || iStart > iEnd) { // 指针交错了，返回null节点
      return null;
    }
    const rootVal = postorder[pEnd]; // 获取当前要构建的根节点的值
    const mid = map[rootVal];        // 获取到它在inorder数组中的位置
    const leftNodeNum = mid - iStart; // 获取左子树的节点个数

    const root = new TreeNode(rootVal); // 创建节点
    root.left = helper(iStart, mid - 1, pStart, pStart + leftNodeNum - 1); // 用递归构建左子树
    root.right = helper(mid + 1, iEnd, pStart + leftNodeNum, pEnd - 1); // 用递归构建右子树

    return root; // 返回当前构建好的子树
  };

  return helper(0, inorder.length - 1, 0, postorder.length - 1); // 递归的入口
};
```

### 889. 根据前序和后序遍历构造二叉树

[889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

中序遍历：左-根-右

后序遍历：左-右-根

```js
var constructFromPrePost = function(pre, post) {
    if(pre.length == 0) return null;
    let tmp = pre[0];
    let index = post.indexOf(pre[1]);
    let root = new TreeNode(tmp);
    root.left = constructFromPrePost(pre.slice(1,index+2),post.slice(0,index+1));
    root.right = constructFromPrePost(pre.slice(index+2),post.slice(index+1,post.length-1));
    return root;
};
```

### 116. 填充每个节点的下一个右侧节点指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

DFS

```js
const connect = (root) => {
  if (root == null) {
    return root;
  }
  const dfs = (root) => {
    if (root.left == null && root.right == null) {
      return;
    }
    root.left.next = root.right;
    if (root.next) {
      root.right.next = root.next.left;
    }
    dfs(root.left);
    dfs(root.right);
  };
  dfs(root);
  return root;
};
```

BFS

使用队列层层遍历，同一层的节点的 next 指针指向它后面的兄弟节点，每一层最后的节点
的 next 指针指到 null

```js
var connect = function(root) {
  if (!root) return root;
  let queue = [root];
  
  while (queue.length > 0) {
    let size = queue.length;
    while (size > 0) {
      size--;
      let offer = queue.shift();
      
      if (offer) {
        if (size === 0) {
          offer.next = null;
        } else {
          offer.next = queue[0];
        }
      }
      if (offer && offer.left) queue.push( offer.left );
      if (offer && offer.right) queue.push( offer.right );
    }
  }
  
  return root;
};
```



### 117. 填充每个节点的下一个右侧节点指针 II

[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**进阶：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

对于这道题目，我们可以对树进行层序遍历，树的层序遍历是基于广度优先遍历的，按照层的顺序进行遍历，我们需要舒适话一个队列queue，这个队列中保存着当前层的节点。

当队列不为空的时候就记录当前队列的的长度len，当遍历这一层的时候，修改这一层节点的 next 指针，这样就可以把每一层都组织成链表。

```js
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if (!root) {
        return null;
    }
    const queue = [root];
    while (queue.length) {
        const len = queue.length;
        let last = null;
        for (let i = 1; i <= len; ++i) {
            let node = queue.shift();
            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
            if (i !== 1) {
                last.next = node;
            }
            last = node;
        }
    }
    return root;
};
```



**不使用额外空间的优化**

使用BFS需要O(n)的空间复杂度，如何不需要额外的空间复杂度呢
在上一层为下一层建立 next 指针
当遍历到某层节点时，该层节点的 next 指针已经建立，这样就不需要队列了，只要知道下一层的最左边的节点，就可以从该节点开始，像遍历链表一样遍历该层的所有节点
时间复杂度：O(N)。我们需要遍历这棵树上所有的节点，所以时间复杂度为 O(N)
空间复杂度：O(1)

```js
var connect = function (root) {
  // 上一个节点
  let last,
    // 下一层从左至右第一个节点，也就是下一层中最左边节点
    nextStart;
  const handle = (p) => {
    // 上一个节点的next指针指向当前节点
    if (last !== null) last.next = p;
    // 如果下一层中最左边节点为空 则将下一个节点指向当前节点，先记录起来方便下一层循环使用
    if (nextStart === null) nextStart = p;
    // 向前走一步  保留当前节点以便下一轮使用
    last = p;
  };
  if (root === null) return null;

  let start = root;
  while (start != null) {
    last = null;
    nextStart = null;
    for (let p = start; p !== null; p = p.next) {
      // 先处理左节点再处理右节点 处理完之后下一层的next指针就已经建立好了
      if (p.left) handle(p.left);
      if (p.right) handle(p.right);
    }
    // 进入下一层
    start = nextStart;
  }
  return root;
};
```

### 297. 二叉树的序列化与反序列化

[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

BFS

思路：广度优先遍历节点，不断子节点不断入队，按照根左右的顺序序列化和反序列化
复杂度：时间复杂度O(n)，每个节点访问一次，n是树的节点个数。空间复杂度O(n)，队列的空间

```js
const serialize = (root) => {
    const queue = [root];
    let res = [];
    while (queue.length) {
        const node = queue.shift(); //出队
        if (node) {                 //node存在 推入根左右
            res.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {                    //如果不存在 推入‘x’
            res.push('X');
        }
    }
    return res.join(',');  //数组转成字符串
}

const deserialize = (data) => {
    if (data == 'X') return null;

    const list = data.split(',');  //字符串转数组

    const root = new TreeNode(list[0]); //从队首开始构建
    const queue = [root];          //根节点加入队列
    let cursor = 1;                //遍历到了第几个节点

    while (cursor < list.length) { //当队列没遍历完时
        const node = queue.shift();  //出队

        const leftVal = list[cursor];      //左节点的值
        const rightVal = list[cursor + 1]; //右节点的值

        if (leftVal != 'X') {              //不是空节点
            const leftNode = new TreeNode(leftVal); //构建左节点
            node.left = leftNode;                   //左节点挂在父节点的left下
            queue.push(leftNode);                   //自己入列 构建以自己为根的子树
        }
        if (rightVal != 'X') {
            const rightNode = new TreeNode(rightVal);
            node.right = rightNode;
            queue.push(rightNode);
        }
        cursor += 2; //构建的节点数+2
    }
    return root;  //返回根
};
```

DFS

思路：深度优先遍历，按根,左,右 返回字符串，方便反序列化的时候从根节点开始构建，递归左右子树，直到遇见了null节点。
复杂度：时间复杂度O(n)，每个节点访问一次，n是树的节点个数。空间复杂度O(n)，最坏情况下递归深度是n

```js
const serialize = (root) => {
    if (root == null) {                  //遇到null 返回‘X’进行标示
        return 'X';
    }
    const left = serialize(root.left);   //序列化左子树
    const right = serialize(root.right); //序列化右子树
    return root.val + ',' + left + ',' + right; //按根,左,右 返回字符串
};

const deserialize = (data) => {
    const list = data.split(',');   //字符串转数组

    const buildTree = (list) => {  	//构建树
        const rootVal = list.shift(); //第一个元素
        if (rootVal == "X") {         //如果是X，返回null
            return null;
        }
        const root = new TreeNode(rootVal); //如果不是X就创建节点
        root.left = buildTree(list);        //构建左子树
        root.right = buildTree(list);       //构建右子树
        return root;                        //返回构建的节点
    };

    return buildTree(list);
};
```



### 236. 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）

```js
var lowestCommonAncestor = function(root, p, q) {
    const travelTree=function(root,p,q){
			if(root===null||root===p||root===q){
				return root
			}
			let left=travelTree(root.left,p,q)
			let right =travelTree(root.right,p,q)
			if (left !== null && right !== null) {//如果在某一个节点的左右子树都能找到p和q说明这个节点就是公共祖先
				return root
			}
			if(left===null){
				return right
			}
			return left
		}
		return travelTree(root,p,q)
};
```



##  单调栈

### 20. 有效的括号

[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```javascript
var isValid = function (s) {
	let m = s.length
	if (m % 2 !== 0) return false
	let map = new Map([
		['{', '}'],
		['(', ')'],
		['[', ']']
	])
	let stk = []
	for (ch of s) {
		if (map.has(ch)) {
			stk.push(ch)
			//console.log(stk);
		} else {
			if (map.get(stk[stk.length - 1]) !== ch || stk.length == 0) return false
			else stk.pop()
		}
	}
	if (stk.length == 0) return true
	else return false
};
```

### 739. 每日温度

[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

```javascript
const dailyTemperatures = (T) => {
	const res = new Array(T.length).fill(0)
	const stack = []
	for (let i = T.length - 1; i >= 0; i--) {
		while (stack.length && T[i] >= T[stack[stack.length - 1]]) {
			stack.pop()
		}
		if (stack.length) {
			res[i] = stack[stack.length - 1] - i
		}
		stack.push(i)
	}
	return res
}
```

224. ### 基本计算器

[224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

匹配到加减号 加号把符号栈最后一位赋值给sign 减号取反 每次匹配到(将当前sign压入符号栈，匹配到)出栈 匹配到数字时 一直匹配直到不是数字时，res+=当前数字*sign

```js
var calculate = function(s) {
		let str=s.replaceAll(' ','')
		let sign=1;
		let ops=[1]
		let i=0,res=0;
		while(i<str.length){
			if(str[i]==='+'){
				sign=ops[ops.length-1]
			}else if(str[i]==='-'){
				sign=-ops[ops.length-1];
			}else if(str[i]==='('){
				ops.push(sign)
			}else if(str[i]===')'){
				ops.pop()
			}else{
				let num=''
				while(i<str.length&&!(isNaN(Number(str[i])))){
					num+=str[i]
					i++;
				}
				i--;
				res+=sign*Number(num)
			}
			i++
		}
			return res
			
	}
```

### 232. 用栈实现队列

[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）

```js
/* 
使用两个栈，s1中存储的是后入队的元素，s2中存储的是先入队的元素
入队时，元素默认存储在s1。
出队时，默认从s2进行出栈操作，如果s2为空，则将s1中元素转移到s2。
如果s2有值，则队首在s2的栈顶。否则，队首在top。
由于s1的元素只有在pop时才会转移到s2，因此只有两个栈都为空时，队列才为空。


*/
var MyQueue = function() {
	this.s1=[]
	this.s2=[]
	this.top=null
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
		if(!this.s1.length){
			this.top=x
		}
		this.s1.push(x)
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
		if(this.s2.length){
			return this.s2.pop()
		}
		while(this.s1.length){
			this.s2.push(this.s1.pop())
		}
		return this.s2.pop()
};	

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
	// 如果s2中有元素，则栈顶即为队首
	if (this.s2.length) {
		return this.s2[this.s2.length - 1];
	}

	// s2中无元素，则此时队首在top
	return this.top;


};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
	// 由于s1的元素只有在pop时才会转移到s2，因此判空时要两个栈一起判断
	return !this.s1.length && !this.s2.length;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```



## 图论



## 排序

### 快速排序

```javascript
const partition=(arr)=>{
    let x=arr[0]
    let length=arr.length
    let i=0
    let j=length-1
    while(i<j){
        // 先从后往前找小的, 没找到继续找
        while(i<j&&arr[j]>x){
            j--;
        }    
        // 找到了，将a[j]值填入坑里, a[j]又变成了坑
        if(i<j){
            arr[i]=arr[j]
        }
        // 然后从前往后找大的，没找到继续找
        while(i<j&&arr[i]<x){
            i++
        }    
        // 找到了，将值填入之前的坑里
        if(i<j){
            arr[j]=arr[i];
        }
    }
    a[i]=x;
    return arr;

}
const a = [2, 1, 3, 6, 4, 5, 9, 8, 7];
let result = partition(a);
console.log(result);
```

### 215. 数组中的第K个最大元素

[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

其实没有必要全部排序，可以利用快速排序的 partition 操作，找到第 K 个最大元素。

每进行一次快速排序的 partition 操作，就能找到这次我们选中的基准值排序之后的正确位置。

如果它的位置刚好是排序之后第 K 个最大元素的位置，即 len - k，我们直接得到了答案；
因为进行 partition 操作之后，位于基准值之前的元素都要小于基准值，位于基准值之后的元素都要大于等于基准值。

如果它的位置小于排序之后第 K 个最大元素的位置，我们就去它之后寻找第 K 个最大元素；
如果它的位置大于排序之后第 K 个最大元素的位置，我们就去它之前寻找第 K 个最大元素；

分治选择排序，然后修正位置

```javascript
var findKthLargest = function (nums, k) {
  const len = nums.length;
  const targetIndex = len - k;
  let left = 0,right = len - 1;

  while (left < right) {
    const index = partition(nums, left, right);
    if (index === targetIndex) {
      return nums[index];
    } else if (index < targetIndex) {
      left = index + 1;
    } else {
      right = index - 1;
    }
  }

  return nums[left];
};

function partition(nums, start, end) {
  const povit = nums[start];
  while (start < end) {
    while (start < end && nums[end] >= povit) {
      end--;
    }
    nums[start] = nums[end];
    while (start < end && nums[start] < povit) {
      start++;
    }
    nums[end] = nums[start];
  }
  nums[start] = povit;
  return start;
}
```

### 165. 比较版本号

[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)

```javascript
var compareVersion = function (version1, version2) {
	let v1 = version1.split(".");
	let v2 = version2.split(".");
	let len = Math.max(v1.length, v2.length)
	for (let i = 0; i <len ; i++) {
		let tempV1 = Number(v1[i] ?? 0)
		let tempV2 = Number(v2[i] ?? 0)
		if (tempV1 > tempV2) return 1;
		if (tempV1 < tempV2) return -1;
		// 如果相等则跳过继续进行循环
	}
	
	return 0;
};
```

### 215. 数组中的第K个最大元素

[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

快排法

```js
var findKthLargest = function (nums, k) {
  const len = nums.length;
  const targetIndex = len - k;
  let left = 0,
    right = len - 1;

  while (left < right) {
    const index = partition(nums, left, right);
    if (index === targetIndex) {
      return nums[index];
    } else if (index < targetIndex) {
      left = index + 1;
    } else {
      right = index - 1;
    }
  }

  return nums[left];
};

function partition(nums, start, end) {
  const povit = nums[start];
  while (start < end) {
    while (start < end && nums[end] >= povit) {
      end--;
    }
    nums[start] = nums[end];
    while (start < end && nums[start] < povit) {
      start++;
    }
    nums[end] = nums[start];
  }
  nums[start] = povit;
  return start;
}

```

56. ### 合并区间

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

```js
var merge = function(intervals) {
		intervals.sort((a,b)=>a[0]-b[0])
		let prev=intervals[0]
		let result=[]
		for(let i=0;i<intervals.length;i++){
			let cur=intervals[i]
			if(cur[0]>prev[1]){
				result.push(prev)
				prev=cur
			}else{
				prev[1]=Math.max(cur[1],prev[1])
			}
		}
		result.push(prev)
		return result
};
```

### 31. 下一个排列
[31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列

-   例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
-   类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。

思路：从后往前遍历 如果遇到后一个大于前一个就跳出 并记录下标j

然后再对j~length 进行遍历  如果发现比之前大的就进行一个交换  大的数换到前面

j右边的数进行翻转，使得变大的幅度小一些

```js
var nextPermutation = function(nums) {
    let j = -1;
    for(let i = nums.length - 2 ; i >= 0; i --) {
        if(nums[i] < nums[i + 1]) {
            j = i;
            break;
        }
    }
    if(j == -1) 
      //如果 j = -1，说明是递减排列
        nums.reverse();
    else {
        for(let i = nums.length - 1; i > j; i --) {
            if(nums[i] > nums[j]) {
                [nums[i], nums[j]] = [nums[j], nums[i]];
                break;
            }
        }
        let i = j + 1, k = nums.length - 1;
        while(i < k) {
            [nums[i], nums[k]] = [nums[k], nums[i]];
            i ++, k --;
        }
    }
};
```

### 148. 排序链表
[148. 排序链表](https://leetcode.cn/problems/sort-list/)

```js
// 归并排序
var sortList = function (head) {
  if (!head || head.next === null) return head;
  // 使用快慢指针找到中间节点
  let slow = head,
    fast = head.next;
  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
  }
  // 将链表分成两半并返回后半部分链表的头节点
  let newList = slow.next;
  slow.next = null;

  // 对前后两个链表进行排序
  let left = sortList(head);
  let right = sortList(newList);
  // 将排序好的两个有序链表合并为一个链表
  let res = new ListNode(-1);
  let nHead = res;
  // 合并链表只需要调整指针的指向
  // 两个链表哪个节点的值小就先指向它
  while (left !== null && right !== null) {
    if (left.val < right.val) {
      nHead.next = left;
      left = left.next;
    } else {
      nHead.next = right;
      right = right.next;
    }
    nHead = nHead.next;
  }
  nHead.next = left === null ? right : left;
  return res.next;
};
```

### 4. 寻找两个正序数组的中位数
[4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

先将两数组排序，然后根据两数组长度判断，中位数取一个还是两个平均值，返回结果。

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

```js
var findMedianSortedArrays = function(nums1, nums2) {
    let len1 = nums1.length;
    let len2 = nums2.length;
    let middle;
    let flag;
    if ((len1 + len2) % 2 === 0) {
        middle = parseInt((len1+len2)/2);
        flag = 0;
    } else {
        middle = parseInt((len1+len2)/2) + 1;
        flag = 1;
    }
    let i=0, j=0;
    let arr = [];
    while(i < len1 && j < len2) {
        if (nums1[i] < nums2[j]) {
            arr.push(nums1[i]);
            i++;
        } else {
            arr.push(nums2[j]);
            j++;
        }
    }
    if (i === len1) {
        arr = arr.concat(nums2.slice(j));
    }

    if (j === len2) {
        arr = arr.concat(nums1.slice(i));
    }

    if (flag === 0) {
        return parseFloat((arr[middle-1] + arr[middle]) / 2);
    } else {
        return arr[middle-1];
    }
};

```

### 41. 缺失的第一个正数
[41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

1.首先将nums[i]放到对应的位置，如nums[0] = 1，nums[1] = 2，....，nums[6] = 7
2.然后遍历交换位置之后的数组，判断是否是对应位置，若不是，则直接返回当前索引值 + 1；若全都是，则直接返回nums.length + 1即可

```js
var firstMissingPositive = function(nums) {
    for(let i = 0; i < nums.length; i++) {
      	// 循环nums，当前元素在(0,nums.length]之间，并且nums[nums[i]-1] != nums[i]，则交换位置
        while(nums[i] > 0 && nums[i] <= nums.length && nums[nums[i]-1] != nums[i]) {
            const temp = nums[nums[i]-1];
            nums[nums[i]-1] = nums[i];
            nums[i] = temp;
        }
    }
    for(let i = 0; i < nums.length; i++) {// 循环交换位置之后的数组，判断第一个缺失的正数
        if(nums[i] != i+1) {
            return i+1;
        }
    }
	// [1,2,3]
    return nums.length + 1;
};

```

## 分治

### 704. 二分查找
[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

```js
var search = function (nums, target) {
	let l = 0, r = nums.length - 1;
	while (l <= r) {
		let mid = (l + r) >> 1;
		if (nums[mid] === target) return mid;
		let isSmall = nums[mid] < target;
		l = isSmall ? mid + 1 : l;
		r = isSmall ? r : mid - 1;
	}

	return -1;
};
```

### 852. 山脉数组的峰顶索引
[852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

```javascript
var peakIndexInMountainArray = function(arr) {
  let left = 1,
    right = arr.length - 1;
  // 左闭右闭区间
  while (left <= right) {
    // 中间值  下面这样写是防止大数情况下溢出
    let mid = left + ((right - left) >> 1);
    // 如果这个数字比它前后两个数字都大
    if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {
      return mid;
    }
    // 如果这个数字比它前一个数字大，但比后一个数字小，那么这个数字位于数组递增的部分，
    // 数组的最大值一定在它的后面
    if (arr[mid] > arr[mid - 1]) {
      left = mid + 1;
    } else {
      // 如果这个数字比它前一个数字小，但比后一个数字大，那么这个数字位于数组递减的部分，
      // 数组的最大值一定在它的前面
      right = mid - 1;
    }
  }
  return -1;
};
```

### 69. x 的平方根 
[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

```js
var mySqrt = function(x) {
	let left=1,right=x;
	while(left<=right){
		let mid=left+((right-left)>>1)
		if(mid<=x/mid){
			if(mid+1>x/(mid+1)){
				return mid
			}
			left=mid+1
		}else{
			right=mid-1
		}
	}
	return 0;
};
```



## 递归

### 递归求1-100的和
```js
//正常递归
function sum(n){
	if(n == 1){
		return 1;
	   }
	return sum(n - 1) + n;
}
console.log(sum(100));


//尾递归
function add (n,sum){
    if(n<=0) return sum
    return add(n-1,n+sum)
}
add(100,0)
```

### 200. 岛屿数量
[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

#### DFS

思路：循环网格，深度优先遍历每个坐标的四周，注意坐标不要越界，遇到陆地加1，并沉没四周的陆地，这样就不会重复计算
复杂度：时间复杂度O(mn), m和n是行数和列数。空间复杂度是O(mn),最坏的情况下所有网格都需要递归，递归栈深度达到m * n

```js
const numIslands=(grid)=>{
	let count=0;
	for(let i=0;i<grid.length;i++){
		for(let j=0;j<grid[0].length;j++){
			if(grid[i][j]=='1'){
				count++;
				turnZero(i,j,grid)
			}
		}
	}
	return count
}
function turnZero(i,j,grid){
	if(i<0||i>=grid.length||j<0||j>=grid[0].length||grid[i][j]==='0')  return 
	grid[i][j]='0';
	turnZero(i,j+1,grid)
	turnZero(i,j-1,grid)
	turnZero(i+1,j,grid)
	turnZero(i-1,j,grid)
}
```

#### BFS

思路：循环网格，广度优先遍历坐标的四周，遇到陆地加1，沉没四周的陆地，不重复计算陆地数
复杂度：时间复杂度O(mn),m和n是行数和列数。空间复杂度是O(min(m，n)),队列的长度最坏的情况下需要能容得下m和n中的较小者

```js
const numIslands=(grid)=>{
	let count=0
	let queue=[]
	for(let i=0;i<grid.length;i++){
		for(let j=0;j<grid[0].length;j++){
			if(grid[i][j]==='1'){
				count++
				grid[i][j] = '0' // 做标记，避免重复遍历
				queue.push([i, j]) //加入队列
				turnZero(queue, grid)
			}
		}
	}
	return count
}

function turnZero(queue,grid){
	const dirs=[[0,1],[1,0],[0,-1],[-1,0]] //上 右 下 左
	while(queue.length){
		const cur=queue.shift()
		for (const dir of dirs) {  //四个方向广度优先扩散
			const x=cur[0]+dir[0]
			const y=cur[1]+dir[1]
			if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] !== '1') {
				continue
			}//检查坐标合法性
			grid[x][y]='0' //沉迷陆地
			queue.push([x,y])
		}
	}
}
```



### 695. 岛屿的最大面积

[695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

#### DFS

```js
var maxAreaOfIsland = function(grid) {
		let row =grid.length,col=grid[0].length
		function dfs(x,y){
		if(x<0||x>=row||y<0||y>=col||grid[x][y]===0) return 0
			grid[x][y]=0
			let ans=1,dx=[-1,1,0,0],dy=[0,0,1,-1]
			for(let i=0;i<dx.length;i++){
				ans+=dfs(x+dx[i],y+dy[i])
			}
			return ans
		}
		let res=0
		for(let i=0;i<row;i++){
			for(let j=0;j<col;j++){
				res=Math.max(res,dfs(i,j))
			}
		}
		return res
};

var maxAreaOfIsland = function(grid) {
    let max = 0;
    let count = 0;
    function dfs(row, col) {
        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] === 0) {
            return 0;
        }
        grid[row][col] = 0;
        count = 1
        count += dfs(row+1, col)
        count += dfs(row-1, col)
        count += dfs(row, col+1)
        count += dfs(row, col-1)
        return count;
    }
    for(let i = 0; i < grid.length; i++) {
        for(let j = 0; j < grid[0].length; j++){
            if(grid[i][j] === 1) {
                max = Math.max(max, dfs(i, j))
            }
        }
    }
    return max;
};

```

#### BFS

```js
var maxAreaOfIsland = function(grid) {
  const m = grid.length;
  const n = grid[0].length;
  let maxArea = 0;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] === 1) {
        const queue = [[i, j]];
        grid[i][j] = 0;
        let area = 0;
        while (queue.length) {
          const [curI, curJ] = queue.shift();
          area++;
          [[-1, 0], [0, 1], [1, 0], [0, -1]].forEach(item => {
            const x = curI + item[0];
            const y = curJ + item[1];
            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] === 1) {
              queue.push([x, y]);
              grid[x][y] = 0;
            }
          });
        }
        maxArea = Math.max(maxArea, area);
      }
    }
  }
  return maxArea;
};
```



### 22. 括号生成

[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

```js
var generateParenthesis = function(n) {
		const res=[];
		var dfs=(LRemain,RRemain,str)=>{
			if(str.length==2*n){
				res.push(str);
				return;
			}
			//裁剪
			if(LRemain>0){
				dfs(LRemain-1,RRemain,str+"(");

			}
			if(LRemain<RRemain){
				dfs(LRemain,RRemain-1,str+")");
			}
		}
		dfs(n,n,"");
		return res;
};
```

## 回溯

### 46. 全排列
[46. 全排列](https://leetcode-cn.com/problems/permutations/)

```javascript
var permute = function(nums) {
	const res=[],path=[];
	backtracking(nums,nums.length,[]);
	return res;
	
	function backtracking(n,k,used){
		if(path.length===k){
			res.push(Array.from(path));
			return ;
		}
		for(let i=0;i<k;i++){
			if(used[i]) continue;
			path.push(n[i]);
			used[i]=true;
			backtracking(n,k,used);
			path.pop();
			used[i]=false;
		}
	}
};
```

### 93. 复原 IP 地址
[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```js
var restoreIpAddresses = function (s) {
		const res=[],path=[];
		backtracking(0,0)
		return res;
		function backtracking(i){
			const len=path.length;
			if(len>4) return
			if(len===4&&i===s.length){
				res.push(path.join("."));
				return
			}
			for(let j=i;j<s.length;j++){
				const str=s.substr(i,j-i+1)
				if(str.length>3||+str>255) break;
				if(str.length>1&&str[0]==='0') break;
				path.push(str)
				backtracking(j+1)
				path.pop()
			}
		}

}
```

## 贪心





## 数论





## 动态规划

### 70. 爬楼梯
[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```javascript
var climbStairs = function (n) {
	if (n <= 1) return n;
	a = 1;
	b = 2;
	for (let i = 3; i <= n; i++) {
		sum = a + b;
		a = b;
		b = sum;
	}
	return b;
}
```

### 剑指 Offer 10- I. 斐波那契数列
[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

````js
var fib = function(n) {
    let n1 = 0, n2 = 1, sum;
    for(let i = 0; i < n; i++){
        sum = (n1 + n2) % 1000000007;
        n1 = n2;
        n2 = sum;
    }
    return n1;
};

````

### 剑指 Offer 62. 圆圈中最后剩下的数字
[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

https://github.com/lzxjack/coding-interviews

```js
var lastRemaining = function(n, m) {
    let now = 0;
    for(let i = 2; i <= n; i++) {
        now = (now + m) % i;
    }
    return now;
};
```



### 5. 最长回文子串
[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

```js
var longestPalindrome = function(s) {
		let n=s.length
		let res=''
		let dp=Array.from(new Array(n),()=>new Array(n).fill(false))
		for(let i=n-1;i>=0;i--){
			for(let j=i;j<n;j++){
				dp[i][j]=s[i]===s[j]&&(j-i<2||dp[i+1][j-1])
				if(dp[i][j]&&j-i+1>res.length){
					res=s.substring(i,j+1)
				}
			}
		}
		return res
};
```

### 62. 不同路径
[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

```js
var uniquePaths = function(m, n) {
	const dp=Array(m).fill().map(()=>Array(n).fill(1));
	for(let i=0;i<m;i++){
		dp[i][0]=1;
	}
	for(let i=0;i<n;i++){
		dp[0][i]=1;
	}
	for(let i=1;i<m;i++){
		for(let j=1;j<n;j++){
            //要么从左 要么从上 来继承状态
			dp[i][j]=dp[i-1][j]+dp[i][j-1];
		}
	}
	return dp[m-1][n-1];
}
```



### 64. 最小路径和
[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```js
const minPathSum = grid => {
	const [m, n] = [grid.length, grid[0].length];
	const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

	dp[0][0] = grid[0][0];
	for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
	for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];

	for (let i = 1; i < m; i++) {
		for (let j = 1; j < n; j++) {
			dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
		}
	}
	return dp[m - 1][n - 1];
};
```



### 121. 买卖股票的最佳时机

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**限定交易次数 k=1**

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润

```js
var maxProfit = function(prices) {
	const len=prices.length
	const dp = new Array(len).fill([0,0])
	  dp[0][0] = 0; // 持有现金
    dp[0][1] = -prices[0]; // 持有股票
	for (let i = 1; i < prices.length; i++){
    
		dp[i][0]=Math.max(dp[i-1][0],-prices[i]);  //不持有股票 保持前一天现状 前一天就卖掉  或者今天卖了
		dp[i][1]=Math.max(dp[i-1][1],prices[i]+dp[i-1][0])   //持有股票 手里没钱
	}
	return dp[len-1][1]
};
```

状态压缩  `dp[i]` 只和 `dp[i - 1]` 有关，去掉一维

```js
//时间复杂度O(n) 空间复杂度O(1)
const maxProfit = function (prices) {
    let n = prices.length;
    let dp = Array.from(new Array(n), () => new Array(2));
    dp[0] = 0;
    dp[1] = -prices[0];
    for (let i = 1; i < n; i++) {
        dp[0] = Math.max(dp[0], dp[1] + prices[i]);
        dp[1] = Math.max(dp[1], -prices[i]);
    }
    return dp[0];
};


const maxProfit = function (prices) {
    let n = prices.length;
    let sell = 0;
    let buy = -prices[0];
    for (let i = 1; i < n; i++) {
        sell = Math.max(sell, buy + prices[i]);
        buy = Math.max(buy, -prices[i]);
    }
    return sell;
};
```

贪心

```js
var maxProfit = function (prices) {
	let lowerPrice = prices[0];// 重点是维护这个最小值（贪心的思想） 
	let profit = 0;
	for (let i = 0; i < prices.length; i++) {
		lowerPrice = Math.min(lowerPrice, prices[i]);// 贪心地选择左面的最小价格
		profit = Math.max(profit, prices[i] - lowerPrice);// 遍历一趟就可以获得最大利润
	}
	return profit;
};
```



### 122. 买卖股票的最佳时机 II
[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

**交易次数无限制 k = +infinity**

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多 只能持有 一股 股票**。你也可以先购买，然后在 同一天 出售

状态：持有现金`dp[i][0]`、持有股票`dp[i][1]`；
如果持有现金，则可能昨天也持有现金`dp[i-1][0]`或者昨天持有股票并卖出，取得收益

`dp[i-1][1]+prices[i]`;
如果持有股票，则可能昨天也持有股票`dp[i-1][1]`或者昨天花掉现金，买入股票

`dp[i-1][0]-prices[i]`;

```js
var maxProfit = function(prices) {
    var dp = [
        []
    ];
    if(prices<1){
        return 0;
    }
    dp[0][0] = 0; // 持有现金
    dp[0][1] = -prices[0]; // 持有股票
    for (var i = 1; i < prices.length; i++) {
        if (!dp[i]) {
            dp[i] = [];
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[prices.length - 1][0]
};
```

状态压缩

```js
const maxProfit = function (prices) {
    let n = prices.length;
    let dp = Array.from(new Array(n), () => new Array(2));
    dp[0] = 0;
    dp[1] = -prices[0];
    for (let i = 1; i < n; i++) {
        dp[0] = Math.max(dp[0], dp[1] + prices[i]);
        dp[1] = Math.max(dp[1], dp[0] - prices[i]);
    }
    return dp[0];
};


//语意化
const maxProfit = function (prices) {
    let n = prices.length;
    let sell = 0;
    let buy = -prices[0];
    for (let i = 1; i < n; i++) {
        sell = Math.max(sell, buy + prices[i]);
        buy = Math.max(buy, sell - prices[i]);
    }
    return sell;
};
```



### 516.最长回文子序列
[516.最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

```js
var longestPalindromeSubseq=function(s){
	const n=s.length
	const dp=new Array(n).fill(0).map(()=>new Array(n).fill(0))
	for(let i=0;i<n;i++){
		dp[i][i]=1
	}
	for(let i=n-1;i>=0;i--){
		for(let j=i+1;j<n;j++){
			if(s[i]=s[j]){
				dp[i][j]=dp[i+1][j-1]+2   //如果左右端点的相等 直接通过内层状态进行转移
			}else{
				dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1])  //不相等  则进行左右各选取一个进行状态结果比较
			}
		}
	}
	return dp[0][n-1]
}
```



### 647. 回文子串
[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目

```js
var countSubstrings=function(s){
	const n=s.length;
	let ans=0;
	let dp=Array.from(Array(n),()=>Array(n).fill(false))
	for(let j=0;j<n;j++){
		for(let i=0;i<=j;i++){
			if(s[i]===s[j]){
				if(j-i<2){
					dp[i][j]=true
				}else{
					dp[i][j]=dp[i+1][j-1]
				}
				ans+=dp[i][j]?1:0
			}
		}
	}
	return ans
}
```



### 300. 最长递增子序列
[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```js
var lengthOfLIS = function (nums) {
  const dp = new Array(nums.length).fill(1);
  for (let i = 0; i < nums.length; i++) {
    // i与i前面的元素比较
    for (let j = 0; j < i; j++) {
      // 找比i小的元素，找到一个，就让当前序列的最长子序列长度加1
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  // 找出最大的子序列
  return Math.max(...dp);
};
```

### 322. 零钱兑换
[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```js
var coinChange = function(coins, amount) {
	let dp=new Array(amount+1).fill(Infinity)
	dp[0]=0
	for(let i=1;i<=amount;i++){
		for(let coin of  coins){
			if(i-coin>=0){
				dp[i]=Math.min(dp[i],dp[i-coin]+1)
			}
		}
	}
	return dp[amount]===Infinity?-1:dp[amount]
};
```



### 718. 最长重复子数组
[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

```js
var findLength = function(nums1, nums2) {
		const m=nums1.length;
		const n=nums2.length;
		const dp=new Array(m+1)
		for(let i=0;i<=m;i++){
			dp[i]=new Array(n+1).fill(0)
		}
		let res=0
		for(let i=1;i<=m;i++){
			for(let j=1;j<=n;j++){
				if(nums1[i-1]===nums2[j-1]){
					dp[i][j]=dp[i-1][j-1]+1
				}
				res=Math.max(dp[i][j],res)
			}
		}
		return res
};
```



### 120. 三角形最小路径和
[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

```js
const minimumTotal = (triangle) => {
	const h = triangle.length;
	// 初始化dp数组
	const dp = new Array(h);
	for (let i = 0; i < h; i++) {
		dp[i] = new Array(triangle[i].length);
	}

	for (let i = h - 1; i >= 0; i--) { // 自底而上遍历
		for (let j = 0; j < triangle[i].length; j++) { // 同一层的
			if (i == h - 1) {  // base case 最底层
				dp[i][j] = triangle[i][j];
			} else { // 状态转移方程，上一层由它下面一层计算出
				dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];
			}
		}
	}
	return dp[0][0];
};
```



### 198. 打家劫舍
[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**在当前位置 `n` 房屋可盗窃的最大值，要么就是 `n-1` 房屋可盗窃的最大值，要么就是 `n-2` 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值**

```js
var rob = function(nums) {
    const len = nums.length;
    if(len == 0)
        return 0;
    const dp = new Array(len + 1);
    dp[0] = 0;
    dp[1] = nums[0];
    for(let i = 2; i <= len; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
    }
    return dp[len];
};
```

### 1143. 最长公共子序列
[1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

```js
var longestCommonSubsequence=(text1,text2)=>{
	let m=text1.length,n=text2.length
	let dp=Array(m+1).fill(0).map(()=>Array(n+1).fill(0))
	for(let i=1;i<=m;i++){
		for(let j=1;j<=n;j++){
			if(text1[i-1]===text2[j-1]){
				dp[i][j]=dp[i-1][j-1]+1
			}else {
				dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1])
			}
		}
	}
	return dp[m][n]
}
```



## 设计数据结构

### 146. LRU 缓存
[146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

```javascript
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.map = new Map();
    this.capacity = capacity;
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if(this.map.has(key)){
        let value = this.map.get(key);
        this.map.delete(key); // 删除后，再 set ，相当于更新到 map 最后一位
        this.map.set(key, value);
        return value
    } else {
        return -1
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    // 如果已有，那就要更新，即要先删了再进行后面的 set
    if(this.map.has(key)){
        this.map.delete(key);
    }
    this.map.set(key, value);
    // put 后判断是否超载
    if(this.map.size > this.capacity){
        this.map.delete(this.map.keys().next().value);
    }

};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */

```

### 155. 最小栈
[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)
