## File 对象，FileList 对象，FileReader 对象

### File 对象

File 对象代表一个文件，用来读写文件信息。它继承了 Blob 对象，或者说是一种特殊的 Blob 对象，所有可以使用 Blob 对象的场合都可以使用它。

最常见的使用场合是表单的文件上传控件（`<input type="file">`），用户选中文件以后，浏览器就会生成一个数组，里面是每一个用户选中的文件，它们都是 File 实例对象。

```js
// HTML 代码如下
// <input id="input" type="file">
var file = document.getElementById('input').files[0];
file instanceof File // true
```

上面代码中，`file`是用户选中的第一个文件，它是 File 的实例。

#### 构造函数

浏览器原生提供一个`File()`构造函数，用来生成 File 实例对象。

```js
new File(array, name [, options])
```

`File()`构造函数接受三个参数。

- array：一个数组，成员可以是二进制对象或字符串，表示文件的内容。
- name：字符串，表示文件名或文件路径。
- options：配置对象，设置实例的属性。该参数可选。

第三个参数配置对象，可以设置两个属性。

- type：字符串，表示实例对象的 MIME 类型，默认值为空字符串。
- lastModified：时间戳，表示上次修改的时间，默认为`Date.now()`。

#### 实例属性和实例方法

File 对象有以下实例属性。

- File.lastModified：最后修改时间
- File.name：文件名或文件路径
- File.size：文件大小（单位字节）
- File.type：文件的 MIME 类型

------

### FileList 对象

`FileList`对象是一个**类似数组的对象，代表一组选中的文件**，每个成员都是一个 **File 实例**。它主要出现在两个场合。

- 文件控件节点（`<input type="file">`）的`files`属性，返回一个 FileList 实例。
- 拖拉一组文件时，目标区的`DataTransfer.files`属性，返回一个 FileList 实例。

```js
// HTML 代码如下
// <input id="input" type="file">
var files = document.getElementById('input').files;
files instanceof FileList // true
```

上面代码中，文件控件的`files`属性是一个 FileList 实例。

FileList 的实例属性主要是`length`，表示包含多少个文件。

FileList 的实例方法主要是`item()`，用来返回指定位置的实例。它接受一个整数作为参数，表示位置的序号（从零开始）。但是，由于 FileList 的实例是一个类似数组的对象，可以直接用方括号运算符，即`myFileList[0]`等同于`myFileList.item(0)`，所以一般用不到`item()`方法。

------

### FileReader 对象

FileReader 对象用于读取 File 对象或 Blob 对象所包含的文件内容。

浏览器原生提供一个`FileReader`构造函数，用来生成 FileReader 实例。

```js
var reader = new FileReader();
```

> FileReader 有以下的实例属性。
>
> - FileReader.error：读取文件时产生的错误对象
> - FileReader.readyState：整数，表示读取文件时的当前状态。一共有三种可能的状态，`0`表示尚未加载任何数据，`1`表示数据正在加载，`2`表示加载完成。
> - FileReader.result：读取完成后的文件内容，有可能是字符串，也可能是一个 ArrayBuffer 实例。
> - FileReader.onabort：`abort`事件（用户终止读取操作）的监听函数。
> - FileReader.onerror：`error`事件（读取错误）的监听函数。
> - FileReader.onload：`load`事件（读取操作完成）的监听函数，通常在这个函数里面使用`result`属性，拿到文件内容。
> - FileReader.onloadstart：`loadstart`事件（读取操作开始）的监听函数。
> - FileReader.onloadend：`loadend`事件（读取操作结束）的监听函数。
> - FileReader.onprogress：`progress`事件（读取操作进行中）的监听函数。

> FileReader 有以下实例方法:
>
> - FileReader.abort()：终止读取操作，`readyState`属性将变成`2`。
> - FileReader.readAsArrayBuffer()：以 ArrayBuffer 的格式读取文件，读取完成后`result`属性将返回一个 ArrayBuffer 实例。
> - FileReader.readAsBinaryString()：读取完成后，`result`属性将返回原始的二进制字符串。
> - FileReader.readAsDataURL()：读取完成后，`result`属性将返回一个 Data URL 格式（Base64 编码）的字符串，代表文件内容。对于图片文件，这个字符串可以用于`<img>`元素的`src`属性。注意，这个字符串不能直接进行 Base64 解码，必须把前缀`data:*/*;base64,`从字符串里删除以后，再进行解码。
> - FileReader.readAsText()：读取完成后，`result`属性将返回文件内容的文本字符串。该方法的第一个参数是代表文件的 Blob 实例，第二个参数是可选的，表示文本编码，默认为 UTF-8。

## 前端二进制ArrayBuffer、TypedArray、DataView、Blob、File、Base64、FileReader一次性搞清楚

- Blob、ArrayBuffer、File可以归为一类，它们都是数据；
- FileReader算是一种工具，用来读取数据；
- FormData可以看做是一个应用数据的场景

### ArrayBuffer

`ArrayBuffer`对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图进行操作。

```js
// 创建一个长度为 16 的 buffer 它会分配一个 16 字节（byte）的连续内存空间，并用 0 进行预填充。
const buffer1 = new ArrayBuffer(16);
```

### TypedArray

TypedArray是一组构造函数，一共包含九种类型，每一种都是一个构造函数。

TypedArray的构造函数接受三个参数，第一个ArrayBuffer（其实还可以是数组、视图这里不细说）对象，第二个视图开始的字节号（默认0），第三个视图结束的字节号（默认直到本段内存区域结束）。

| 名称              | 占用字节 | 描述                                   |
| ----------------- | -------- | -------------------------------------- |
| Int8Array         | 1        | 8位有符号整数                          |
| Uint8Array        | 1        | 8位无符号整数                          |
| Uint8ClampedArray | 1        | 8位无符号整型固定数组(数值在0~255之间) |
| Int16Array        | 2        | 16位有符号整数                         |
| Uint16Array       | 2        | 16位无符号整数                         |
| Int32Array        | 4        | 32 位有符号整数                        |
| Uint32Array       | 4        | 32 位无符号整数                        |
| Float32Array      | 4        | 32 位 IEEE 浮点数                      |
| Float64Array      | 8        | 64 位 IEEE 浮点数                      |

```js
// Uint8Array —— 将 ArrayBuffer 中的每个字节视为 0 到 255 之间的单个数字（每个字节是 8 位）。这称为 “8 位无符号整数”。
// Uint16Array —— 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。
// Uint32Array —— 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。
// Float64Array —— 将每 8 个字节视为一个 5.0x10-324 到 1.8x10308 之间的浮点数。

const uint8 = new Uint8Array(buffer1);
const uint16 = new Uint16Array(buffer1);
const uint32 = new Uint32Array(buffer1);
const float64 = new Float64Array(buffer1);
```

### DataView

`DataView` 就是一种更灵活的视图，DataView视图支持除Uint8ClampedArray以外的八种类型。DataView比使用TypedArray更方便，只需要简单的创建一次就能进行各种转换。

```js
// 可以转成各种格式
const dataView1 = new DataView(buffer1);
console.log(dataView1);
console.log(dataView1.getUint8(0));
console.log(dataView1.getUint16(0));
console.log(dataView1.getUint32(0));
console.log(dataView1.getFloat64(0));
```

### Blob

`Blob` 对象表示一个不可变、原始数据的类文件对象。

```js
// 构造函数
const blob = new Blob(array, options)
```

- array 是一个由`ArrayBuffer, ArrayBufferView, Blob, DOMString` 等对象构成的数组，`DOMStrings`会被编码为UTF-8。
- options 是一个可选，它可能会指定如下两个属性：
    - type，默认值为 `""`，内容的MIME类型。
    - endings，默认值为`"transparent"`，用于指定包含行结束符`\n`的字符串如何被写入。 它是以下两个值中的一个： `"native"`，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 `"transparent"`，代表会保持blob中保存的结束符不变

```js
const blob1 = new Blob(['hello randy'], { type: "text/plain" });
```

#### 属性

- `type` 类型 [常见的MIME 类型](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types%2FCommon_types)
- `size` 大小、单位为字节

```js
const blob = new Blob(["hello", "randy"], { type: "text/plain" });
// 输出的对象有如下属性
// size: 10;
// type: "text/plain";
console.log(blob);
```

#### 方法

- `slice()` 从 `Blob` 中截取一部分并返回一个新的 `Blob`(用法同数组的 `slice`)
- `arrayBuffer()` 返回一个以二进制形式展现的 `promise`
- `stream()` 返回一个`ReadableStream`对象
- `text()` 返回一个文本形式的 `promise`

```js
// 转成stream
console.log(blob.stream());

// 转成Arraybuffer
blob.arrayBuffer().then((res) => {
  console.log(res);
});

// 转成文本
blob.text().then((res) => {
  console.log(res);
});
```

#### blob url

简单的理解一下就是将一个`file`或`Blob`类型的对象转为`UTF-16`的字符串，并保存在当前操作的`document`下，存储在内存中。

类似这样一个链接

```js
blob:http://localhost:3000/53acc2b6-f47b-450f-a390-bf0665e04e59
```

生成blob url使用的方法是`URL.createObjectURL(file/blob)`。清除方式只有页面`unload()`事件或者使用`URL.revokeObjectURL(objectURL)`手动清除 。

这在前端下载中经常会用到。

```js
export const downloadFile = async (params, fileName) => {
  // 我们使用axios设置接口返回类型 responseType: "blob", 所以这里从后端返回的是blob。
  const results = await download(params);
  
  const a = document.createElement("a");
  a.download = fileName + ".xlsx";
  // 生成blob url。这里可以使用Blob对象或者File对象
  a.href = window.URL.createObjectURL(results);
  a.style.display = "none";
  document.body.appendChild(a);
  a.click();
  // 释放内存
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
};
```

### File

`File` 描述文件信息的一个对象，可以让 `JavaScript` 访问文件信息。`File` 继承于 `Blob`。

```js
const file = new File(array, name[, options])
```

- array 是一个由`ArrayBuffer, ArrayBufferView, Blob, DOMString` 等对象构成，`DOMStrings`会被编码为UTF-8。
- name 表示文件名称，或者文件路径。
- options 是一个可选，它可能会指定如下两个属性：
    - type，默认值为 `""`，内容的MIME类型。
    - lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。

#### 属性

- `type` 类型 [常见的MIME 类型](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types%2FCommon_types)
- `size` 大小、单位为字节
- `name` 文件名称
- `lastModified` 最后修改时间（时间戳）
- `lastModifiedDate` 最后修改时间

```js
const file1 = new File(["文件对象"], "test", { type: "text/plain" });
// 输出的对象有如下属性
// lastModified: 1640589621358
// lastModifiedDate: Mon Dec 27 2021 15:20:21 GMT+0800 (中国标准时间) {}
// name: "test"
// size: 12
// type: "text/plain"
// webkitRelativePath: ""
console.log(file1);
```

#### 方法

- `slice()` 从 `Blob` 中截取一部分并返回一个新的 `Blob`(用法同数组的 `slice`)
- `arrayBuffer()` 返回一个以二进制形式展现的 `promise`
- `stream()` 返回一个`ReadableStream`对象
- `text()` 返回一个文本形式的 `promise`

```js
// 转成stream
console.log(file1.stream());

// 转成Arraybuffer
file1.arrayBuffer().then((res) => {
  console.log(res);
});

// 转成文本
file1.text().then((res) => {
  console.log(res);
});
```

### Base64

#### 定义

Base64是一种编码格式，在前端经常会碰到，格式是 `data:[<mediatype>][;base64],<data>` 。

除了使用工具进行Base64编码外，js还内置了两个方法能进行字符串的Base64的编码和解码。

```js
const str1 = "hello randy";

// 编码
const b1 = window.btoa(str1);
console.log(b1); // aGVsbG8gcmFuZHk=

// 解码
const str2 = window.atob(b1);
console.log(str2); // hello randy
复制代码
```

#### 优点

1. 可以将二进制数据（比如图片）转化为可打印字符，方便传输数据。
2. 对数据进行简单的加密，肉眼是安全的。
3. 如果是在html或者css处理图片，可以减少http请求。

#### 缺点

1. 内容编码后体积变大， 至少大1/3。因为是三字节变成四个字节，当只有一个字节的时候，也至少会变成三个字节。
2. 编码和解码需要额外工作量。

### FileReader

FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容.

#### 属性

| 属性                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| FileReader.error      | 一个DOMException，表示在读取文件时发生的错误 。              |
| FileReader.result     | 返回文件的内容。只有在读取操作完成后，此属性才有效，返回的数据的格式取决于是使用哪种读取方法来执行读取操作的。 |
| FileReader.readyState | 表示FileReader状态的数字。0 还没有加载任何数据。1 数据正在被加载。2 已完成全部的读取请求。 |

#### 方法

需要注意的是 ，无论读取成功或失败，方法并不会返回读取结果，这一结果存储在 result属性中。

| 方法名                          | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| FileReader.abort()              | 中止读取操作。在返回时，readyState 属性为 DONE。             |
| FileReader.readAsArrayBuffer()  | 将读取的内容转成ArrayBuffer。                                |
| FileReader.readAsBinaryString() | 将读取的内容转成二进制数据。                                 |
| FileReader.readAsDataURL()      | 将读取的内容转成并将其编码为 base64 的 data url。 格式是 `data:[<mediatype>][;base64],<data>` |
| FileReader.readAsText()         | 将数据读取为给定编码（默认为 utf-8 编码）的文本字符串。      |

#### 事件

| 事件                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| FileReader.onabort     | 处理 abort 事件。该事件在读取操作被中断时触发。              |
| FileReader.onerror     | 处理 error 事件。该事件在读取操作发生错误时触发。            |
| FileReader.onload      | 处理 load 事件。该事件在读取操作完成时触发。                 |
| FileReader.onloadstart | 处理 loadstart 事件。该事件在读取操作开始时触发。            |
| FileReader.onloadend   | 处理 loadend 事件。该事件在读取操作结束时（要么成功，要么失败）触发。 |
| FileReader.onprogress  | 处理 progress 事件。该事件在读取Blob时触发。                 |

#### 例子

```js
const blob3 = new Blob(["hello", "randy"], { type: "text/plain" });

const fileReader = new FileReader();

fileReader.readAsDataURL(blob3);

fileReader.onload = () => {
  console.log(fileReader);
  // 通过fileReader获取结果
  // fileReader.result 是结果（如果成功）
  // fileReader.error 是 error（如果失败）。
};
```

### 相互转换

#### Blob和File的互相转换

##### Blob转File

```js
const blob1 = new Blob(["blob文件"], { type: "text/plain" });
// blob转file
const file2 = new File([blob1], "test2", { type: blob1.type });
console.log("file2: ", file2);
```

##### File转Blob

```js
const file1 = new File(["文件对象"], "test", { type: "text/plain" });
// file转blob
const blob2 = new Blob([file1], { type: file1.type });
console.log("blob2: ", blob2);
```

#### File、Blob、img转Base64

##### Blob转Base64

```js
// Blob转Base64
const blob = new Blob(["hello", "randy"], { type: "text/plain" });

const fileReader = new FileReader();

fileReader.readAsDataURL(blob);

fileReader.onload = () => {
  console.log(fileReader.result); // "data:text/plain;base64,aGVsbG9yYW5keQ=="
};
```

##### File转Base64

```js
// File转Base64
const file1 = new File(["文件对象"], "test", { type: "text/plain" });

const fileReader = new FileReader();

fileReader.readAsDataURL(file1);

fileReader.onload = () => {
  console.log(fileReader); // "data:text/plain;base64,5paH5Lu25a+56LGh"
};
```

##### img转Base64

```js
// 本地图片转base64，注意链接是本地链接不能是网络地址。
const img2base64 = (imgUrl) => {
  let image = new Image();
  image.src = imgUrl;
  return new Promise((resolve) => {
    image.onload = () => {
      let canvas = document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      var context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      let dataUrl = canvas.toDataURL("image/png");
      resolve(dataUrl);
    };
  });
};

img2base64("../vue2/src/assets/logo.png").then((res) => {
  console.log(res);
});
```

#### Base64转Blob、File

##### Base64转Blob

```js
function dataURLtoBlob(dataurl) {
  // `data:[<mediatype>][;base64],<data>`
  var arr = dataurl.split(","),
    mime = arr[0].match(/:(.*?);/)[1],
    bstr = atob(arr[1]),
    n = bstr.length,
    u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
}
```

##### Base64转File

```js
function dataURLtoFile(dataurl, filename) {
  //将base64转换为文件
  var arr = dataurl.split(","),
    mime = arr[0].match(/:(.*?);/)[1],
    bstr = atob(arr[1]),
    n = bstr.length,
    u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new File([u8arr], filename, { type: mime });
}
```

## **FormData**

使用FormData我们可以异步上传一个二进制文件，而这个二进制文件就是Blob对象

在 `post` 提交数据时我们常采用 `application/json`、`application/x-www-form-urlencoded` 等类型，也确实能够覆盖到大部分的场景，但是有一些场景下，比如文件上传的时候，就不算是好的解决方案了

`application/json` 作为请求头 `Content-Type` 字段值时，表示告知服务端参数是序列化后的 `JSON` 字符串，所以一般在传参时都会用 `JSON.stringify` 序列化一下

浏览器对 `JSON.stringify` API 支持程度比较高，但是 `JSON.stringify` 在转换某一些数据结构时会出问题，比如 会丢失 function 类型的参数、循环引用时会报错、`Blob` /`File` 对象会被转化成 `{}` 等等

`FormData` 这种方式相信很多同学都比较熟悉，它提供了一种表示表单数据的键值对 `key/value` 的构造方式，由名称和定义就知道 `FormData` 是专门为表单量身定做的类型，但其实其功能要比 `application/json` 强得多，比如文件上传的问题，用 `FormData` 传参能很好的解决，`window` 上也直接挂载了 [FormData](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFormData) 对象，很方便我们直接使用。

我们在控制台实例化一个 `FormData` 对象

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e1c9e81b71b4f53a80add2783fc547b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

### 使用

可以看到其原型上有很多的方法，个人感觉这个 `FormData` 跟 `Map` 有点像，仔细观察可以知道都有 `set`、`get`、`values`、`has` 等方法，我们平常开发主要的使用也就是  `append` 方法了，一般都会封装一层 `request`，调用层只需要传入参数的对象集合就可以。

```javascript
const specialFileType = ['Blob', 'File'];

function formatData (_data) {
  const data = new window.FormData()
  for (const key in _data) {
    let value = _data[key]
    if (_data[key] instanceof Object && !specialFileType.includes(_data[key].constructor.name)) {
      value = JSON.stringify(_data[key])
    }
    data.append(key, value)
  }
  return data
}
```

### `append` or `set`

这就有同学要问了，为啥不用 `set` 方法，  `MDN` 上面写的很清楚，`append` 的 `key` 存在，就会附加到已有值集合的后面，而 `set` 会使用新值覆盖已有的值，所以选择使用哪一种取决于你的需求。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e721d8a64bc44ec28711fcde66f8bc46~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

 `FormData` 在文件上传这一块比较有优势，那么它是怎么处理的呢？`FormData` 对象能够设置三种类型的值，`string`、`Blob`、`File`，所以我们不需要转换格式，可以直接传文件，当我们传递 `File` 到 `formatData` 层，会直接被 `append` 到 `FormData` 对象里，且可以通过 `get` 获取到值，然后发送请求到服务端，我们能从浏览器入参中清晰的看到 `d` 、`e` 参数的类型是 `binary`，因为就是二进制的文件类型，这样服务端接到值之后很方便获取。

```javascript
cosnt View = () => {
  const [fileA, setFileA] = useState(null);
  const [fileB, setFileB] = useState(null);
  const handleClick = () => {
    console.log('fileA:', fileA)
    console.log('fileB:', fileB)
    const p = {
      a: { a1: 11, a2: 22 },
      b: [1,2,3],
      c: 123,
      d: fileA[0],
      e: fileB[0],
    }
    const data = formatData(p);
    axios({
      method: 'POST',
      url: '/aa',
      data,
      // headers: {
      //   'content-type': 'multipart/formdata'
      // },
    })
  }

  return <div>
    <div onClick={handleClick}>发送请求</div>
    <input
      type='file'
      onChange={(a) => {
        const v = a.target.files;
      setFileA(v);
    }}
    />
    <input
      type='file'
      onChange={(a) => {
        const v = a.target.files;
      setFileB(v);
    }}
    />
  </div>
}
```

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ae6c673c2b045528b5862ac75bac2f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" />

一个参数之间都有一个 `------WebKitFormBoundary ***` 区分开，这实际上是 `FormData` 的规范标志，后面的字符串是浏览器帮我们自动创建的，以 `------WebKitFormBoundary ***`  作为分隔符，也作为开始和结尾，其内容主要有 `Content-Disposition`、`Content-Type` 等，其中 `Content-Disposition`  是必选项， `name` 属性代表着表单元素的 `key`，`filename` 则是上传文件的名称，也可以使用 `FormData` 第三个参数更改 ，另外，我在发送请求时，并没有更改请求头里面的 `Content-Type`，但实际上我们看到的是正确的 `multipart/form-data`，这是因为现在的浏览器比较智能，当客户端未设置请求头的 `Content-Type` 时，请求参数为对象时，某一些浏览器会自动帮我们在 请求头中添加 `Content-Type: text/plain`，如果传输的数据是 `FormData`，也会自动帮我们加上 `Content-Type: multipart/form-data` 等，可能不同浏览器表现行为不一样，但是最好的方式就是客户端与服务端约定好 `Content-Type` 类型，固定传递

## form-data与x-www-form-urlencoded

### 1.x-www-form-urlencoded

> application/x-www-form-urlencoded是最常见的 POST 提交数据的方式。浏览器的原生 
>
>  表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。 例如：

```html
<form action="form_action.asp" enctype="text/plain">
  <p>First name: <input type="text" name="fname" /></p>
  <p>Last name: <input type="text" name="lname" /></p>
  <input type="submit" value="Submit" />
</form>
```

查看请求头信息可以知道：

```
Content-Type: application/x-www-form-urlencoded;charset=utf-8
title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3
```

> 首先，Content-Type 被指定为 application/x-www-form-urlencoded；
>
> 其次，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式很好的支持，常用的如jQuery中的ajax请求，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8

### 2.multipart/form-data

> 这也是常见的post请求方式，一般用来上传文件，各大服务器的支持也比较好。所以我们使用表单 上传文件 时，必须让表单的enctype属性值为 multipart/form-data.

### 3.两者的联系与区别

> 以上两种方式：application/x-www-form-urlencoded和multipart/form-data都是浏览器原生支持的。

两者的区别

> x-www-form-urlencoded
>
> > 1)只能上传键值对，而且键值对都是通过&间隔分开的。

当使用js中URLencode转码方法使用，包括将name、value中的空格替换为加号；将非ascii字符做百分号编码；将input的name、value用‘=’连接，不同的input之间用‘&’连接。 百分号编码什么意思呢。比如汉字‘丁’吧，他的utf8编码在十六进制下是0xE4B881，占3个字节，把它转成字符串‘E4B881’，变成了六个字节，每两个字节前加上百分号前缀，得到字符串“%E4%B8%81”，变成九个ascii字符，占九个字节（十六进制下是0x244534254238253831）。

把这九个字节拼接到数据包里，这样就可以传输“非ascii字符的utf8编码的 十六进制表示的 字符串的 百分号形式”，^_^。

> multipart/form-data
>
> > 1)可以上传文件或者键值对，最后都会转化为一条消息.

它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；

另一种常用的方式：application/json

application/json作为响应头并不陌生，实际上，现在很多时候也把它作为请求头，用来告诉服务端消息主体是序列化的JSON字符串。

### 4.请求方法问题

先使用get方法和post方法，但不写enctype，即以默认的`application/x-www-form-urlencoded`表格数据格式进行表单请求

发现post方法和get方法都只是把文件名编码进了url中，文件内容无法得到，这也证实了上述文档中的内容，使用`application/x-www-form-urlencoded`无法实现文件上传

若使用`enctype='multipart/form-data'`，并分别使用post和get方法提交表单

在上传文件中使用get方法是无效的，依然只能得到文件名。而post结合`multipart/form-data`才能真正将文件内容传入请求体。

提交文件的格式使用一长串字符作为boundtry封装线对字段进行分割。这也很符合multipart多个部分的语义，包含了多个部分集，每一部分都包含了一个`content-desposition`头，其值为`form-data`,以及一个`name`属性，其值为表单的字段名，文件输入框还可以使用`filename`参数指定文件名。`content-type`非必须属性，其值会根据文件类型进行变化，默认值是`text/plain`。multipart的每一个part上方是边缘，最后一个part的下方添加一个边缘。

## 前端利用Blob对象创建指定文件并下载

### 1.Blob对象

Blob对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File接口基于Blob，继承了blob的功能并将其扩展使其支持用户系统上的文件。

#### 构造函数

```js
var aBlob = new Blob( array, options );
```

- array 是一个由ArrayBuffer（二进制数据缓冲区）、ArrayBufferView（二进制数据缓冲区的array-like视图）、Blob、DOMString等对象构成的Array，或者其他类似对象的混合体，它将会被放进Blob。DOMStrings会被编码为UTF-8。
- options 是可选的，它可能会指定如下两个属性：
    - type，默认值为 ""，它代表了将会被放入到blob中的数组内容的MIME类型。
    - endings，默认值为"transparent"，用于指定包含行结束符\n的字符串如何被写入。 它是以下两个值中的一个： "native"，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 "transparent"，代表会保持blob中保存的结束符不变。

#### 示例

```js
var debug = {hello: "world"};
var blob = new Blob([JSON.stringify(debug, null, 2)],
  {type : 'application/json'});
```

### 2.URL对象

通过创建URL对象指定文件的下载链接。

#### 构造函数

创建新的URL表示指定的File对象或者Blob对象。

```js
objectURL = window.URL.createObjectURL(blob);
```

#### window.URL.revokeObjectURL()

在每次调用`createObjectURL`方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 `URL.revokeObjectURL`方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。

```js
window.URL.revokeObjectURL(objectURL);
```

### 3.利用`<a>`标签下载

生成一个`<a>`标签。

```js
const link = document.createElement('a');
```

#### href属性指定下载链接

```js
link.href = window.URL.createObjectURL(blob);
```

#### dowload属性指定文件名

download 属性规定被下载的超链接目标。在`<a>`标签中必须设置 href 属性。该属性也可以设置一个值来规定下载文件的名称。所允许的值没有限制，浏览器将自动检测正确的文件扩展名并添加到文件 (.img, .pdf, .txt, .html, 等等)。

```js
link.download = fileName;
```

#### click()事件触发下载

```js
link.click();
```

### 4.创建并下载

选择相应的MIME类型并设置编码。

```js
const foo = {hello: "world"};
const blob = new Blob([JSON.stringify(foo)], type: 'application/vnd.ms-excel;charset=utf-8');
const fileName = `${new Date().valueOf()}.xls`;
const link = document.createElement('a');
link.href = window.URL.createObjectURL(blob);
link.download = fileName;
link.click();
window.URL.revokeObjectURL(link.href);
```

**注** ：下载指定扩展名的文件只需要对照[MIME 参考手册](https://link.juejin.cn?target=http%3A%2F%2Fwww.w3school.com.cn%2Fmedia%2Fmedia_mimeref.asp)设置type即可。

### 5.兼容IE

在IE中要使用`window.navigator.msSaveOrOpenBlob`来处理Blob对象。

```js
window.navigator.msSaveOrOpenBlob(blob, fileName);
```

### 6.Promise写法

基于axios的写法。

```js
axios.get(`url`, {
        responseType: 'arraybuffer',
    }).then(res => {
        if (res.status == 200) {
            let blob = new Blob([res.data], {
                type: 'application/vnd.ms-excel;charset=utf-8'
            });
            let fileName = `yourfile.xls`;
            // for IE
            if (window.navigator && window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveOrOpenBlob(blob, fileName);
            } else {
                // for Non-IE
                let objectUrl = URL.createObjectURL(blob);
                let link = document.createElement("a");
                link.href = objectUrl;
                link.setAttribute("download", fileName);
                document.body.appendChild(link);
                link.click();
                window.URL.revokeObjectURL(link.href);
            }
        } else {
            // error handler
        }
    });
```

### 7.实现导出table生成excel

```js
const saveFile = (content, fileName) => {
  const blob = new Blob([content]);
  if (window.navigator.msSaveOrOpenBlob) {
    navigator.msSaveBlob(blob, fileName);
  } else {
    const elink = document.createElement("a");
    elink.download = fileName;
    elink.style.display = "none";
    elink.href = URL.createObjectURL(blob);
    document.body.appendChild(elink);
    elink.click();
    document.body.removeChild(elink);
  }
};
```



```js
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <table id="table">
        <tr>
            <th>asf</th>
            <th>asf</th>
            <th>asf</th>
        </tr>
        <tr>
            <td>asf</td>
            <td>asf</td>
            <td>asf</td>
        </tr>
    </table>
    <script>
        function base64(content) {
            return window.btoa(unescape(encodeURIComponent(content)));
        }
        function tableToExcel(tableID, fileName) {
            var excelContent = document.querySelector(tableID).innerHTML;
            var excelFile = "<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:x='urn:schemas-microsoft-com:office:excel' xmlns='http://www.w3.org/TR/REC-html40'>";
            excelFile += "<head><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>{worksheet}</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--></head>";
            excelFile += "<body><table width='10%'  border='1'>";
            excelFile += excelContent;
            excelFile += "</table></body>";
            excelFile += "</html>";
            var link = "data:application/vnd.ms-excel;base64," + base64(excelFile);
            var a = document.createElement("a");
            a.download = fileName + ".xlsx";
            a.href = link;
            a.click();
        }
        tableToExcel('#table', 'table')
    </script>
</body>

</html>
```

## [如何使用 WebWorker 对用户体验进行革命性的提升](https://blog.csdn.net/weixin_46837985/article/details/121917951)

## 纯前端生成Excel文件骚操作——WebAssembly & web workers

[纯前端生成Excel文件骚操作——WebAssembly & web workers](https://juejin.cn/post/7037413658795704356)

## 前端文件压缩

[前端批量获取文件并打包压缩解决方案](https://juejin.cn/post/6970866355977486349)

[前端性能优化gzip初探（补充gzip压缩使用算法brotli压缩的相关介绍)](https://juejin.cn/post/6844903887871148046)

## 前端图片压缩

[前端图片压缩上传（压缩篇）：可能是最适合小白的前端图片压缩文章了！](https://juejin.cn/post/6844903495703904263)

[在前端如何玩转 Word 文档](https://juejin.cn/post/6850037262445445134)

## el-upload使用

1、action
上传的地址，接口地址
直接在 action 中写后端地址会出现跨域问题，而且传参数不方便
就用 http-request 指定具体上传方法

2、auto-upload
是否在选取文件后立即进行上传，默认 true
在 action 赋空值，使用 http-request 指定方法上传时，auto-upload 为 false

3、http-request
覆盖默认的上传行为1，可以自定义上传的实现
默认的上传方法均失效，获取不到 file 值
需要使用 on-change2 做上传文件前的处理

4、上传文件显示进度条
el-progress3
5、上传 .xls , .xlsx 文件并显示进度条的实现代码

```js
<el-dialog
  ref=""
  append-to-body
  :title="excel.title"
  v-if="excel.visible"
  :close-on-click-modal="false"
  :visible.sync="excel.visible"
>
  <el-upload
    class="upload-demo"
    ref="upload"
    action=""
    :limit="1"
    :auto-upload="false"
    :file-list="excel.upload.fileList"
    :on-change="excelChange"
    :http-request="excelRequest"
    :on-remove="excelRemove"
  >
    <el-button icon="el-icon-upload2" plain @click="excelReset">{{ st('frame.choiceFile') }}</el-button>
    <div slot="tip" class="el-upload__tip">只能上传 .xlsx 和 .xls 文件，且不超过1个文件</div>
  </el-upload>
  <el-progress v-show="excel.progressFlag" :percentage="excel.loadProgress"></el-progress>
  <div ref="uploadFile"></div>
  <div slot="footer" class="dialog-footer">
    <el-button type="primary" @click="cancel()">{{st('frame.cancel')}}</el-button>
    <el-button type="success" @click="submitFile()">{{st('publicCustom.ok')}}</el-button>
  </div>
</el-dialog>
data() {
	return {
      excel: {
        title: this.st('frame.import'),
        visible: false,
        progressFlag: false,
        loadProgress: 0,
        upload: {
          fileList: [],
          action: '',
          headers: {},
          data: {
            jsondata: ''
          }
        }
      }
   }
}
methods: {
	excelReset() {
      this.excel.upload.fileList = []
      this.$refs.uploadFile.innerHTML = null
    },
    excelRemove() {
      this.excel.upload.fileList = []
      this.excel.progressFlag = false
      this.$refs.uploadFile.innerHTML = null
      this.excel.loadProgress = 0
    },
    excelChange(file) {
      if (file.name.indexOf('.xlsx') == -1 && file.name.indexOf('.xls') == -1) {
        this.$message.error(this.st('frame.uploadError'))
        this.excel.upload.fileList = [] 
      } else {
        if(file.status === 'ready'){
          this.excel.progressFlag = true
          this.excel.loadProgress = 0
          const interval = setInterval(() => {
            if(this.excel.loadProgress >=99){
              clearInterval(interval)
              return
            }
            this.excel.loadProgress += 1
          }, 20)
        }
        this.excelRequest(file)
      }
    },
    excelRequest(file) {
      var form = new FormData()
      form.append("file", file.raw)
      InportPbomPartExcel(form).then((res) => {
        if (res.resultData.success) {
          const url = settings.api.url + res.resultData.fileName
          window.open(url)
          let template = res.resultData.MessageString
          this.$refs.uploadFile.innerHTML = template
          this.excel.progressFlag = false
          this.excel.loadProgress = 100
        } else {
          this.$message.error(res.resultData.MessageString)
        }
      })
    }
}

```

on-preview 点击文件列表中已上传的文件时的钩子
on-success 文件上传成功时的钩子
on-progress 文件上传时的钩子
before-upload 上传文件之前的钩子，参数为上传的文件，若返回 false 或者返回 Promise 且被 reject，则停止上传
on-change 文件状态改变时的钩子，添加文件、上传成功和上传失败时都会被调用

```js
<el-upload 
 action="Fake Action" :before-upload="uploadSuccess" :on-change="uploadVideoProcess" :show-file-list="false" :file-list="fileList">
 <el-button v-if="typePage !=='view'" size="mini" type="primary">点击上传</el-button>
 <span v-if="typePage !=='view'" slot="tip" class="el-upload__tip">支持pdf,jpg,png格式文件</span>
</el-upload>
<el-progress v-show="progressFlag" :percentage="loadProgress"></el-progress>

uploadVideoProcess(file, fileList) { 
   if(file.status === 'ready'){
      this.progressFlag = true; // 显示进度条
      this.loadProgress = 0; 
      const interval = setInterval(() => {
        if(this.loadProgress >=99){
          clearInterval(interval)
          return
        }
        this.loadProgress += 1
      }, 20);
    }
  if (file.status === 'success') {
    this.progressFlag = false; // 不显示进度条
    this.loadProgress = 100;
  }
}

```

## el-upload实现多个文件上传

最近在用 Vue 开发项目的时候有一个需求，需要导入 word 文档，并且需要支持多选。`element-ui` 的 `upload` 组件支持多选文件，只需要配置参数 `multiple` 为 `true` 即可。但是这个组件默认会将多选的文件分多次进行上传，于是就会存在多次的上传请求，由于后台的接口要求是一次请求能够上传多个文件，且我们也知道请求多了会对服务器造成更大的压力，因而基于多种原因，这个 `upload` 的上传行为得进行改造一番。

### 前后的结果

改造前的结果：同时上传2个文件，会发出2次对接口的请求，每次请求里包含了一个文件。

![upload_result_after](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5c97d1272244c47aa33829c44a6bb6c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

改造后的结果：同时上传2个文件，会发出一次接口请求，接口入参里包含2个文件。

![upload_result_after](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c17564ad8d14795a8d2699f05d6b83b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

### 方法一：通过配置file-list（推荐使用）

html部分：

```html
<el-upload
    class="upload-demo list-uploadbtn"
    ref="upload"
    :action="curBastUrl"
    :auto-upload="false"
    :on-remove="updataRemove"
    :before-upload="beforeUpload"
    :on-change="updatachange"
    :file-list="fileList"
    :multiple="true">
    <el-button size="small">点击上传</el-button>
</el-upload>
<el-button type="primary" @click="submitUpload">确 定</el-button>
```

js部分：

```js
submitUpload() {  // 导入
    let formData = new FormData();  //  用FormData存放上传文件
    this.fileList.forEach(file => { 
        formData.append('file', file.raw)		
    }) 
    　　    
    formData.append('categoryDirectory', this.filedata.categoryDirectory)

    // importCase是上传接口
    importCase(formData).then((res) => { 
        //手动上传无法触发成功或失败的钩子函数，因此这里手动调用 
    　　this.updataSuccess(res.data) 
    }, (err) => {
    　　 
    })
}
```

关键代码说明：

- `auto-upload` 设置为 `false` 用于关闭组件的自动上传；
- `file-list` 配置一个数组用于接收上传的文件列表；
- `multiple` 设置为 `true` 表示支持多选文件；
- `action` 配置为完整的上传接口url，不配置会报错
- 不用配置 `data`、`on-success`、`on-error`等参数，因为手动上传不会用到这些配置信息；
- 最后通过点击按钮手动调用上传函数 	`submitUpload` ，创建一个 `FormData` 把 `fileList ` 的文件存进去。

### 方法二：通过配置http-request

html部分：

```html
<el-upload
    class="upload-demo list-uploadbtn"
    ref="upload"
    :action="curBastUrl"
    :auto-upload="false"
    :http-request="uploadFile"
    :on-remove="updataRemove"
    :before-upload="beforeUpload"
    :on-change="updatachange"
    :multiple="true">
    <el-button size="small">点击上传</el-button>
</el-upload>
<el-button type="primary" @click="submitUpload">确 定</el-button>
```

js部分：

```js
submitUpload() {  // 导入
    let tempData =  this.filedata
    this.filedata = new FormData()  //  用FormData存放上传文件
    this.$refs.upload.submit()  // 会循环调用uploadFile方法，多个文件调用多次

    this.filedata.append('categoryDirectory', tempData.categoryDirectory)

    // importCase是上传接口
    importCase(this.filedata).then((res) => { 
    //手动上传无法触发成功或失败的钩子函数，因此这里手动调用 
    　　this.updataSuccess(res.data) 
    }, (err) => {
    　　 
    })
}
uploadFile(file) {
    this.filedata.append('file', file.file)
}
```

关键代码说明：

- `http-request` 自定义上传方法；
- 最后通过点击按钮手动调用上传函数 	`submitUpload` ，创建一个 `FormData`, 调用 `upload` 组件的 `submit` 方法的时候会循环调用 `http-request` 配置的方法，从而往 `FormData ` 里存放文件。

## el-upload源码分析



## el-upload组件二次封装

主要需求就三个，如下：

- 文件拖拽上传
- 不仅能单文件上传，多文件也可以同时上传
- 显示上传列表，能够对已上传文件进行撤销操作

### template

```js
    <div class="upload-file">
        <el-upload
                :action="uploadFileUrl"
                :before-upload="handleBeforeUpload"
                :file-list="fileList"
                show-file-list
                drag
                multiple
                :limit="limit"
                :on-error="handleUploadError"
                :on-exceed="handleExceed"
                :on-success="handleUploadSuccess"
                :on-preview="handleUploadedPreview"
                :before-remove="beforeDelete"
                :on-remove="handleDelete"
                class="uploader"
                ref="upload"
        >
            <i class="el-icon-upload"></i>
            <div class="el-upload__text">将文件拖到此处，或 <em>选取文件</em> 上传</div>

            <!-- 上传按钮 -->
            <!--<el-button size="mini" type="primary">选取文件</el-button>-->

            <!-- 上传提示 -->
            <div class="el-upload__tip" slot="tip" v-if="showTip">
                <template v-if="fileSize"> 请上传大小不超过 <b style="color: #f56c6c"> {{ fileSize }} KB</b> </template>
                <template v-if="fileType"> 格式为 <b style="color: #f56c6c">{{ fileType.join("/") }}</b> 的文件</template>
            </div>
        </el-upload>
    </div>
```

### props 

props自定义属性，接收来自父组件的数据

```js
props: {
    // 上传文件数量限制
    limit: {
        type: Number,
        default: 5
    },
    // 单个上传文件大小限制
    fileSize: {
        type: Number,
        default: 500
    },
    // 允许上传的文件类型, 例如['png', 'jpg', 'jpeg']
    fileType: {
        type: Array,
        default: () => ["doc", "xls", "ppt", "txt", "pdf", 'png', 'jpg', 'jpeg']
    },
    // 是否显示文件上传提示
    isShowTip: {
        type: Boolean,
        default: true
    }
}
```

### data

data 数据定义

```js
data() {
    return {
        // 上传的图片请求地址
        uploadFileUrl: "http://localhost:8088/file/upload",
        fileList: [],
        notifyPromise: Promise.resolve()
    };
}
```

### methods 方法

#### 各方法解析

- `handleBeforeUpload()` 上传文件之前的钩子，参数为上传的文件，若返回 `false` 或者返回 `Promise` 且被 `reject`，则停止上传。
- `handleExceed()` 文件超出个数限制时执行弹出警告通知框。
- `handleUploadError()` 文件上传失败时执行弹出警告通知框，同时关闭上传加载。
- `handleUploadSuccess()` 单个文件上传成功就执行。
- `beforeDelete()` 删除文件之前的钩子，参数为上传的文件和文件列表，若返回 `false` 或者返回 `Promise` 且被 `reject`，则停止删除。
- `handleDelete()` 文件列表移除文件时执行，调用删除文件接口，去删除指定的上传文件。
- **uploadFileDelete()** 传入指定文件 `url` 和该文件在 `fileList` 中的索引，后端根据文件文件路径删除已上传的文件，然后移除 `fileList` 中索引值位置上的 `file`。
- **warningNotify()** 接收一个参数，即警告信息，用来弹出警告框的，有 2s 的延迟消失时间。

```js
methods: {
    // 上传前校检格式和大小
    handleBeforeUpload(file) {
        // 校检文件类型
        if (this.fileType) {
            let fileExtension = "";
            if (file.name.lastIndexOf(".") > -1) {
                fileExtension = file.name.slice(file.name.lastIndexOf(".") + 1);
            }
            const isTypeOk = this.fileType.some((type) => {
                return fileExtension && fileExtension.indexOf(type) > -1;

            });
            if (!isTypeOk) {
                this.warningNotify(`文件格式不正确，请上传${this.fileType.join("/")}格式文件！`);
                return false;
            }
        }
        // 校检文件大小
        if (this.fileSize) {
            // KB
            const fileSize = file.size / 1024;
            const isLt = fileSize < this.fileSize;
            if (!isLt) {
                this.warningNotify(`上传文件大小不能超过 ${this.fileSize} KB!`);
                return false;
            }
        }
        // 开始上传
        this.loading = this.$loading({
            lock: true,
            text: "上传中...",
            background: "rgba(0, 0, 0, 0.7)",
        });
        return true;
    },
    // 文件个数超出限制
    handleExceed() {
        this.$message.warning(`上传文件数量不能超过 ${this.limit} 个!`);
    },
    // 上传失败
    handleUploadError(err) {
        this.$message.error(`上传失败[${err}], 请重试`);
        this.loading.close();
    },
    // 上传成功回调
    handleUploadSuccess(res, file, fileList) {
        if (res.resultCode === 200) {
            file['url'] = res.data.path;
            //this.fileList.push(file);  报错 Cannot set properties of null (setting 'status')
            this.$message.success("上传成功");
            this.loading.close();
        } else {
            this.handleUploadError(res.message);
        }
    },
    // 删除上传文件前
    beforeDelete(file, fileList) {
        this.fileList = fileList;
        if (file.status === 'success') {
            return this.$confirm(`确定删除文件【${file.name}】`);
        }
    },
    // 删除上传文件
    handleDelete(file, fileList) {
        if (file.status === 'success') {
            let filePath = file.url;
            let fileIndex;
            this.fileList.forEach((it, index) => {
                if (it.url === filePath) {
                    fileIndex = index;
                }
            });
            // 删除已上传的文件
            this.uploadFileDelete(filePath, fileIndex);
        }
    },
    uploadFileDelete(filePath, fileIndex) {
        let _this = this;
        if (fileIndex >= 0) {
            this.axios({
                method: 'DELETE',
                url: '/file/upload/delete',
                headers: {'content-type': 'application/json'},
                data: filePath
            }).then((response) => {
                let data = response.data;
                if (data.resultCode === 200) {
                    this.$message({
                        type: 'success',
                        message: data.message
                    });
                    _this.fileList.splice(fileIndex, 1);
                } else {
                    this.$message.error(data.message);
                }
            }).catch(error => {
                this.$message.error(error);
            });
        } else {
            this.$message.error("未找到上传文件，无法删除");
        }
    }
}
```

#### bug解决

##### notifyPromise: Promise.resolve() 解决组件高度坍塌问题

当多文件上传前文件格式校验不通过时，弹出警告消息，但 Element 一下子同时调用了多次 this.$notify 方法，导致通知消息框高度坍塌，重叠在一起了 ↓

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2a092c9ef2740bb933eda0d3fda3c1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

面向 `Baidu` 编程后，找到了一种采用 `Promise` 的回调方法可以解决 `Element Notification` 组件高度塌陷问题

$notify

> `$notify`计算通知的间距时，会拿当前元素的高度，但是因为`vue`的异步更新队列存在缓冲机制，第一次方法调用时，并没有更新`dom`，导致拿到的高度为**0**，所有第二个通知框只是上移了默认的 `offset 16px`。

```js
    warningNotify(msg) {
        let _this = this;
        this.notifyPromise = this.notifyPromise.then(_this.$nextTick).then(() => {
            _this.$notify({
                type: 'warning',
                title: '警告',
                message: msg,
                duration: 2000
            });
        });
    }

```

> 使用`vue`提供的`nextTick`方法，保证第一次通知的`dom`更新之后，再执行第二次通知的代码，此时通知框的高度就会加上第一个通知框的高度，得到正确的计算高度，这时框重叠问题就解决了。

##### 多文件上传

因为我在上传文件成功回调函数中向实例 `fileList` 中 `push` 当前上传的 `file` ， 我原本单纯认为上传成功后就可以添加到上传文件列表之中，但是实际上是不需要我们手动添加的，我这波操作简直是脱裤子放屁 o(╥﹏╥)o 还是开裆裤的那种！

从文件开始上传就已经全在文件上传列表里了，不必再次 `push`，否则会在异步多文件上传过程中干扰原来的 `fileList` ，导致上传文件的 `status` 状态为 `null`，从而导致报错

方法一： 将 `...push(file)` 注释，然后在删除文件前的回调函数中对实例中的 `fileList` 赋值就好了

方法二： 再定义一个文件上传列表 `uploadList` 用来存储上传成功的 `files`

### 使用

```js
<template>
    <upload :limit="10" :file-size="100" :is-show-tip="false"/>
</template>
<script>
    import Upload from "../file/Upload";
    export default {
        name: 'Example',
        components: {Upload},
        data() {
            return {
            }
        },
        methods: {
        }
    }
</script>
```

