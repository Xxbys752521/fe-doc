## 编码和加密

### 1.摘要算法 md5等

[摘要和加密](https://juejin.cn/post/6844903561478799368)

MD5算法就是一种常见的摘要算法。该算法可以生成压缩包的一个128 bit 的二进制串。除了压缩包，也可以应用于其他文件和字符串。比如数据库中不会直接存储账号密码，比如我就习惯将 密码拼接一个无规律的字符串 然后计算出MD5摘要放入数据库中

摘要

-   摘要是哈希值，我们通过散列算法比如MD5算法就可以得到这个哈希值。
-   摘要只是用于验证数据完整性和唯一性的哈希值，不管原始数据是什么样的，得到的哈希值都是固定长度的。
-   不管原始数据是什么样的，得到的哈希值都是固定长度的，也就是说摘要并不是原始数据加密后的密文，只是一个验证身份的令牌。所以我们无法通过摘要解密得到原始数据。

加密

加密是通过 “加密算法” 将 "明文" 加密成 “密文”。 我们可以通过 “密钥” 和 “解密算法” 将 “密文” 还原成 “明文”。



### 2.base64编码

https://juejin.cn/post/6844903698045370376



### 3.字符编码理论

https://juejin.cn/post/6844903698045370376



### 4.常见加密算法

https://juejin.cn/post/6844903638117122056



### 5.登录密码加密

Hash特点：
 1.算法是公开的
 2.对相同数据运算,得到的结果是一样的
 3.对不同数据运算,如MD5得到的结果默认是128位,32个字符（16进制标识）。
 4.没法逆运算
 5.信息摘要，信息“指纹”，是用来做数据识别的。



hash加密：
 1.md5. 2.sha1  2.sha256  3.sha516

用户密码加密
 1.首先密码加密不能用rsa加密，因为rsa加密虽然在传输过程中是相对安全的，但是一旦开发人员变动带走了私钥与密钥，是很容易的获取用户的登录密码

2.hash加密，hash加密是不可逆的，加密后传输至服务端后，开发人员是获取不出用户的登录密码的，只需要将加密的hash值存入数据库中，但是这个方法现在也是不安全的。[https://www.cmd5.com](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cmd5.com)，这个网址可以查出大部分的密码

3.hash加盐：所谓的hash加盐就是在原密码的基础上，添加上一段随机字符串（该字符串是由客户端开发人员写死的），然后进行hash加密，但是这种方法对于开发者的依赖比较大还有就是灵活性不高，当用户量大了后，如果想更换盐成本会很大

4.hamc加密：也可以说是动态加盐（一个用户一个盐），当用户注册的时候，服务端会返回给客户端一个盐，然后进行两次hash加密，传输给服务端。这样不会对开发人员产生依赖，且由于是一个用户一个盐，这样更换起来也会比较方便



### 6.前后端鉴权

[傻傻分不清之 Cookie、Session、Token、JWT](https://juejin.cn/post/6844904034181070861)

#### Token

token 即使是在计算机领域中也有不同的定义，这里我们说的token，是指**访问资源的凭据**。例如当你调用Google API，需要带上有效 token 来表明你请求的合法性。这个 token 是 Google 给你的，这代表 Google 给你的授权使得你有能力访问 API 背后的资源。

请求 API 时携带 token 的方式也有很多种，通过 HTTP Header 或者 url 参数 或者 google 提供的类库都可以：

```js
// HTTP Header:
GET /drive/v2/files HTTP/1.1
Authorization: Bearer <token>
Host: www.googleapis.com/

// URL query string parameter
GET https://www.googleapis.com/drive/v2/files?token=<token>

// Python:
from googleapiclient.discovery import build
drive = build('drive', 'v2', credentials=credentials)

```

更具体的说，上面用于调用 API 的 token 我们称为细分为 access token。通常 access token 是有有效期限的，如果过期就需要重新获取。那么如何重新获取？现在我们要让时光倒流一会，回顾第一次获取 token 的流程是怎样的:

1.  首先你需要向 Google API 注册你的应用程序，注册完毕之后你会拿到认证信息（credentials）包括 ID 和 secret。不是所有的程序类型都有 secret。
2.  接下来就要向 Google 请求 access token。这里我们先忽略一些细节，例如请求参数（当然需要上面申请到的 secret）以及不同类型的程序的请求方式等。重要的是，如果你想访问的是用户资源，这里就会提醒用户进行授权。
3.  如果用户授权完毕。Google 就会返回 access token。又或者是返回授权代码（authorization code），你再通过代码取得 access token
4.  token 获取到之后，就能够带上 token 访问 API 了

注意在第三步通过 code 兑换 access token 的过程中，Google 并不会仅仅返回 access token，还会返回额外的信息，这其中和之后更新相关的就是 refresh token

一旦 access token 过期，你就可以通过 refresh token 再次请求 access token。

以上只是大致的流程，并且故意省略了一些额外的概念。比如更新 access token 当然也可以不需要 refresh token，这要根据你的请求方式和访问的资源类型而定。

### OAuth

#### SSO (Single sign-on)

通常公司内部会有非常多的工具平台供大家使用，比如人力资源，代码管理，日志监控，预算申请等等。如果每一个平台都实现自己的用户体系的话无疑是巨大的浪费，所以公司内部会有一套公用的用户体系，用户只要登陆之后，就能够访问所有的系统。这就是**单点登录（SSO: Single Sign-On）**

SSO 是一类解决方案的统称，而在具体的实施方面，我们有两种策略可供选择：1) SAML 2.0 ; 2) OAuth 2.0。

**Authentication VS Authorisation**

-   Authentication: 身份鉴别，以下简称认证
-   Authorisation: 授权

**认证**的作用在于认可你有权限访问系统，用于鉴别访问者是否是合法用户；而**授权**用于决定你有访问哪些资源的权限。大多数人不会区分这两者的区别，因为站在用户的立场上。而作为系统的设计者来说，这两者是有差别的，这是不同的两个工作职责，我们可以只需要认证功能，而不需要授权功能，甚至不需要自己实现认证功能，而借助 Google 的认证系统，即用户可以用 Google 的账号进行登陆

**Authorization Server/Identity Provider(IdP) VS Service Provider(SP)/Resource Server**

把负责认证的服务称为 Authorization Server 或者 Identity Provider，以下简称 IdP；而负责提供资源（API调用）的服务称为 Resource Server 或者 Service Provider，以下简称 SP

-   还未登陆的用户打开浏览器访问你的网站（SP，以下都简称 SP），网站提供服务但是并不负责用户认证。
-   于是 SP 向 IdP 发送了一个 SAML 认证请求，同时 SP 将用户浏览器重定向到 IdP 。
-   IdP 在验证完来自 SAML 的请求无误之后，在浏览器中呈现登陆表单让用户进行填写用户名和密码进行登陆
-   一旦用户登陆成功，IdP 会生成一个包含用户信息（用户名或者密码）的 SAML token （SAML token 又称为 SAML Assertion，本质上是 XML 节点），IdP 向 SP 返回 token, 并且将用户重定向到 SP (token 的返回是在重定向步骤中实现的，下面会详细说明)
-   SP 对拿到的 token 进行验证，并从中解析出用户信息，例如他们是谁以及他们的权限有哪些。此时就能够根据这些信息允许用户访问我们网站的内容了

当用户在 IdP 登陆成功之后，IdP 需要将用户再次重定向至 SP 站点，这一步通常有两个办法：

-   HTTP 重定向（HTTP Redirect）：这并不推荐，应为重定向的 URL 长度有限，无法携带更长的信息，比如 SMAL Token
-   HTTP POST 请求：这个是更常规的做法，当用户登陆完毕之后渲染出一个表单，用户点击后向 SP 提交 POST 请求。又或者可以使用 Javascript 向 SP 发出一个 POST 请求

如果你的应用是基于 web，那么以上的方案没有任何问题。但如果你开发的是一个 iOS 或者 Android 的手机应用，那么问题就来了：

-   用户在 iPhone 上打开应用，此时用户需要通过 IdP 进行认证
-   应用跳转至 Safari 浏览器，在登陆认证完毕之后，需要通过 HTTP POST 的形式将 token 返回至手机应用

虽然 POST 的 url 可以拉起应用，但是手机应用无法解析 POST 的内容，我们也就无法读取 SAML Token

当然还是有办法的，比如在 IdP 授权阶段不跳转至系统的 Safari 浏览器，在内嵌的 webview 中解决，在想方设法从 webview 中提取 token，或者利用代理服务器。但无论如何，SAML 2.0 并不适用于当下跨平台的场景，这也许与它产生的年代也有关系，它诞生于 2005 年，在那个时刻 HTTP POST 确实是最好的选择方案

#### OAuth 2.0

[OAuth2.0原理图解：第三方网站为什么可以使用微信登录](https://juejin.cn/post/7066716559808397343)

-   用户通过客户端（可以是浏览器也可以是手机应用）想要访问 SP 上的资源，但是 SP 告诉用户需要进行认证，将用户重定向至 IdP
-   IdP 向用户询问 SP 是否可以访问用户信息，如果用户同意，IdP 向客户端返回 access code
-   客户端拿 code 向 IdP 换 access token，并拿着 access token 向 SP 请求资源
-   SP 接受到请求之后拿着附带 token 向 IdP 验证用户的身份

用户从 IdP 返回客户端的方式是通过 URL 重定向，这里的 URL 允许自定义schema，所以即使在手机上也能拉起应用；另一方面因为 IdP 向客户端传递的是 code，而不是 XML 信息，所以 code 可以很轻易的附着在重定向 URL 上进行传递

但以上的 SSO 流程体现不出 OAuth 的本意。**OAuth 的本意是一个应用允许另一个应用在用户授权的情况下访问自己的数据,OAuth 的设计本意更倾向于授权而非认证（当然授权用户信息就间接实现了认证）**, 虽然 Google 的 OAuth 2.0 API 同时支持授权和认证。所以你在使用 Facebook 或者 Gmail 账号登陆第三方站点时，会出授权对话框告诉你第三方站点可以访问你的哪些信息，需要征得你的同意：



#### Refresh Token

为什么我们需要 refresh token？

这样的处理是为了职责的分离：refresh token 负责身份认证，access token 负责请求资源。虽然 refresh token 和 access token 都由 IdP 发出，但是 access token 还要和 SP 进行数据交换，如果公用的话这样就会有身份泄露的可能。并且 IdP 和 SP 可能是完全不同的服务提供的。而在第一小节中我们之所以没有这样的顾虑是因为 IdP 和 SP 都是 Google



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/3/164608d01d87803a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

###



## 面向对象理论

### 1.为什么选择面向对象编程



### 2.面向对象的特性



## 操作系统原理

### 1.进程和线程

进程（Process）是系统进行资源分配和调度的基本单位。

进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。

与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。

线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。

调度与操作系统的线程的实现有关，如果是管态线程与目态线程是一一对应，则调度的最小单位可以是线程，但我觉得这也就是理论上，一般的商用操作系统可能操作系统调度的单位也是进程。

[![img](https://iknow-pic.cdn.bcebos.com/ac4bd11373f08202d6a9f18045fbfbedab641b51?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_auto)](https://iknow-pic.cdn.bcebos.com/ac4bd11373f08202d6a9f18045fbfbedab641b51)



进程一般有三个状态：就绪状态、执行状态和等待状态【或称阻塞状态】；进程只能由父进程建立，系统中所有的进程形成一种进程树的层次体系；挂起命令可由进程自己和其他进程发出，但是解除挂起命令只能由其他进程发出。

进程控制块（PCB）：PCB不但可以记录进程的属性信息，以便操作系统对进程进行控制和管理，而且PCB标志着进程的存在，操作系统根据系统中是否有该进程的进程控制块PCB而知道该进程存在与否。

系统建立进程的同时就建立该进程的PCB，在撤销一个进程时，也就撤销其PCB，故进程的PCB对进程来说是它存在的具体的物理标志和体现。一般PCB包括以下三类信息：进程标识信息；处理器状态信息；进程控制信息。

### 2.进程间通信

### 3.死锁产生原因和解决

死锁：两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进。此时称这一组进程为死锁

引起死锁的原因和必要条件
引起死锁的原因：
①系统资源不足
②进程推进顺序非法

产生死锁的必要条件
①互斥条件——涉及的资源是非共享的，即为临界资源
②不剥夺条件——进程所获得的资源在未使用完毕之前，不能被其它进程强行夺走
③部分分配——进程每次申请它所需要的一部分资源。在等待新资源的同时，进程继续占用已分配到的资源
④环路条件——存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求

为了使系统不发生死锁，必须要破坏产生死锁的四个必要条件之一

①采用资源静态分配方法预防死锁
②采用资源动态分配、有控分配方法来避免死锁
③当死锁发生时检测出死锁，并设法修复
④忽略死锁，一旦发生死锁便重启系统（这种方法被绝大多数操作系统所采用）



死锁的动态避免就是采用资源动态分配的方式
①有序资源分配方法：系统中所有资源都给一个唯一的编号，所有分配请求必须以上升的次序进行，当遵守上升次序的规则时，若资源可用，则予以分配；否则，请求者等待。
②银行家算法：申请者事先说明对各类资源的最大需求量。在进程活动期间动态申请某类资源时，由系统审查现有该类资源的数目是否能满足当前进程的最大需求量，如能满足就予以分配，否则拒绝。



### 4.操作系统资源分配

资源管理目的：为用户提供一种简单而有效地使用资源的方法
任务：1、资源数据结构的描述
2、确定资源的分配原则和调度原则
3、执行资源分配
4、存取控制和安全保护

操作系统对资源区分两种不同的概念
①物理资源——系统中那些物理、可实际使用的资源
②虚拟资源——逻辑资源。是经过操作系统改造的、用户看到的，使用方便的虚资源

目的：①方便用户使用 ②资源可动态分配，提高资源利用率

资源分配机制
资源描述器：描述各类资源的最小分配单位的数据结构
资源信息块：描述某类资源的请求者、可利用的资源以及该类资源分配程序的地址

资源分配策略：在众多个请求者中选一个满足条件的请求者原则

资源分配策略具体如何体现？
体现在资源请求队列的排序原则上
（1）先请求先服务策略（FIFO）
①排序原则——按请求的先后次序排序：每一个新产生的请求均排在资源请求队列的队尾。
②资源可用时的处理：资源可用时，取资源请求队列队首元素，将该资源分配给请求者。

（2）优先调度策略
①排序原则——按请求的优先级高低排序
对每一个进程制定一个优先级
按优先级的高低排序——每一个新产生的请求按对应进程的优先级高低插入到队列的相应位置。
（3）针对设备特性的调度策略
调度目标：当有大量的I/O请求时，降低完成这些I/O服务的总时间
移臂调度：最短寻道时间优先算法（SSTF）、扫描算法（SCAN）
旋转调度

如何确定移动臂磁盘组中磁盘块的物理位置

### 计算机组成原理

### 1.怎么存储数

### 2.什么是补码

### 3.指令，汇编语言，机器码有什么区别和联系



## 编译原理

### 1.C语言是怎么进行编译的

### 2.词法分析和文法分析

https://zhuanlan.zhihu.com/p/31096468

### 3.js预编译原理

### 4.v8引擎是怎么编译js的



## 后端理论

### 1.什么是ioc和aop

### 2.前后端分离中，后端负责了什么

### 3.restful api怎么进行设计





## 常用工具

#### CI&CD

