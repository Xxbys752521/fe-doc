## 电商后台管理

### 技术功能

token验证

cdn加速静态资源

设置开发模式和生产模式

路由懒加载

mixin使用   统一管理表单验证规则

面包屑导航抽离

时间格式转换过滤器

生成树形结构

### 设计问题

#### token怎么做登录验证

![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/25/171103222de1a969~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

前后端完全分离的情况下，Vue项目中实现token验证大致思路如下：

1. 第一次登录的时候，前端调后端的登陆接口，发送用户名和密码
2. 后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token
3. 前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面
4. 前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面
5. 每次调后端接口，都要在请求头中加token
6. 后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401
7. 如果前端拿到状态码为401，就清除token信息并跳转到登录页面
8. 调取登录接口成功，会在回调函数中将token存储到localStorage和vuex中

我把 Token 存在sessionStorage，检查有无 Token ，每次请求在 Axios 请求头上进行携带

#### 怎么进行判断处理

router/index.js文件

```js
//挂载路由导航守卫
router.beforeEach((to, from, next) => {
  if (to.path === '/login') return next();

  const tokenStr = window.sessionStorage.getItem('token')
  if (!tokenStr) return next('/login');
  next();
})
```

main.js文件里面

```js
//拦截器给header写入token
axios.interceptors.request.use(config=>{
  config.headers.Authorization=window.sessionStorage.getItem('token');
  return config;
});

Vue.prototype.$http=axios
```



使用 router.beforeEach 注册一个全局前置守卫，判断用户是否登陆

token有自己的过期时限，并且是在后台实现，前台虚无考虑那么多，具体前台的步骤分为三部

1. 在登陆的时候后台会给一个token码，前台将其存储在cookie，localstroage或者localsession中即可

   请注意需要在tooken的前边拼接字符串'Bearer '+，固定格式

   ```js
    login(){
        axios.post('/user/login',this.user).then((res)=>{
            localStorage.setItem('token',"Bearer "+res.data.res.token)
        })
    }
   
   ```

2. 在router中设置守卫导航

判断token是否存在，如果存在将携带token进行下一簇的操作，如果不存在，则返回登陆

```js
    router.beforeEach((to,from,next)=>{
        if(to.matched.some((route)=>route.meta.Auth)){
            if(localStorage.getItem('token')){
                next()
            }else{
              next({
                 path:'/login',
                    query:{
                     returnURL:to.path
                }
                })
            }
           
     }else{
             next()
        }
    })

```

1. 在axios的请求拦截器中携带tooken进行请求

   **config.headers.Authorization**

   ```
    axios.interceptors.request.use(config=>{
        const token=localStorage.getItem('token')
        // if(token){
            token?config.headers.Authorization=token:null;
        // }
        return config
    })
   ```

每次请求时都会携带token，后台验证不验证token就是后台的问题了

设置token的回复拦截器，对回执码错误的进行操作处理

```js
    axios.interceptors.response.use(res=>{
        if(res.data.res_code=== 401){
            router.replace('/login');
            localStorage.removeItem('token')
        }
        return res
    })
```

token的基本原理

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b5e67305f84e9391de2d5b436600e7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

access token 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活

refresh token 用来获取 access token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 session 一样处理

#### Acesss Token

- **访问资源接口（API）时所需要的资源凭证**
- **简单 token 的组成：** uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）
- 特点：
  - **服务端无状态化、可扩展性好**
  - **支持移动端设备**
  - 安全
  - 支持跨程序调用
- **token 的身份验证流程：**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d9c745f~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token
6. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据

- **每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里**
- **基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库**
- **token 完全由应用管理，所以它可以避开同源策略**

#### Refresh Token

- 另外一种 token——refresh token
- refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d1c887b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



- Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。
- Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。

Session 是一种**记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息**。而 Token 是**令牌**，**访问资源接口（API）时所需要的资源凭证**。Token **使服务端无状态化，不会存储会话信息。**

Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。**

所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：**如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。**

#### Token 和 JWT 的区别  

**相同：**

- 都是访问资源的令牌
- 都可以记录用户的信息
- 都是使服务端无状态化
- 都是只有验证成功后，客户端才能访问服务端上受保护的资源

**区别：**

- Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
- JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。



### 优化问题

#### 细节处理

* 打包是 console的处理:  babel-plugin-transform-remove-console

  * plugins: [ "transform-remove-console"  ]

* 生成打包报告

  1. vue-cli-service build --report
  2. UI面版

#### cdn怎么引入的

* **通过 externals 加载外部 CDN 资源**

  vue.config.js 里  在生产模式     config.set(externals{键值对}) 在生产模式 

  index.html里面在设置cdn链接

  

  * 默认情况下，通过 import 语法导入的第三方依赖包，最终会被打包合并到同一个文件中，从而导致打包成功后，单文件体积过大的问题。

  * 为了解决上述问题，可以通过 webpack 的 externals 节点，来配置并加载外部的 CDN 资源。凡是声明在externals 中的第三方依赖包，都不会被打包。

  * 开发时直接下载引用
    * 发布时把直接引入可以省的包 使用window全局的方式来查找  也就是说 CDN 挂载 通过CDN挂载的方式进行引用
    
    通过执行npm run preview – --report来分析webpack打包之后的结果，观察各个静态资源的大小。可以发现占用空间最多的是第三方依赖。如vue、element-ui、 ECharts等。
    
    你可以使用 CDN 外链的方式引入这些第三方库，**这样能大大增加构建的速度(通过 CDN 引入的资源不会经 webpack 打包)。如果你的项目没有自己的CDN服务的话，使用一些第三方的CDN服务**，如 unpkg 等是一个很好的选择，它提供过了免费的资源加速，**同时提供了缓存优化**，由于你的第三方资源是在html中通过script引入的，它的缓存更新策略都是你自己手动来控制的，省去了你需要优化缓存策略功夫。

  **cdn缓存优化**

  如果没有使用cdn

  1. 用户在浏览器中输入要访问的域名。
  2. 浏览器向DNS服务器请求对该域名的解析。
  3. DNS服务器返回该域名的IP地址给浏览器。
  4. 浏览器使用该IP地址向服务器请求内容。
  5. 服务器将用户请求的内容返回给浏览器。

  如果使用了cdn

  1. 用户在浏览器中输入要访问的域名。
  2. 浏览器向DNS服务器请求对域名进行解析。由于CDN对域名解析进行了调整，**DNS服务器会最终将域名的解析权交给CNAME**指向的CDN专用DNS服务器。
  3. **CDN的DNS服务器**将**CDN的负载均衡设备IP地址**返回给用户。
  4. 用户向CDN的负载均衡设备发起内容URL访问请求。
  5. **CDN负载均衡设备**会为用户选择一台合适的缓存服务器提供服务。
     选择的依据包括：
     根据用户IP地址，判断哪一台服务器**距离用户最近**；
     根据用户所请求的URL中携带的内容名称，**判断哪一台服务器上有用户所需内容**；
     查询各个服务器的负载情况，**判断哪一台服务器的负载较小**。
     基于以上这些依据的综合分析之后，**负载均衡设置会把缓存服务器的IP地址返回给用户**。
  6. 用户向缓存服务器发出请求。
  7. 缓存服务器响应用户请求，将用户所需内容传送到用户。
     如果这台缓存服务器上并没有用户想要的内容，而负载均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉取到本地。

  使用CDN服务的网站，只需将其域名的解析权交给CDN的负载均衡设备，CDN负载均衡设备将为用户选择一台合适的缓存服务器，用户通过访问这台缓存服务器来获取自己所需的数据。
  由于**缓存服务器部署在网络运营商的机房**，而这些**运营商又是用户的网络服务提供商**，因此用户可以**以最短的路径，最快的速度对网站进行访问**。因此，CDN可以加速用户访问速度，减少源站中心负载压力。

* 路由来加载

  ```
  // 分组名生成文件
  const Login = () => import(/* webpackChunkName: "login_home_welome" */ 'components/login/Login')
  const Home = () => import(/* webpackChunkName: "login_home_welome" */ 'components/home/Home')
  const Welcome = () => import(/* webpackChunkName: "login_home_welome" */ 'components/home/welcome/Welcome')
  
  const Users = () => import(/* webpackChunkName: "Users_Rights_Roles" */ 'components/home/users/Users')
  const Rights = () => import(/* webpackChunkName: "Users_Rights_Roles" */ 'components/home/power/rights/Rights')
  const Roles = () => import(/* webpackChunkName: "Users_Rights_Roles" */ 'components/home/power/roles/Roles')
  
  const Cate = () => import(/* webpackChunkName: "Cate_Params" */ 'components/home/goods/cate/Cate')
  const Params = () => import(/* webpackChunkName: "Cate_Params" */ 'components/home/goods/params/Params')
  
  const GoodsList = () => import(/* webpackChunkName: "GoodsList_Add" */ 'components/home/goods/list/List')
  const Add = () => import(/* webpackChunkName: "GoodsList_Add" */ 'components/home/goods/list/children/Add')
  
  const Order = () => import(/* webpackChunkName: "Order_Report" */ 'components/home/order/Order')
  const Report = () => import(/* webpackChunkName: "Order_Report" */ 'components/home/report/Report')
  // 独立生成一个文件
  const Login = () => import('components/login/Login')
  const Home = () => import('components/home/Home')
  const Welcome = () => import('components/home/welcome/Welcome')
  
  const Users = () => import('components/home/users/Users')
  const Rights = () => import('components/home/power/rights/Rights')
  const Roles = () => import('components/home/power/roles/Roles')
  
  const Cate = () => import('components/home/goods/cate/Cate')
  const Params = () => import('components/home/goods/params/Params')
  
  const GoodsList = () => import('components/home/goods/list/List')
  const Add = () => import('components/home/goods/list/children/Add')
  
  const Order = () => import('components/home/order/Order')
  const Report = () => import('components/home/report/Report')
  
  ```

#### cdn原理

CDN (全称 Content Delivery Network)，即内容分发网络

构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。`CDN` 的关键技术主要有内容存储和分发技术

简单来讲，`CDN`就是根据用户位置分配最近的资源

于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**，其实就是缓存了源站内容的代理服务器。

在没有应用`CDN`时，我们使用域名访问某一个站点时的路径为

> 用户提交域名→浏览器对域名进行解释→`DNS` 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复

应用`CDN`后，`DNS` 返回的不再是 `IP` 地址，而是一个`CNAME`(Canonical Name ) 别名记录，指向`CDN`的全局负载均衡

`CNAME`实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是`CDN`实现的关键

由于没有返回`IP`地址，于是本地`DNS`会向负载均衡系统再发送请求 ，则进入到`CDN`的全局负载均衡系统进行智能调度：

- 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点
- 看用户所在的运营商网络，找相同网络的边缘节点
- 检查边缘节点的负载情况，找负载较轻的节点
- 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等

结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问`CDN`的缓存代理

### 怎么设置生产模式

process.env.NODE_ENV===productions

设置打包入口

在vue.config.js中设置 configureWebpack 节点  以操作对象 来定义webpack的打包配置

chainwebpack   根据process.env.NODE_ENV  来 设置打包入口  

开发模式的入口文件为 main.-dev.js

发布生成模式入口文件 main-prod.js

```js
module.exports = {
	chainWebpack: config => {
		// 发布模式
		config.when(process.env.NODE_ENV === 'production', config => {
			config
				.entry('app')
				.clear()
				.add('./src/main-prod.js')

			config.set('externals', {
				vue: 'Vue',
				'vue-router': 'VueRouter',
				axios: 'axios',
				echarts: 'echarts',
				'vue-quill-editor': 'VueQuillEditor'
			})

			config.plugin('html').tap(args => {
				args[0].isProd = true
				return args
			})
		})

		// 开发模式
		config.when(process.env.NODE_ENV === 'development', config => {
			config
				.entry('app')
				.clear()
				.add('./src/main-dev.js')

			config.plugin('html').tap(args => {
				args[0].isProd = false
				return args
			})
		})
	}
}
```



### 路由懒加载

Vue的特点是SPA - **Single Page Application**（单页面应用程序）。

像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后，一般情况下，会放在一个单独的js文件中。但是，如果很多的页面都放在同一个js文件中，必然会造成这个页面非常大，造成进入首页时，需要加载的内容过多，时间过长，会出现长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。

路由懒加载有着诸如：“只有第一次会加载页面，以后的每次页面切换，只需要进行组件替换。减少了请求体积，加快页面的响应速度，降低了对服务器的压力”等等优点。

为了解决上面的问题，我们需要对Vue实现组件懒加载（按需加载）。

#### 为什么要进行路由懒加载

1.当进行打包构建应用时，打包后的代码逻辑实现包可能会非常大。 

2.当我们把不同的路由对应的组件分别打包，在路由被访问时再进行加载，就会更加高效。 

#### 路由懒加载所做的事情

1.将路由对应的组件加载成一个个对应的js包 。
2.路由被访问时才将对应的组件加载。

#### 理解基本原理

webpack打包的时候，碰到import()这种函数，就会把里面对应的文件单独打包成js，然后通过script异步加载这个js，这样就实现了异步懒加载   异步加载利用了promise 和定时器    在需要的时候异步再去加载

**要实现懒加载，就得先将进行懒加载的子模块（子组件）分离出来。**

**懒加载实现的前提：ES6的动态加载模块 - import（）**

```
调用import（）之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。
```

1：import 是解构过程并且是编译时执行
2：require 是赋值过程并且是运行时才执行，也就是异步加载
3：require的性能相对于import稍低，因为require是在运行时才引入模块并且还赋值给某个变量

##### 在html中

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/1/172705177cb52ad6~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

从上面我们可以看到，先用link定义Home.js、app.js、chunk-vendors.js这些资源和web客户端的关系。

- `ref=preload`：告诉浏览器这个资源要给我提前加载。
- `rel=prefetch`：告诉浏览器这个资源空闲的时候给我加载一下。
- `as=script`：告诉浏览器这个资源是script，提升加载的优先级。

然后在body里面加载了chunk-vendors.js、app.js这两个js资源。可以看出web客户端初始化时候就加载了这个两个js资源。

##### 分析chunk-vendors.js

chunk-vendors.js可以称为项目公共模块集合，代码精简后如下所示，

```js
(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["chunk-vendors"],{
    "01f9":(function(module,exports,__webpack_require__){
        ...//省略
    })
    ...//省略
}])
```

从代码中可以看出，执行chunk-vendors.js，仅仅把下面这个数组`push`到`window["webpackJsonp"]`中，而数组第二项是个对象，对象的每个value值是一个函数表达式，不会执行。就这样结束了，当然不是，我们带着`window["webpackJsonp"]`去app.js中找找。

##### 分析app.js

app.js可以称为项目的入口文件。

app.js里面是一个自执行函数，通过搜索`window["webpackJsonp"]`可以找到如下相关代码。

```js
(function(modules){
    //省略...
    var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
    var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
    jsonpArray.push = webpackJsonpCallback;
    jsonpArray = jsonpArray.slice();
    for (var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
    var parentJsonpFunction = oldJsonpFunction;
    //省略...
}({
    0:(function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__("56d7");
    })
    //省略...
}))
```

- 先把`window["webpackJsonp"]`赋值给`jsonpArray`。
- 把`jsonpArray`的`push`方法赋值给`oldJsonpFunction`。
- 用`webpackJsonpCallback`函数拦截`jsopArray`的`push`方法，也就是说调用`window["webpackJsonp"]`的`push`方法都会执行`webpackJsonpCallback`函数。
- 将`jsonpArray`浅拷贝一下再赋值给`jsonpArray`。
- 因为执行chunk-vendors.js中的`window["webpackJsonp"].push`时`push`方法还未被`webpackJsonpCallback`函数拦截，所以要循环`jsonpArray`，将每项作为参数传入`webpackJsonpCallback`函数并调用。
- 将`jsonpArray`的`push`方法再赋值给`parentJsonpFunction`。

##### webpackJsonpCallback函数

```js
(function(modules){
    function webpackJsonpCallback(data) {
        var chunkIds = data[0];
        var moreModules = data[1];
        var executeModules = data[2];
        var moduleId, chunkId, i = 0, resolves = [];
        for (; i < chunkIds.length; i++) {
            chunkId = chunkIds[i];
            if (Object.prototype.hasOwnProperty.call(installedChunks, chunkId)
            && installedChunks[chunkId]) {
                resolves.push(installedChunks[chunkId][0]);
            }
            installedChunks[chunkId] = 0;
        }
        for (moduleId in moreModules) {
            if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
                modules[moduleId] = moreModules[moduleId];
            }
        }
        if (parentJsonpFunction) parentJsonpFunction(data);
        while (resolves.length) {
            resolves.shift()();
        }
        deferredModules.push.apply(deferredModules, executeModules || []);
        return checkDeferredModules();
    };
    var installedChunks = {
        "app": 0
    };
    //省略...
}({
    0:(function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__("56d7");
    })
    //省略...
}))

```

- module是指任意的代码块，chunk是webpack处理过程中被分组的module的合集。
- `modules`缓存所有的module（代码块），调用`modules`中的module就可以执行里面的代码。
- `installedChunks`缓存所有chunk的加载状态，如果`installedChunks[chunk]`为0，代表chunk已经加载完毕。
- `deferredModules`中每项也是一个数组，例如`[module,chunk1,chunk2,chunk3]`,其作用是如果要执行module，必须在chunk1、chunk2、chunk3都加载完毕后才能执行。

`if (parentJsonpFunction) parentJsonpFunction(data)`这句代码在多入口项目中才有作用，在前面提到过`jsonpArray`的`push`方法被赋值给`parentJsonpFunction`，调用`parentJsonpFunction`是真正把chunk中push方法中的参数push到`window["webpackJsonp"]`这个数组中。

##### checkDeferredModules函数

```js
var deferredModules = [];
var installedChunks = {
    "app": 0
}
function checkDeferredModules() {
    var result;
    for (var i = 0; i < deferredModules.length; i++) {
        var deferredModule = deferredModules[i];
        var fulfilled = true;
        for (var j = 1; j < deferredModule.length; j++) {
            var depId = deferredModule[j];
            if (installedChunks[depId] !== 0) fulfilled = false;
        }
        if (fulfilled) {
            deferredModules.splice(i--, 1);
            result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
        }
    }
    return result;
}

```

- 循环`deferredModules`，创建变量`fulfilled`表示`deferredModule`中的chunk加载情况，`true`表示全部加载完毕，`false`表示未全部加载完毕。
- 从`j=1`开始循环`deferredModule`中的chunk，因为`deferredModule[0]`是module，如果`installedChunks[chunk]!==0`，则这个chunk未加载完毕，把变量`fulfilled`设置为`false`。循环结束后返回result。
- 经循环`deferredModule`中的chunk并判断chunk的加载状态后，`fulfilled`还是为true，则调用`__webpack_require__`函数，将`deferredModule[0]`（module）作为参数传入执行。
- `deferredModules.splice(i--, 1)`,删除满足条件的deferredModule，并将i减一，其中`i--`是先使用i，然后在减一。

因为在`webpackJsonpCallback`函数中`deferredModules`为`[]`，所以回到主体函数继续往下看。

```
deferredModules.push([0, "chunk-vendors"]);
return checkDeferredModules();
复制代码
```

按上面逻辑分析后，会执行`__webpack_require__(0)`,那么来看一下`__webpack_require__`这个函数。

##### __webpack_require__函数

```js
var installedModules = {};
function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
        return installedModules[moduleId].exports;
    }
    var module = installedModules[moduleId] = {
        i: moduleId,
        l: false,
        exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.l = true;
    return module.exports;
}

```

从代码可知`__webpack_require__`就是一个执行module的方法。

- `installedModules`用来缓存module的执行状态。
- 通过moduleId在modules（在`webpackJsonpCallback`函数中缓存所有module的集合）获取对应的module用call方法执行。
- 将执行结果赋值到module.exports并返回。

**`__webpack_require__.e`方法是实现懒加载的核心**，在这个方法里面处理了三件事情。

- 使用JSONP模式加载路由对应的js文件，也可以称为chunk。
- 设置chunk加载的三种状态并缓存在`installedChunks`中，防止chunk重复加载。
- 处理chunk加载超时和加载出错的场景。

chunk加载的三种状态

- `installedChunks[chunkId]`为`0`，代表该chunk已经加载完毕。
- `installedChunks[chunkId]`为`undefined`，代表该chunk加载失败、加载超时、从未加载过。
- `installedChunks[chunkId]`为`Promise`对象，代表该chunk正在加载。

### mixin的使用

#### mixin基本特点

Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件

**1、方法和参数在各组件中不共享**

如混入对象中有一个 cont:1的变量,在组件A中改变cont值为5，这时候在组件B中获取这个值，拿到的还是1，还是混入对象里的初始值，数据不共享

**2、值为对象的选项**

如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的，比如混入对象里有个方法A，组件里也有方法A，这时候在组件里调用的话，执行的是组件里的A方法

**3、值为函数的选项**

如created,mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用，同一个钩子函数里，会先执行混入对象的东西，再执行本组件的

**4、与vuex的区别**

vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。

Mixins：可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。

**5、与公共组件的区别**

组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。

#### 对表单规则的使用mixin

导出不同的表单规则对象  

验证手机号和邮箱对象中设置data函数  可以进行正则的验证   返回添加表单的验证规则   和修改表单的规则

验证其他表单直接可以在data函数中 可以直接返回 表单的验证规则对象

```js
export const userAddFormRulesMixin = {
	data() {
		// 验证邮箱的规则
		var checkEmail = (rule, value, callback) => {
			const regEmail = /^\w+@\w+(\.\w+)+$/ // 验证邮箱的正则表达式
			if (regEmail.test(value)) {
				return callback() // 合法邮箱
			}
			// 返回一个错误提示
			callback(new Error('请输入合法的邮箱'))
		}
		// 验证手机的规则
		var checkMobeli = (rule, value, callback) => {
			const regMobile = /^1[34578]\d{9}$/
			if (regMobile.test(value)) {
				return callback()
			}
			// 返回一个错误提示
			callback(new Error('请输入合法的手机号码'))
		}
		return {
			// 添加表单的验证规则对象
			addFormRules: {
				username: [
					{ required: true, message: '请输入登录名称', trigger: 'blur' },
					{ min: 3, max: 10, message: '长度在 3 到 10 个字符', trigger: 'blur' }
				],
				password: [
					{ required: true, message: '请输入密码', trigger: 'blur' },
					{
						min: 6,
						max: 15,
						message: '用户名长度在 6 到 15 个字符',
						trigger: 'blur'
					}
				],
				email: [
					{ required: true, message: '请输入邮箱', trigger: 'blur' },
					{ validator: checkEmail, trigger: 'blur' }
				],
				mobile: [
					{ required: true, message: '请输入手机', trigger: 'blur' },
					{ validator: checkMobeli, trigger: 'blur' }
				]
			},
			// 修改用户数据验证规则
			editFormRules: {
				email: [
					{ required: true, message: '请输入用户邮箱', trigger: 'blur' },
					{ validator: checkEmail, trigger: 'blur' }
				],
				mobile: [
					{ required: true, message: '请输入用户手机', trigger: 'blur' },
					{ validator: checkMobeli, trigger: 'blur' }
				]
			}
		}
	}
}
export const rolesFormRulesMixin = {
	data() {
		return {
			addFormRules: {
				roleName: [
					{ required: true, message: '请输入角色名字', trigger: 'blur' },
					{
						min: 3,
						max: 10,
						message: '输入的范围是 3 ~ 10 为字符',
						triggetr: 'nlur'
					}
				],
				roleDesc: [
					{ required: true, message: '请输入角色描述', trigger: 'blur' },
					{
						min: 5,
						max: 20,
						message: '输入的范围是 5 ~ 20 为字符',
						triggetr: 'nlur'
					}
				]
			},
			editFormRules: {
				roleName: [
					{ required: true, message: '请输入角色名字', trigger: 'blur' },
					{
						min: 3,
						max: 10,
						message: '输入的范围是 3 ~ 10 为字符',
						triggetr: 'nlur'
					}
				],
				roleDesc: [
					{ required: true, message: '请输入角色描述', trigger: 'blur' },
					{
						min: 5,
						max: 20,
						message: '输入的范围是 5 ~ 20 为字符',
						triggetr: 'nlur'
					}
				]
			}
		}
	}
}
export const paramsFormRulesMixin = {
	data() {
		return {
			// 添加表单的验证规则
			addFormRules: {
				attr_name: [
					{ required: true, message: '请输入添加的分类', trigger: 'blur' },
					{ min: 2, max: 10, message: '长度在 2 到 10 个字符', trigger: 'blur' }
				]
			},
			// 修改表单的验证
			editFormRules: {
				attr_name: [
					{ required: true, message: '请输入修改的信息', trigger: 'blur' },
					{ min: 2, max: 10, message: '长度在 2 到 10 个字符', trigger: 'blur' }
				]
			}
		}
	}
}
export const goodsAddFormRulesMixin = {
	data() {
		return {
			// 添加商品验证规则
			addFormRules: {
				goods_name: [
					{ required: true, message: '请输入商品的名称', trigger: 'blur' },
					{
						min: 2,
						max: 30,
						message: '请输入 2 ~ 30 范围的字符',
						trigger: 'blur'
					}
				],
				goods_price: [{ required: true, message: '请输入商品的价格', trigger: 'blur' }],
				goods_weight: [{ required: true, message: '请输入商品的重量', trigger: 'blur' }],
				goods_number: [{ required: true, message: '请输入商品的数量', trigger: 'blur' }],
				goods_cat: [{ required: true, message: '请选择商品分类', trigger: 'blur' }]
			}
		}
	}
}
```

在需要的组建里面使用

mxins:[导出的表单验证对象名]

给form设置一个ref  再通过this.$refs.refname.validate  来进行表单预校验

### 面包屑导航组件抽离

考虑到每个页面都有面包屑导航   每个页面代码有高度重复性    所以想办法抽离出来各个   只需要传入配置信息 面包屑导航的名字就行了 

设置一个公共组件   通过props来接受其他组件传递过来的导航名

```vue
<template>
  <div>
    <!-- 面包屑导航区域 -->
    <el-breadcrumb separator-class="el-icon-arrow-right">
      <el-breadcrumb-item :to="{ path: '/home' }">首页</el-breadcrumb-item>
      <el-breadcrumb-item>{{ name1 }}</el-breadcrumb-item>
      <el-breadcrumb-item>{{ name2 }}</el-breadcrumb-item>
    </el-breadcrumb>
  </div>
</template>

<script>
export default {
  name: 'Breadcrumb',
  props: {
    name1: String,
    name2: String
  }
}
</script>

<style lang="less" scoped></style>
```

在每个组件中设置

```vue
components:{
Breadcrumb
}
```



设置统一的提示和对话框

Vue.prototype.$message = Message;

Vue.prototype.$confirm = MessageBox.confirm;

### 时间格式过滤器

```js
Vue.filter('dataFormat',function(originVal){
  const dt = new Date(originVal * 1000);//这里的问题是 要给时间戳乘以1000  如果不是10位时间戳的话（不包含毫秒） 要把10位时间戳*1000

const y=dt.getFullYear();
const m=(dt.getMonth()+1+'').padStart(2,'0');
const d = (dt.getDate() + '').padStart(2, '0');
const hh = (dt.getHours() + '').padStart(2, '0');
const mm = (dt.getMinutes() + '').padStart(2, '0');
const ss = (dt.getSeconds() + '').padStart(2, '0');
  return `${y}-${m}-${d} ${hh}:${mm}:${ss}`
})
```

### 生成树形结构

```vue
<!-- 分配权限的对话框 -->
    <el-dialog title="分配权限" :visible.sync="SetRightDialogVisible" width="50%" @close="SetRightDialogVisibleClosed">
      <!-- 树形控件 -->
      <el-tree :data="rightsList" :props="treeProps" show-checkbox node-key="id" :default-expand-all="true" :default-checked-keys="defKeys" ref="treeRef"></el-tree>
      <span slot="footer" class="dialog-footer">
        <el-button @click="SetRightDialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="allotRights">确 定</el-button>
      </span>
    </el-dialog>
```

```js
// 树形控件的绑定对象
      treeProps: {
        children: 'children',
        label: 'authName'
      },
      // 树形控件 -> 默认选中的节点id值数组
      defKeys: [],
      // 当前即将分配权限的角色的ID
      rolesId: ''


// 展示分配权限的对话框
    async showSetRightDialog(roles) {
      this.rolesId = roles.id
      // 获取所有权限列表
      const { data: res } = await this.$http.get('rights/tree')
      if (res.meta.status !== 200) {
        return this.$message.error('获取权限列表失败!')
      }
      // 获取到的权限数据保存
      this.rightsList = res.data
      console.log(this.rightsList)
      // 递归获取三级节点
      this.getLeafKeys(roles, this.defKeys)
      this.SetRightDialogVisible = true
    },
    // 递归的形式,获取角色下所有的三级权限的id,并保存到 defKeys数组中
    getLeafKeys(node, arr) {
      // 如果当前node没有children属性则是三级节点
      if (!node.children) {
        return arr.push(node.id)
      }
      node.children.forEach(item => this.getLeafKeys(item, arr))
    },
    // 监听分配权限对话框的关闭事件
    SetRightDialogVisibleClosed() {
      // 清空 defkeys 数组  避免累积
      this.defKeys = []
    },
    // 点击为角色分配权限
    async allotRights() {
      const keys = [...this.$refs.treeRef.getCheckedKeys(), ...this.$refs.treeRef.getHalfCheckedKeys()]
      const idStr = keys.join(',')
      const { data: res } = await this.$http.post(`roles/${this.rolesId}/rights`, { rids: idStr })
      if (res.meta.status !== 200) {
        return this.$message.error('分配权限失败!')
      }
      this.$message.success('分配权限成功!')
      this.getRolesList()
      this.SetRightDialogVisible = false
    }
```



## 内容管理系统

### typescript和javascript的区别

TypeScript简称TS，JavaScript的超集，就是在JavaScript的基础上做一层封装，封装出TS的特性，最终可以编译为JavaScript

TS最初是为了让习惯编写强类型语言的后端程序员能快速编写web应用，因为 JavaScript 没有强数据类型，所以 TypeScript 提供了静态数据类型，这是 TypeScript 的核心

#### Typescript的优势在哪

##### 静态类型

静态类型化是一种功能，可以在开发人员编写脚本是检测错误，有了这项功能，就会允许开发人员编写更健壮的代码并对其进行维护，以便使得代码质量更好、更清晰。

函数fun接受两个类型的number的参数，传入非number的参数报错

TypeScript能使用JavaScript 中的所有代码和编码概念

TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展

JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript

TypeScript 通过类型注解提供编译时的静态类型检查

TypeScript 中的数据要求带有明确的类型，JavaScript不要求

TypeScript 为函数提供了缺省参数值

TypeScript 引入了 JavaScript 中没有的“类”概念

TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中

### interface和type的区别

#### 相同点

### 都可以描述一个对象或者函数

#### interface

```
interface User {
  name: string
  age: number
}

interface SetUser {
  (name: string, age: number): void;
}
```

#### type

```
type User = {
  name: string
  age: number
};

type SetUser = (name: string, age: number)=> void;
```

### 都允许拓展（extends）

interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 **虽然效果差不多，但是两者语法不同**。

#### interface extends interface

```
interface Name { 
  name: string; 
}
interface User extends Name { 
  age: number; 
}
```

#### type extends type

```
type Name = { 
  name: string; 
}
type User = Name & { age: number  };
```

#### interface extends type

```
type Name = { 
  name: string; 
}
interface User extends Name { 
  age: number; 
}
```

#### type extends interface

```js
interface Name { 
  name: string; 
}
type User = Name & { 
  age: number; 
}

```

### 不同点

#### type 可以而 interface 不行

- type 可以声明基本类型别名，联合类型，元组等类型

```
// 基本类型别名
type Name = string

// 联合类型
interface Dog {
    wong();
}
interface Cat {
    miao();
}

type Pet = Dog | Cat

// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]

```

- type 语句中还可以使用 typeof 获取实例的 类型进行赋值

```
// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement('div');
type B = typeof div
```

- 其他骚操作

```
type StringOrNumber = string | number;  
type Text = string | { text: string };  
type NameLookup = Dictionary<string, Person>;  
type Callback<T> = (data: T) => void;  
type Pair<T> = [T, T];  
type Coordinates = Pair<number>;  
type Tree<T> = T | { left: Tree<T>, right: Tree<T> };
```

#### interface 可以而 type 不行

interface 能够声明合并

```
interface User {
  name: string
  age: number
}

interface User {
  sex: string
}

/*
User 接口为 {
  name: string
  age: number
  sex: string 
}
*/
```



### 基本功能

#### 登录的逻辑业务

localStorage 的封装

```typescript
class LocalCache {
  setCache(key: string, value: any) {
    window.localStorage.setItem(key, JSON.stringify(value));
  }
  getCache(key: string) {
    const value = window.localStorage.getItem(key);
    if (value) {
      return JSON.parse(value);
    }
  }
  deleteCache(key: string) {
    window.localStorage.removeItem(key);
  }
  clearCache() {
    window.localStorage.clear();
  }
}

export default new LocalCache();
```

对网络请求的数据用 Vuex 分模块进行存储，同时需要在本地缓存一份，因为有时已经登陆，在其他页面点击刷新按钮，vuex 内的数据是在内存里面的，那么刷新后数据就会消失，此时就可以从本地的缓存的数据进行重新加载。

登陆的逻辑步骤：

1、将账号密码进行验证，返回结果
2、获取用户的基本信息
3、获取主页的信息。(因为是管理系统，那么不同角色的主页面是不一致的)
4、数据的保存
5、页面跳转

如果同时在 login 组件内进行如此多的步骤，有些步骤是和本组件的关系是不相关的，其实这部分逻辑可以在 vuex 的 action 内进行。

```typescript
import { Module } from "vuex";
import router from "@/router";

import {
  accountLoginRequest,
  userInfoRequest,
  userMenuRequest,
} from "@/service/login";
import { AccountLoginType } from "@/service/login/types";
import localCache from "@/utils/cache";

import { RootStateType } from "../types";
import { LoginStateType } from "./types";

const loginModule: Module<LoginStateType, RootStateType> = {
  namespaced: true,
  state() {
    return {
      token: "",
      userInfo: {},
      userMenus: [],
    };
  },
  getters: {},
  mutations: {
    changeToken(state, token: string) {
      state.token = token;
    },
    changeUserInfo(state, payload: any) {
      state.userInfo = payload;
    },
    changeUserMenus(state, payload: any) {
      state.userMenus = payload;
    },
  },
  actions: {
    async accountLoginAction(context, payload: AccountLoginType) {
      // 登陆信息
      const loginResult = await accountLoginRequest(payload);
      const { id, token } = loginResult.data;
      context.commit("changeToken", token);
      localCache.setCache("token", token);
      // 登陆后用户信息
      const userInfoResult = await userInfoRequest(id);
      context.commit("changeUserInfo", userInfoResult.data);
      localCache.setCache("userInfo", userInfoResult.data);
      //请求用户菜单
      const userMenuResult = await userMenuRequest(id);
      context.commit("changeUserMenus", userMenuResult.data);
      localCache.setCache("userMenus", userMenuResult.data);
      // 路由跳转
      router.push("/main");
    },
    uploadAction(context) {
      // 刷新时直接从本地获取
      const token = localCache.getCache("token");
      if (token) {
        context.commit("changeToken", token);
      }
      const userInfo = localCache.getCache("userInfo");
      if (userInfo) {
        context.commit("changeUserInfo", userInfo);
      }
      const userMenus = localCache.getCache("userMenus");
      if (userMenus) {
        context.commit("changeUserMenus", userMenus);
      }
    },
  },
};

export default loginModule;
```

### 遇到的问题

#### 主页面刷新问题

保存在vuex中的 token userinfo  usermenu   会在用户刷新之后 消失

localstorage里面还有   这表明是登录状态  vuex里面没有加载数据

在vuex的index.ts里面设置一个setupStore

然后 再maints里面使用这个setupstore

```js
export function setupStore() {
  store.dispatch('login/loadLocalLogin')
}
```



刷新就会直接跳转到notfound页面

setupstore和use(router)的顺序问题

在router的导航守卫

进行页面跳转之前，通过getRoutes打印路径信息  得到数组  由路径匹配路由

再打印to  输出即将跳转到的对象   path正常  但是匹配到的name没找到而是not found

在main.ts中   app.use(router)   刷新后  页面程序加载  会重新执行ts文件

执行app.use(router)  注册路由     执行install函数   获取当前的path   

获取完成之后立马会去匹配路径   当前没有我们动态注册的路径  就匹配到not found      路由守卫是回调函数   

执行setupstore    里面已经注册了动态路由  routes已经确定了

执行路由守卫     但是在上一步已经把to匹配好了  确定是notfound

解决方法是把setupstore（）放到app.use(router)前面

在path和路由匹配之前     path ： /user  -> user

setupstore()

#### 权限管理

方法一：不管什么角色登陆，在开发的时候，在前端都全部配置好路由的映射关系，只是在展示的时候，对应路由的跳转不展现出来。 引发的问题： 虽然页面没有展示，但是可以通过浏览器的地址栏进行 “套”，就会显示对应映射的组件，但组件上可能是没有什么东西的，虽然这样但也不好，会不安全。

方法二：在前端这里，为不同的角色设置好不同的映射关系（映射数组），请求数据用户的角色是什么，再把该角色的数组加入到 main 对应的 children 内。 引发问题： 若后端又有新的角色出现，那么前端这边也要跟着进行修改，重新进行部署。

方法三：在前端创建好所有路径对应的组件，但是根据后端返回的菜单数据，进行动态的生成路由。后端在返回对应的路径信息时，也要把该路径映射组件的路径一起返回。但是也要后端要增加一个字段，来放置组件的位置。

方法四：在前端创建好所有路径对应的组件，但是根据后端返回的菜单数据，进行动态的生成路由。后端在返回对应的路径信息时，在前端就设置好路径和组件之间的映射关系，在前端根据传过来的路径进行查找，查找到就找到了该路径和组件的映射关系。

菜单动态生成路由映射



### 项目难点



#### 类型确定

```typescript
Exclude<T, U> - 用于从类型T中去除不在U类型中的成员
Extract<T, U> - 用于从类型T中取出可分配给U类型的成员
NonNullable<T> - 用于从类型T中去除undefined和null类型
ReturnType<T> - 获取函数类型的返回类型
InstanceType<T> - 获取构造函数的实例类型
```

ref可以传入一个泛型   写错了可以报错 拼写错误

InstanceType<T>   获取构造函数的实例类型

例如demo.vue 组件在导出时候  组件名只是一个描述  </demo>  是一个组件实例    demo相当于一个类

ref<InstanceType<typeof ElForm>>();

在ref进行绑定组件或这元素的时候，在ts中为了更好的推测，和代码规范，需要具体指明绑定的类型，比如：

```typescript
// element-plus组件
const elFormRef = ref<InstanceType<typeof ElForm>>();
// 自定义组件
let loginUserRef = ref<InstanceType<typeof LoginUser>>();
let loginPhoneRef = ref<InstanceType<typeof LoginPhone>>();
```

组件使用instanceType<typeof .... >:  .vue 文件 export 的对象是组件的描述，是有着具体值的对象，在 template 内使用的是根据组件描述创建的实例，这个组件描述是不能直接作为一个类型的。该语法可以得到具有构造函数的实例对象，这时才可以作为一个类型传入 ref

##### 想对创建出来的store对象进行类型的约束，可以这样做

```typescript
// 模块内的state的类型
import type { LoginStateType } from "./login/types";
// 根模块内的state类型
export interface RootStateType {}
// 定义一个接口，集合展示模块内的类型
interface ModuleType {
  login: LoginStateType;
}
// 导出交叉类型
export type RootWithModule = RootStateType & ModuleType;

```

router/index.ts

```typescript
// 模块内的state的类型
import type { LoginStateType } from "./login/types";
// 根模块内的state类型
export interface RootStateType {}
// 定义一个接口，集合展示模块内的类型
interface ModuleType {
  login: LoginStateType;
}
// 导出交叉类型
export type RootWithModule = RootStateType & ModuleType;

```

知识点补充一：PropType

vue3 为结合 ts ，props 设置自定类型

- 用 vue3 封装组件时，难免需要规定较为复杂的数据类型，用于声明组件接受的参数类型，比如下面这种数据类型接口
- 假设我现在需要指定一个变量 list 的数据类型为 Array，如何规范 Array 的格式呢？
  错误示例：type: Array: ColumnProps[],
  正确示例：type: Array as PropType<ColumnProps[]>,
  原因：此处 Array 并非作为数据类型存在，而是作为 构造函数 存在，为构造函数指定类型，应用  PropType  这个 API

```typescript
import { defineComponent, PropType } from "vue";
// ....代码省略
props: {
  formItem: {
    type: Array as PropType < IFormItemType[] > ,
    default:() = >[]
  }
}
```

知识点补充二：require.context方法

webpack 的函数：根据传入的参数，获取对应文件的相对路径，返回值调用.keys()方法和得到路径的数组。

权限管理：根据传递对来的路径，去匹配对应的 route，设置动态路由

```typescript
import type { RouteRecordRaw } from "vue-router";
export default function (useMenus: any[]): RouteRecordRaw[] {
  const routes: RouteRecordRaw[] = [];
  // 加入全部路由
  const allRoutes: RouteRecordRaw[] = [];
  const routeFiles = require.context("@/router/main", true, /\.ts$/);
  routeFiles.keys().forEach((filePath) => {
    const routeModule = require("@/router/main" + filePath.split(".")[1]);
    allRoutes.push(routeModule.default);
  });
  console.log(useMenus);
  // 递归函数 获取可点击部分的url，并进行筛选
  function findRouteFun(useMenus: any[]) {
    for (const menu of useMenus) {
      if (menu.type === 1) {
        findRouteFun(menu.children);
      } else if (menu.type === 2) {
        const route = allRoutes.find((item) => item.path === menu.url);
        if (route) {
          routes.push(route);
        }
      }
    }
  }
  findRouteFun(useMenus);
  console.log(routes);
  return routes;
}

```

#### Vuex使用

vuex现在对ts的支持性比较差

在store文件夹下 设置不同功能的文件夹

types.ts下    设置接口*IRootState*

createStore的时候可以传入一个泛型

可以对state进行限制

##### index.ts下

```js
import { createStore } from 'vuex'

import login from './login/login'

import { IRootState } from './types'

const store = createStore<IRootState>({
  state() {
    return {
      name: 'coderwhy',
      age: 18
    }
  },
  mutations: {},
  getters: {},
  actions: {},
  modules: {
    login
  }
})

export function setupStore() {
  store.dispatch('login/loadLocalLogin')
}

export default store
```

##### login中

types.ts

```js
export interface ILoginState {
  token: string
  userInfo: any
  userMenus: any
}
```

login.ts

```js
import { Module } from 'vuex'

import {
  accountLoginRequest,
  requestUserInfoById,
  requestUserMenusByRoleId
} from '@/service/login/login'
import localCache from '@/utils/cache'
import router from '@/router'

import { IAccount } from '@/service/login/type'
import { ILoginState } from './types'
import { IRootState } from '../types'
                          //模块类型 和根类型
const loginModule: Module<ILoginState, IRootState> = {
  namespaced: true,
  state() {
    return {
      token: '',
      userInfo: {},
      userMenus: []
    }
  },
  getters: {},
  mutations: {
    changeToken(state, token: string) {
      state.token = token
    },
    changeUserInfo(state, userInfo: any) {
      state.userInfo = userInfo
    },
    changeUserMenus(state, userMenus: any) {
      state.userMenus = userMenus
    }
  },
  actions: {
    async accountLoginAction({ commit }, payload: IAccount) {
      // 1.实现登录逻辑
      const loginResult = await accountLoginRequest(payload)
      const { id, token } = loginResult.data
      commit('changeToken', token)
      localCache.setCache('token', token)

      // 2.请求用户信息
      const userInfoResult = await requestUserInfoById(id)
      const userInfo = userInfoResult.data
      commit('changeUserInfo', userInfo)
      localCache.setCache('userInfo', userInfo)

      // 3.请求用户权限菜单
      const userMenusResult = await requestUserMenusByRoleId(userInfo.role.id)
      const userMenus = userMenusResult.data
      commit('changeUserMenus', userMenus)
      localCache.setCache('userMenus', userMenus)

      // 4.跳到首页
      router.push('/main')
    },
    loadLocalLogin({ commit }) {
      const token = localCache.getCache('token')
      if (token) {
        commit('changeToken', token)
      }
      const userInfo = localCache.getCache('userInfo')
      if (userInfo) {
        commit('changeUserInfo', userInfo)
      }
      const userMenus = localCache.getCache('userMenus')
      if (userMenus) {
        commit('changeUserMenus', userMenus)
      }
    }
  }
}

export default loginModule

```



##### 在service/login中

types.ts中设置接口

````typescript
export interface IAccount {
  name: string
  password: string
}

export interface ILoginResult {
  id: number
  name: string
  token: string
}

export interface IDataType<T = any> {
  code: number
  data: T
}
````

```js
import hyRequest from '../index'

import { IAccount, IDataType, ILoginResult } from './type'

enum LoginAPI {
  AccountLogin = '/login',
  LoginUserInfo = '/users/', // 用法: /users/1
  UserMenus = '/role/' // 用法: role/1/menu
}

export function accountLoginRequest(account: IAccount) {
  return hyRequest.post<IDataType<ILoginResult>>({
    url: LoginAPI.AccountLogin,
    data: account
  })
}

export function requestUserInfoById(id: number) {
  return hyRequest.get<IDataType>({
    url: LoginAPI.LoginUserInfo + id,
    showLoading: false
  })
}

export function requestUserMenusByRoleId(id: number) {
  return hyRequest.get<IDataType>({
    url: LoginAPI.UserMenus + id + '/menu',
    showLoading: false
  })
}
```

模块设置   system   good  login等

##### 模块划分

service里面 system.ts

```js
import hyRequest from '../../index'

import { IDataType } from '../../types'

export function getPageListData(url: string, queryInfo: any) {
  return hyRequest.post<IDataType>({
    url: url,
    data: queryInfo
  })
}

```





```typescript
export interface ISystemState {
  userList: any[]
  userCount: number
}

```



```js
import { Module } from 'vuex'
import { IRootState } from '@/store/types'
import { ISystemState } from './types'

import { getPageListData } from '@/service/main/system/system'

const systemModule: Module<ISystemState, IRootState> = {
  namespaced: true,
  state() {
    return {
      userList: [],
      userCount: 0
    }
  },
  mutations: {
    changeUserList(state, userList: any[]) {
      state.userList = userList
    },
    changeUserCount(state, userCount: number) {
      state.userCount = userCount
    }
  },
  actions: {
    async getPageListAction({ commit }, payload: any) {
      console.log(payload.pageUrl)
      console.log(payload.queryInfo)

      // 1.对页面发送请求
      const pageResult = await getPageListData(
        payload.pageUrl,
        payload.queryInfo
      )
      const { list, totalCount } = pageResult.data
      commit('changeUserList', list)
      commit('changeUserCount', totalCount)
    }
  }
}

export default systemModule
```



#### 组件二次封装

传入配置信息就可以获取一个新的组件

##### form组件的二次封装

###### baseUI下面

设置一个types文件 

指定一个表单项目的接口  接口中设置item类型   

index.ts   总出口文件

```typescript
import MsiForm from "./src/MsiForm.vue";

export * from "./types";
export default MsiForm;
```

types.ts文件

```typescript
type InputType = "input" | "select" | "password" | "datapicker";

export interface IFormItemType {
  type: InputType;
  label: string;
  rules?: any[];
  placeholder?: string;
  options?: any[];
  otherOptions?: any;
}

interface colLayoutType {
  xs?: number;
  sm?: number;
  md?: number;
  lg?: number;
  xl?: number;
}
export interface IForm {
  formItem: IFormItemType[];
  labelWidth?: string;
  itemStyle?: any;
  colLayout?: colLayoutType;
}
```

hyForm.vue组件

template进行v-if  选择那种类型进行展示

````typescript
<template>
  <div class="msi-form">
    <el-form :label-width="labelWidth">
      <el-row>
        <template v-for="item in formItem" :key="item.label">
          <el-col :="colLayout">
            <el-form-item :label="item.label" :style="itemStyle">
              <template v-if="item.type === 'input'">
                <el-input
                  :placeholder="item.placeholder"
                  v-bind="item.otherOptions"
              /></template>
              <template v-else-if="item.type === 'password'">
                <el-input
                  show-password
                  :placeholder="item.placeholder"
                  v-bind="item.otherOptions"
              /></template>
              <template v-else-if="item.type === 'select'">
                <el-select
                  v-bind="item.otherOptions"
                  :placeholder="
                    item.placeholder ? item.placeholder : '请选择..'
                  "
                >
                  <el-option
                    v-for="option in item.options"
                    :key="option.value"
                    :value="option.value"
                    >{{ option.title }}</el-option
                  >
                </el-select>
              </template>
              <template v-else-if="item.type === 'datapicker'">
                <el-date-picker v-bind="item.otherOptions"
              /></template>
            </el-form-item>
          </el-col>
        </template>
      </el-row>
    </el-form>
  </div>
</template>

<script lang="ts">
import { defineComponent, PropType } from "vue";
import type { IFormItemType } from "../types";

export default defineComponent({
  name: "index",
  props: {
    formItem: {
      type: Array as PropType<IFormItemType[]>,
      default: () => []
    },
    labelWidth: {
      type: String,
      default: "80px"
    },
    itemStyle: {
      type: Object,
      default: () => ({ padding: "10px 20px" })
    },
    colLayout: {
      type: Object,
      default: () => ({
        xs: 24,
        sm: 24,
        md: 12,
        lg: 8,
        xl: 6
      })
    }
  },
  setup() {
    return {};
  }
});
</script>

<style lang="less" scoped>
.msi-form {
  padding-top: 20px;
  width: 100%;
  background-color: #fff;
  border-radius: 10px;
}
</style>
````

###### 使用配置方法

导入baseui里面的form组件

再导入相关配置文件  给form组件绑定 配置信息

```vue
<template>
  <div class="user">
    <hy-form v-bind="searchFormConfig" />
    <div class="content"></div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import HyForm from '@/base-ui/form'

import { searchFormConfig } from './config/search.config'

export default defineComponent({
  name: 'user',
  components: {
    HyForm
  },
  setup() {
    return {
      searchFormConfig
    }
  }
})
</script>

<style scoped></style>
```

配置信息

设置type  label  width height等组件信息

```js
import { IForm } from '@/base-ui/form'

export const searchFormConfig: IForm = {
  labelWidth: '120px',
  itemLayout: {
    padding: '10px 40px'
  },
  colLayout: {
    span: 8
  },
  formItems: [
    {
      type: 'input',
      label: 'id',
      placeholder: '请输入id'
    },
    {
      type: 'input',
      label: '用户名',
      placeholder: '请输入用户名'
    },
    {
      type: 'password',
      label: '密码',
      placeholder: '请输入密码'
    },
    {
      type: 'select',
      label: '喜欢的运动',
      placeholder: '请选择喜欢的运动',
      options: [
        { title: '篮球', value: 'basketball' },
        { title: '足球', value: 'football' }
      ]
    },
    {
      type: 'datepicker',
      label: '创建时间',
      otherOptions: {
        startPlaceholder: '开始时间',
        endPlaceholder: '结束时间',
        type: 'daterange'
      }
    }
  ]
}
```

###### 双向绑定问题

```js
               <el-input
                  :placeholder="item.placeholder"
                  v-bind="item.otherOptions"
                  :show-password="item.type === 'password'"
                  v-model="formData[`${item.field}`]"
                />
emits: ['update:modelValue'],
  setup(props, { emit }) {   props里面接受modelValue
    const formData = ref({ ...props.modelValue })
    watch(
      formData,
      (newValue) => {
        console.log(newValue)
        emit('update:modelValue', newValue)
      },
      {
        deep: true
      }
    )
                      
```

pagesearch







##### 面包屑导航二次封装

baseui里面

```js
<template>
  <div class="nav-breadcrumb">
    <el-breadcrumb separator="/">
      <template v-for="item in breadcrumbs" :key="item.name">
        <el-breadcrumb-item :to="{ path: item.path }">{{
          item.name
        }}</el-breadcrumb-item>
      </template>
    </el-breadcrumb>
  </div>
</template>

<script lang="ts">
import { defineComponent, PropType } from 'vue'
import { IBreadcrumb } from '../types'

export default defineComponent({
  props: {
    breadcrumbs: {
      type: Array as PropType<IBreadcrumb[]>,
      default: () => []
    }
  },
  setup() {
    return {}
  }
})
</script>

<style scoped></style>

```



设置接口类型

```js
export interface IBreadcrumb {
  name: string
  path?: string
}
```

转换函数

```js
export function pathMapBreadcrumbs(userMenus: any[], currentPath: string) {
  const breadcrumbs: IBreadcrumb[] = []
  pathMapToMenu(userMenus, currentPath, breadcrumbs)
  return breadcrumbs
}

// /main/system/role  -> type === 2 对应menu
export function pathMapToMenu(
  userMenus: any[],
  currentPath: string,
  breadcrumbs?: IBreadcrumb[]
): any {
  for (const menu of userMenus) {
    if (menu.type === 1) {
      const findMenu = pathMapToMenu(menu.children ?? [], currentPath)
      if (findMenu) {
        breadcrumbs?.push({ name: menu.name })
        breadcrumbs?.push({ name: findMenu.name })
        return findMenu
      }
    } else if (menu.type === 2 && menu.url === currentPath) {
      return menu
    }
  }
}
```

双向数据流问题

父给子传一个引用  子组件不能直接更改  而是要emit一个函数  父组件接受 然后进行更改





##### table组件二次封装

proplist datalist

proplist 里面写组件的配置信息  可以设置一个slotname 

table里面    table-column里面传入一个插槽   拿到每一行的数据    每一行的user数据   接受一个scope

scope.row[propItem.prop]   相当于从一行数据里面取出   name cellphone等数据

但是不能写死  要使用 slot   动态给一个名字  可以对某一列进行更改

:row="scope.row" 传到上一层 然后再在pagecontent里面用 scope.row来拿取

```vue
 <template v-for="propItem in propList" :key="propItem.prop">
        <el-table-column v-bind="propItem" align="center">  table-column里面传入一个插槽
          <template #default="scope">
            <slot :name="propItem.slotName" :row="scope.row">
              {{ scope.row[propItem.prop] }}
            </slot>
          </template>
        </el-table-column>
      </template>
```

pagecontent

```vue
<template>
  <div class="page-content">
    <hy-table :listData="dataList" v-bind="contentTableConfig">
      <!-- 1.header中的插槽 -->
      <template #headerHandler>
        <el-button type="primary" size="medium">新建用户</el-button>
      </template>

      <!-- 2.列中的插槽 -->
      <template #status="scope">  这里可以指定那些需要修改
        <el-button
          plain
          size="mini"
          :type="scope.row.enable ? 'success' : 'danger'"
        >
          {{ scope.row.enable ? '启用' : '禁用' }}
        </el-button>
      </template>
      <template #createAt="scope">
        <span>{{ $filters.formatTime(scope.row.createAt) }}</span>
      </template>
      <template #updateAt="scope">
        <span>{{ $filters.formatTime(scope.row.updateAt) }}</span>
      </template>
      <template #handler>
        <div class="handle-btns">
          <el-button icon="el-icon-edit" size="mini" type="text"
            >编辑</el-button
          >
          <el-button icon="el-icon-delete" size="mini" type="text"
            >删除</el-button
          >
        </div>
      </template>
    </hy-table>
  </div>
</template>
```



index.ts 统一出口文件

```typescript
import MsiTabel from "./src/MsiTabel.vue";
export * from "./types/types";
export default MsiTabel;
```

types.ts

```typescript
export interface ITabeleTitle {
  prop: string;
  label: string;
  minWidth?: string;
  slotName?: string;
}
```

hytable.vue

```typescript
<template>
  <div class="msi-tabel">
    <el-table :data="tableData" border style="width: 100%">
      <template v-for="title in propList" :key="title.prop">
        <el-table-column
          :label="title.label"
          align="center"
          :min-width="title.minWidth"
        >
          <template #default="scope">
            <slot :name="title.slotName" :row="scope.row">{{
              scope.row[title.prop]
            }}
              </slot>
          </template>
        </el-table-column>
      </template>
    </el-table>
  </div>
</template>

<script lang="ts">
import { defineComponent, PropType } from "vue";
import { ITabeleTitle } from "../types/types";
export default defineComponent({
  name: "MsiTabel",
  props: {
    tableData: {
      type: Array,
      default: () => []
    },
    propList: {
      type: Array as PropType<ITabeleTitle[]>,
      default: () => []
    }
  },
  setup() {
    return {};
  }
});
</script>

<style lang="less" scoped></style>

```

然后再user.vue里面  只用使用 pagecontent pagesearch  然后再绑定相关的 config文件

pagecontent里面导入table   指定pagename       pagesearch里面导入form



```vue
<template>
  <div class="user">
    <page-search :searchFormConfig="searchFormConfig" />
    <page-content
      :contentTableConfig="contentTableConfig"
      pageName="users"
    ></page-content>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

import PageSearch from '@/components/page-search'
import PageContent from '@/components/page-content'

import { searchFormConfig } from './config/search.config'
import { contentTableConfig } from './config/content.config'

export default defineComponent({
  name: 'users',
  components: {
    PageSearch,
    PageContent
  },
  setup() {
    return {
      searchFormConfig,
      contentTableConfig
    }
  }
})
</script>

<style scoped></style>
```



#### ts封装axios

- 无处不在的代码提示；
- 灵活的拦截器；
- 可以创建多个实例，灵活根据项目进行调整；
- 每个实例，或者说每个接口都可以灵活配置请求头、超时时间等；
- 取消请求（可以根据url取消单个请求也可以取消全部请求）。

#### 基本使用

```js
import axios from 'axios'

// axios的实例对象
// 1.模拟get请求
axios.get('http://123.207.32.32:8000/home/multidata').then((res) => {
  console.log(res.data)
})

// 2.get请求,并且传入参数
// axios
//   .get('http://httpbin.org/get', {
//     params: {
//       name: 'coderwhy',
//       age: 18
//     }
//   })
//   .then((res) => {
//     console.log(res.data)
//   })

// // 3.post请求
// axios
//   .post('http://httpbin.org/post', {
//     data: {
//       name: 'why',
//       age: 18
//     }
//   })
//   .then((res) => {
//     console.log(res.data)
//   })

// 额外补充的Promise中类型的使用
// Promise本身是可以有类型
// new Promise<string>((resolve) => {
//   resolve('abc')
// }).then((res) => {
//   console.log(res.length)
// })

// 4.axios的配置选项
// 4.1. 全局的配置
axios.defaults.baseURL = 'http://httpbin.org'
axios.defaults.timeout = 10000
// axios.defaults.headers = {}

// 4.2. 每一个请求单独的配置
// axios
//   .get('/get', {
//     params: {
//       name: 'coderwhy',
//       age: 18
//     },
//     timeout: 5000,
//     headers: {}
//   })
//   .then((res) => {
//     console.log(res.data)
//   })

// 3.post请求
// axios
//   .post('/post', {
//     data: {
//       name: 'why',
//       age: 18
//     }
//   })
//   .then((res) => {
//     console.log(res.data)
//   })

// 5.axios.all -> 多个请求, 一起返回
axios
  .all([
    axios.get('/get', { params: { name: 'why', age: 18 } }),
    axios.post('/post', { data: { name: 'why', age: 18 } })
  ])
  .then((res) => {
    console.log(res[0].data)
    console.log(res[1].data)
  })

// 6.axios的拦截器
// fn1: 请求发送成功会执行的函数
// fn2: 请求发送失败会执行的函数
axios.interceptors.request.use(
  (config) => {
    // 想做的一些操作
    // 1.给请求添加token
    // 2.isLoading动画
    console.log('请求成功的拦截')
    return config
  },
  (err) => {
    console.log('请求发送错误')
    return err
  }
)

// fn1: 数据响应成功(服务器正常的返回了数据 20x)
axios.interceptors.response.use(
  (res) => {
    console.log('响应成功的拦截')
    return res
  },
  (err) => {
    console.log('服务器响应失败')
    return err
  }
)

```



#### 基础封装

首先我们实现一个最基本的版本，实例代码如下：

```typescript
//index.ts
import axios from 'axios'
import type {AxiosInstance,AxiosRequestConfig} from 'axios'
class Request{
    //axios实例
    instance:AxiosInstance
    constructor(config:AxiosRequestConfig){
        this.instance=axios.create(config)
    }
    request(config:AxiosRequestConfig){
        this.instance.request(config)
}
}
export default Request
```

其封装为一个类，而不是一个函数的原因是因为类可以创建多个实例，适用范围更广，封装性更强一些

创建一个对象 然后可以指定 baseURl Timeout 拦截器{}对象方法·

封装一个接口  指定拦截器   request拦截器    类型是axiosrequestconfig类型

catch拦截器   响应拦截  响应错误拦截

继承类型axiosrequestconfig  然后可以设置不同的拦截器

#### axios拦截器原理

。Axios是基于Promise机制实现的异步的链式请求框架。体积小，源码易懂。非常适合做基础的请求库。

#### Axios结构

1.  代码结构

    1.  `axios.js`：入口文件，将`Axios`实例的`request`函数绑定为入口函数，`axios.create`其实返回的是一个`function`，就是`Axios`实例的`Axios.prototype.request`

    2.  
        lib/Axios.js ：真正的Axios 的实例，用于拼接拦截器的调用链，关键代码如下：

        ```javascript
            // Hook up interceptors middleware
            var chain = [dispatchRequest, undefined];
            var promise = Promise.resolve(config);
            
            this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            chain.unshift(interceptor.fulfilled, interceptor.rejected);
            });
            
            this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            chain.push(interceptor.fulfilled, interceptor.rejected);
            });
            
            while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
            }
            
            return promise;
        ```

    3.  `lib/InterceptorManager.js`：拦截器管理，是一个对`[]`的封装

    4.  `lib/dispatchRequest.js`：发送请求的`Promise`，完成发送请求的逻辑。注意看`Axios.js`中的`var chain = [dispatchRequest, undefined];`

    5.  `adapter/*`：适配器，这里的代码保证了Axios在ssr模式下和浏览器环境中区分环境实现请求返送的逻辑。里面存放了两个定义好的适配器，可以参照`README.md`中的描述自定义适配器

2.  拦截器模型

    ![img](https:////upload-images.jianshu.io/upload_images/5637148-48325488140d9304.png?imageMogr2/auto-orient/strip|imageView2/2/w/1135/format/webp)

    Axios拦截器示意图.png

    -   request和response的拦截器都可以有多对，其中每一个点都会挂在一个`then()`的调用上，`promise.then(chain.shift(), chain.shift());`

#### 使用场景：应对OAuth中`refresh_token`换`access_token`时其他请求需等待的问题

-   **根据场景来看，我们需要有一下几个能力**

    1.  `Request`拦截器中任意的请求(**比如请求A**)进入之后，如果主动检测到了`access_token`的超时，那么停止当前请求**A**，开启`refresh_token`的请求，当成功之后再执行**A**请求
    2.  当请求已发送，服务端识别到了token失效，`Response`拦截器中的处理跟`Request`拦截器要做的事一样
    3.  当有进行中的`refresh_token`请求时，此请求需要等待这个进行中的`refresh_token`的请求成功之后再进行发送

-   **那我们一个一个来处理**

    1.  当请求进入拦截器，主动发现需要`refresh_token`时(比如`access_token`有效期临近)需要将请求放置在`refresh_token`成功之后

        -   处理方式可以采用在`then()`调用拦截器的方法时返回一个`Promise`，然后在`Promise`中等待`refresh_token`的请求成功之后再进行当前进入的请求的发送

        

        ```jsx
        // axios 的 request拦截器
        axios.interceptors.request.use(config => {
            return new Promise(resolve => {
                // 模拟等待refresh_token
                setTimeout(function (config_param) {
                    resolve(config_param);
                }, 2000, config)
            });
        });
        ```

        -   上面的代码只是一个简单的示意，实际处理中要注意以下几点，

            -   刷新token之后`config_param`要处理新Token的拼装；
            -   请求拦截器中要能识别出是否是`refresh_token`的请求；
            -   能识别出是否正在进行`refresh_token`，并能正确处理其他进入的请求，这个后面会讲到

        -   处理之后调用链会变成这样

            ![img](https:////upload-images.jianshu.io/upload_images/5637148-37f4199fd75e8492.png?imageMogr2/auto-orient/strip|imageView2/2/w/1184/format/webp)

            请求拦截器中加入Promise

    2.  当请求已发送，服务端识别到了Token失效时(这个情况比较多，服务器时间与本地有间隙；Token不支持多点登陆等等)，需要先`refresh_token`，然后重发请求

        -   可以采用与`Request`拦截器相似的处理，在拦截器中同样开启`refresh_token`，成功之后重新创建已经失败的请求，执行完请求之后将重新创建的请求获取到的返回值resolve给response的返回值



```tsx
        let res = response.data;
        switch (res.code) {
            case RespStatus.UNAUTHORIZED.code: {
                let respConfig = response.config;
                if (isRefreshTokenReq(respConfig.url)) {
                    //刷新Token的请求如果出现401直接退出登录
                    showLoginOut();
                } else {
                    logDebug('请求的返回值出现401，由请求' + config.url + '的返回值触发，开始进行refresh_token！');
                    let auth = storage.state.user.auth;
                    try {
                        res = doRefreshToken(auth.refresh_token, auth.wmq_d_current_username, respConfig)
                            .then(config => {
                                return wmqhttp(attachAuthInfoToConfig(storage.state.user.auth, config));
                            }).then(value => {
                                return Promise.resolve(value);
                            });
                    } catch (e) {
                        console.log('无法等待刷新Token！', e);
                        showLoginOut();
                    }
                }
                break;
            }
            default:
                logDebug('Axios response default data：', res);
                break;
        }
        return res;
```

-   处理之后调用链会变成这样

    ![img](https:////upload-images.jianshu.io/upload_images/5637148-3f88ce6334a5f689.png?imageMogr2/auto-orient/strip|imageView2/2/w/1140/format/webp)

    响应拦截器中加入Promise和二次请求

1.  对于在`refresh_token`时其他请求的进入需要安排这个请求动作，让请求发生在`refresh_token`之后进行
     \- 解决思路如下，在全局的状态中记录是否正在刷新请求，并且保存`refresh_token`的`Promise`。当遇到请求之后新创建一个`Promise`交给拦截器，在新创建的`Promise`中用`then()`等待refresh_token。



```jsx
       new Promise(resolve => {
           pendingPromise.then(() => {
               logDebug('刷新Token成功，开始处理之前等待的请求', config.url);
               resolve(attachAuthInfoToConfig(storage.state.user.auth, config));
           });
       });
```







别人传进来什么样的拦截 就可以应用什么样的拦截

不仅可以传入基本属性还可以传入拦截器

针对每个拦截器可以做自己的东西 比如输出不同的东西  进行不同的代码提示

在开发的时候控制台输出很多，自定义拦截器之后 可以对不同接口进行不同代码提示

针对不同的方法可以设置不同的拦截器   request get post delete patch等等

请求很多   请求之前做的东西不一样的   每个请求不一样   所有请求都有的处理  所有都共有  没有的再加 

比如返回的时候就拿到res.data  自己可以预先处理得到的数据  比如可以设置是否显示加载   也可以拿到其他的比如状态码 



定义一个拦截器接口    设置请求和响应的拦截器和错误拦截

再定义一个配置接口继承至AxiosRequestConfig   可以设置拦截器和是否显示加载 showLoading



在type.ts文件里面   

```typescript
import type { AxiosRequestConfig, AxiosResponse } from 'axios'
//interface指定一个类型传入 也可以设置默认类型
export interface HYRequestInterceptors<T = AxiosResponse> {
  requestInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig
  requestInterceptorCatch?: (error: any) => any
  responseInterceptor?: (res: T) => T
  responseInterceptorCatch?: (error: any) => any
}

export interface HYRequestConfig<T = AxiosResponse> extends AxiosRequestConfig {
  interceptors?: HYRequestInterceptors<T>
  showLoading?: boolean
}
```

好处就是我可以给每个拦截器里面写自己的处理

得到的结果可能不符合我们的使用要求 可以直接解析数据  进行数据的初步处理  获取不同的数据部分

可以给请求携带token

可以在开发的时候直接自定义显示或者打印错误信息   elmessage elloading

 每个请求可能返回不同的错误码 可以

可以直接控制发起请求时是否显示loading效果

```js
import axios from 'axios'
import type { AxiosInstance } from 'axios'
import type { HYRequestInterceptors, HYRequestConfig } from './type'

import { ElLoading } from 'element-plus'
import { ILoadingInstance } from 'element-plus/lib/el-loading/src/loading.type'

const DEAFULT_LOADING = true

class HYRequest {
  instance: AxiosInstance
  interceptors?: HYRequestInterceptors
  showLoading: boolean
  loading?: ILoadingInstance

  constructor(config: HYRequestConfig) {
    // 创建axios实例
    this.instance = axios.create(config)

    // 保存基本信息
    this.showLoading = config.showLoading ?? DEAFULT_LOADING
    this.interceptors = config.interceptors

    // 使用拦截器
    // 1.从config中取出的拦截器是对应的实例的拦截器
    this.instance.interceptors.request.use(
      this.interceptors?.requestInterceptor,
      this.interceptors?.requestInterceptorCatch
    )
    this.instance.interceptors.response.use(
      this.interceptors?.responseInterceptor,
      this.interceptors?.responseInterceptorCatch
    )

    // 2.添加所有的实例都有的拦截器
    this.instance.interceptors.request.use(
      (config) => {
        console.log('所有的实例都有的拦截器: 请求成功拦截')

        if (this.showLoading) {
          this.loading = ElLoading.service({
            lock: true,
            text: '正在请求数据....',
            background: 'rgba(0, 0, 0, 0.5)'
          })
        }
        return config
      },
      (err) => {
        console.log('所有的实例都有的拦截器: 请求失败拦截')
        return err
      }
    )

    this.instance.interceptors.response.use(
      (res) => {
        console.log('所有的实例都有的拦截器: 响应成功拦截')

        // 将loading移除
        this.loading?.close()

        const data = res.data
        if (data.returnCode === '-1001') {
          console.log('请求失败~, 错误信息')
        } else {
          return data
        }
      },
      (err) => {
        console.log('所有的实例都有的拦截器: 响应失败拦截')
        // 将loading移除
        this.loading?.close()

        // 例子: 判断不同的HttpErrorCode显示不同的错误信息
        if (err.response.status === 404) {
          console.log('404的错误~')
        }
        return err
      }
    )
  }

  request<T>(config: HYRequestConfig<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      // 1.单个请求对请求config的处理
      if (config.interceptors?.requestInterceptor) {
        config = config.interceptors.requestInterceptor(config)
      }

      // 2.判断是否需要显示loading
      if (config.showLoading === false) {
        this.showLoading = config.showLoading
      }

      this.instance  //指定T 需要外部传入 再到intercepter 再到res
        .request<any, T>(config)
        .then((res) => {
          // 1.单个请求对数据的处理
          if (config.interceptors?.responseInterceptor) {
            res = config.interceptors.responseInterceptor(res)
          }
          // 2.将showLoading设置true, 这样不会影响下一个请求
          this.showLoading = DEAFULT_LOADING

          // 3.将结果resolve返回出去
        
          resolve(res)
        })
        .catch((err) => {
          // 将showLoading设置true, 这样不会影响下一个请求
          this.showLoading = DEAFULT_LOADING
          reject(err)
          return err
        })
    })
  }

  get<T>(config: HYRequestConfig<T>): Promise<T> {
    return this.request<T>({ ...config, method: 'GET' })
  }

  post<T>(config: HYRequestConfig<T>): Promise<T> {
    return this.request<T>({ ...config, method: 'POST' })
  }

  delete<T>(config: HYRequestConfig<T>): Promise<T> {
    return this.request<T>({ ...config, method: 'DELETE' })
  }

  patch<T>(config: HYRequestConfig<T>): Promise<T> {
    return this.request<T>({ ...config, method: 'PATCH' })
  }
}

export default HYRequest

```

index.ts做统一出口   新建一个对象  然后设置url time interceptors

```js
// service统一出口
import HYRequest from './request'
import { BASE_URL, TIME_OUT } from './request/config'

//在新建的时候传入配置 相当于config
const hyRequest = new HYRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,
  interceptors: {
    requestInterceptor: (config) => {
      // 携带token的拦截
      const token = ''
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }

      console.log('请求成功的拦截')
      return config
    },
    requestInterceptorCatch: (err) => {
      console.log('请求失败的拦截')
      return err
    },
    responseInterceptor: (res) => {
      console.log('响应成功的拦截')
      return res
    },
    responseInterceptorCatch: (err) => {
      console.log('响应失败的拦截')
      return err
    }
  }
})

export default hyRequest

```



### 管理权限



#### 动态路由组件权限管理

表述：一开始想到 如果自己开发的时候就一次配置好所有的路由映射 展示的时候  对应的页面不展示   但是会出现问题  虽然没显示 但是可以在浏览器地址栏直接进行输入 然后进行跳转  这是个安全问题

![QQ截图20220324133927](C:\Users\Administrator\Desktop\前端八股\img\项目\QQ截图20220324133927.png)

前端这里，为不同的角色设置好不同的映射关系（映射数组），请求数据用户的角色是什么，再把该角色的数组加入到 main 对应的 children 内。 引发问题： 若后端又有新的角色出现，那么前端这边也要跟着进行修改，重新进行部署

![QQ截图20220324135421](C:\Users\Administrator\Desktop\前端八股\img\项目\QQ截图20220324135421.png)

在前端创建好所有路径对应的组件，但是根据后端返回的菜单数据，进行动态的生成路由。后端在返回对应的路径信息时，也要把该路径映射组件的路径一起返回。

在前端创建好所有路径对应的组件，但是根据后端返回的菜单数据，进行动态的生成路由。后端在**返回对应的路径信息**时，在**前端就设置好路径和组件之间的映射关系**，在**前端根据传过来的路径进行查找**，查找到就找到了该路径和组件的映射关系。

![QQ截图20220324135729](C:\Users\Administrator\Desktop\前端八股\img\项目\QQ截图20220324135729.png)

菜单到路由的映射

菜单-->url->路由->path->components

角色管理->/main/role->path->components    这个componets是一个数组routes  然后我再动态添加给main的children

后端设计的时候对于componets也有多种方法

一种是菜单中就有加载组件的名称  问题 前端开发的时候 路径和名称必须一致   一旦不一样 就会出错

另外一种就是   菜单中只有url  而我们可以在前端代码中设置  path->component 的映射关系

根据服务器的url去动态加载 这个映射关系   有哪些映射关系 再构成数组routes  再加到main里面



在view下面创建组件   mian/system/各个组件文件夹

在router文件夹下 设置相似的路径 然后写一下比如 user/user.ts

导出 name 和path   就是user.vue的目录  比如  /main/system/user

component  进行懒加载的形式import   组件



menu-->url->path->components

url找到相应的path  path对相应的vue组件

有哪些权限 注册哪些组件进行跳转



#### 代码实现

在vuex中



构建一个方法  进行路由添加

```js
import { RouteRecordRaw } from 'vue-router'

export function mapMenusToRoutes(userMenus: any[]): RouteRecordRaw[] {
  const routes: RouteRecordRaw[] = []

  // 1.先去加载默认所有的routes
  const allRoutes: RouteRecordRaw[] = []
  const routeFiles = require.context('../router/main', true, /\.ts/)
  routeFiles.keys().forEach((key) => {
    const route = require('../router/main' + key.split('.')[1])
    allRoutes.push(route.default)
  })

  // 2.根据菜单获取需要添加的routes
  // userMenus:
  // type === 1 -> children -> type === 1
  // type === 2 -> url -> route
  const _recurseGetRoute = (menus: any[]) => {
    for (const menu of menus) {
      if (menu.type === 2) {
        const route = allRoutes.find((route) => route.path === menu.url)
        if (route) routes.push(route)
      } else {
        _recurseGetRoute(menu.children)
      }
    }
  }

  _recurseGetRoute(userMenus)

  return routes
}
```

store/login.ts里面

mutations

```js
changeUserMenus(state, userMenus: any) {
      state.userMenus = userMenus

      console.log('注册动态路由')

      // userMenus => routes
      const routes = mapMenusToRoutes(userMenus)

      // 将routes => router.main.children
      routes.forEach((route) => {
        router.addRoute('main', route)
      })
    }
```



 actions

```typescript
const userMenusResult = await requestUserMenusByRoleId(userInfo.role.id)
      const userMenus = userMenusResult.data
      commit('changeUserMenus', userMenus)
      localCache.setCache('userMenus', userMenus)
```





路径

选择方法多种

方法一：不管什么角色登陆，在开发的时候，在前端都全部配置好路由的映射关系，只是在展示的时候，对应路由的跳转不展现出来。 引发的问题： 虽然页面没有展示，但是可以通过浏览器的地址栏进行 “套”，就会显示对应映射的组件，但组件上可能是没有什么东西的，虽然这样但也不好，会不安全。

方法二：在前端这里，为不同的角色设置好不同的映射关系（映射数组），请求数据用户的角色是什么，再把该角色的数组加入到 main 对应的 children 内。 引发问题： 若后端又有新的角色出现，那么前端这边也要跟着进行修改，重新进行部署。

方法三：在前端创建好所有路径对应的组件，但是根据后端返回的菜单数据，进行动态的生成路由。后端在返回对应的路径信息时，也要把该路径映射组件的路径一起返回。但是也要后端要增加一个字段，来放置组件的位置。

方法四：在前端创建好所有路径对应的组件，但是根据后端返回的菜单数据，进行动态的生成路由。后端在返回对应的路径信息时，在前端就设置好路径和组件之间的映射关系，在前端根据传过来的路径进行查找，查找到就找到了该路径和组件的映射关系。

优化问题

