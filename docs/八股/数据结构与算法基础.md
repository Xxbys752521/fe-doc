# 数据结构与算法

## [常见数据结构总结](https://juejin.cn/post/6957919292352364551)

### 1.栈

栈是一种**后进先出**（即LIFO:Last in, First out）的数据结构，在`JavaScript`中没有栈的结构，但是可以用数组来实现栈的所有功能: `push(入栈)`和`pop（出栈）`

简易实现

```js
function Stack() {
    this.stack = []
    this.push = function(item) {
        this.stack.push(item)
    }
    this.pop = function() {
        this.stack.pop()
    }
}
```



### 2.队列

队列是一种**先进先出**（即FIFO:First in, First out）的数据结构，在`JavaScript`中没有队列的数据结构，不过我们依旧可以使用数组来实现队列的功能：`enqueue（入队）`和`dequeue（出队）`

#### 简易实现

```js
function Queue() {
  this.queue = []
  this.enqueue = function(item) {
    this.queue.push(item)
  }
  this.dequeue = function() {
    return this.queue.shift()
  }
}
```

#### 完全实现

```js
function Queue() {
        //属性
        this.items = [];
        //方法
        // 1.将元素加入到队列中
        Queue.prototype.enqueue = function (element) {
          this.items.push(element);
        };
        // 2.从队列中删除前端元素
        Queue.prototype.dequeue = function () {
          return this.items.shift();
        };
        // 3.查看前端元素
        Queue.prototype.front = function () {
          return this.items[0];
        };
        // 4.查看队列是否为空
        Queue.prototype.isEmpty = function () {
          return this.items.length == 0;
        };
        // 5.查看队列元素的个数
        Queue.prototype.size = function () {
          return this.items.length;
        };
        // 6.toString
        Queue.prototype.toString = function () {
          var resultString = "";
          for (var i = 0; i < this.items.length; i++) {
            resultString += this.items[i] + " ";
          }
          return resultString;
        };
      }
//使用
var queue = new Queue();

```

### 3.链表

链接也是由多个元素组成的列表，但是与队列和栈不同的是，链表的存储是不连续的，而是使用next指向下一个元素。在链表中，我们需要添加删除元素，只需要修改next指针即可。在`js`中我们可以用`object`来模拟链表。

简单实现

```js
function ListNode(val, next) {
     this.val = (val===undefined ? 0 : val)
     this.next = (next===undefined ? null : next)
 }
```

完全实现

```js
//封装链表的类
      function LinkedList() {
        //内部的类:节点类
        function Node(data) {
          this.data = data;
          this.next = null;
        }
        //属性
        this.head = null;
        //用于记录链表的长度
        this.length = 0;

        //1.追加方法
        LinkedList.prototype.append = function (data) {
          //1.创建新节点
          var newNode = new Node(data);
          //2.判断是否添加的是第一个节点
          if (this.length === 0) {
            //2.1是第一个节点
            this.head = newNode;
          } else {
            //2.2不是第一个节点
            //找到最后一个节点
            var current = this.head;
            while (current.next) {
              current = current.next;
            }
            //最后节点的next指向新的节点
            current.next = newNode;
          }

          //3.length+1
          this.length += 1;
        };
        //2.toString方法
        LinkedList.prototype.toString = function () {
          //1.定义变量
          var current = this.head;
          var listString = "";
          //2.循环获取一个个的节点
          while (current) {
            listString += current.data + " ";
            current = current.next;
          }
          return listString;
        };
        //3.insert方法
        LinkedList.prototype.insert = function (position, data) {
          //1.对position进行越界判断
          //负数判断，长度判断
          if (position < 0 || position > this.length) return false;

          //2.根据data创建newNode
          var newNode = new Node(data);

          //3.判断插入的位置是否是第一个
          if (position == 0) {
            //让新节点的next指向head的指针,而head的指针真好指向原先的第一个
            newNode.next = this.head;
            //再让head指向新的节点
            this.head = newNode;
            this.length += 1;
          } else {
            var index = 0;
            var current = this.head;
            var previous = null;
            while (index++ < position) {
              previous = current;
              current = current.next;
            }
            newNode.next = current;
            previous.next = newNode;
            this.length += 1;
          }
        };
        //4.get方法
        LinkedList.prototype.get = function (position) {
          //1.对position进行越界判断
          //负数判断，长度判断
          if (position < 0 || position >= this.length) return null;
          //2.获取对应的data
          var current = this.head;
          var index = 0;
          while (index++ < position) {
            current = current.next;
          }
          return current.data;
        };
        //5.indexOf方法
        LinkedList.prototype.indexOf = function (data) {
          //1.定义变量
          var current = this.head;
          var index = 0;
          //2.开始查找
          while (current) {
            if (current.data === data) {
              return index;
            } else {
              current = current.next;
              index += 1;
            }
          }
          //找到最后没有找到，返回-1
          return -1;
        };
        //6.update方法
        LinkedList.prototype.update = function (position, newData) {
          //1.对position进行越界判断
          //负数判断，长度判断
          if (position < 0 || position >= this.length) return false;
          //2.获取对应的data
          var current = this.head;
          var index = 0;
          while (index++ < position) {
            current = current.next;
          }
          //将position位置的data替换成新data
          current.data = newData;
        };
        //7.removeAt方法
        LinkedList.prototype.removeAt = function (position, newData) {
          //1.对position进行越界判断
          //负数判断，长度判断
          if (position < 0 || position >= this.length) return null;
          //2.判断是否删除的是第一个节点
          var current = this.head;
          if (position === 0) {
            this.head = this.head.next;
          } else {
            var index = 0;
            var previous = null;
            while (index++ < position) {
              previous = current;
              current = current.next;
            }
            //让前一个节点的next指向current的next
            previous.next = current.next;
          }

          //3.length-1
          this.length -= 1;
          return current.data;
        };
        //8.remove方法
        LinkedList.prototype.remove = function (data) {
          //1.获取data在列表中的位置
          var position = this.indexOf(data);
          //2.根据位置信息删除节点
          return this.removeAt(position);
        };
        //9.isEmpty方法
        LinkedList.prototype.isEmpty = function () {
          return this.length === 0;
        };
        //10.size方法
        LinkedList.prototype.size = function () {
          return this.length;
        };
      }

var list = new LinkedList();
```



### 4.二叉树

树是一种**分层**数据的抽象模型，在`JavaScript`中没有树这个数据结构，所以通常我们使用`Object`来模拟一个树的结构

树的高度：从根节点到所有叶节点中最大的边的数目。

树的深度：从根节点到所有叶节点中最多的节点数目

二叉树的度是指树中所以结点的度数的最大值。二叉树的度小于等于2，因为二叉树的定义要求二叉树中任意结点的度数（结点的分支数）小于等于2

二叉树**叶子结点**总数为n0，度为2的结点个数为n2，则n0=n2+1

>假设该二叉树总共有n个结点(n=n0+n1+n2)，则该二叉树总共会有n-1条边，度为2的结点会延伸出两条边，
>
>同理，度为1的结点会延伸出一条边，则可列公式：n-1 = 2*n2 + 1*n1 ，
>
>合并两个式子可得：2*n2 + 1*n1 +1 =n0 + n1 + n2 ，则计算可知 n0=n2+1

如果完全二叉树有n个结点，那么树最高为log2(n)+1

简单实现

```js
function TreeNode(val, left, right) {
 	this.val = (val===undefined ? 0 : val)
	this.left = (left===undefined ? null : left)
	this.right = (right===undefined ? null : right)
}
```

**由数组构建二叉树**

```js
// 新建树节点类
class TreeNode {
    constructor(val, left, right) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}
// 入参一个数组，生成二叉树
function buildTree(arr) {
	// 若没有参数或数组长度为0，则视为空树
    if (!arr || arr.length === 0) {
        return null;
    }
    
    // 先将数组第一个元素 设置为根结点
    let root = new TreeNode(arr.shift());
    
    // 节点队列 陆续从数组中为节点添加左右叶子
    let nodeQueue = [root];
    
    // 当数组剩余仍有元素，则持续为最近的节点添加叶子
    while (arr.length > 0) {
    
        // 从节点数组头部取出节点 为了添加叶子备用
        let node = nodeQueue.shift();
        
        // 若数组中无元素，则视为无叶子可添加,返回即可
        if (!arr.length) {
            break;
        }
        
        // 先从节点数组中取一个元素 转化为节点 拼接为左叶子
        let left = new TreeNode(arr.shift());
        node.left = left;
        nodeQueue.push(left);
        
        // 每拼接一片叶子节点 重新判断剩余叶子数量 若无剩余视为拼接完毕
        if (!arr.length) {
            break;
        }
        
        // 左侧叶子拼完，右边一样的操作
        let right = new TreeNode(arr.shift());
        node.right = right;
        nodeQueue.push(right);
    }
    
    // 最后返回根结点，通过根结点就能得到整个二叉树的结构
    return root;
}
// 测试
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(buildTree(arr))
```

![在这里插入图片描述](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgsffbf7e0529d14205a65485a117d19395.png)



```js
     //封装二叉搜索树
      function BinarySearchTree() {
        //节点
        function Node(key) {
          this.key = key;
          this.left = null;
          this.right = null;
        }
        //属性
        this.root = null;
        //方法
        //1.1插入数据
        BinarySearchTree.prototype.insert = function (key) {
          //1.根据key创建节点
          var newNode = new Node(key);

          //2.判断根节点是否有值
          if (this.root == null) {
            this.root = newNode;
          } else {
            this.insertNode(this.root, newNode);
          }
        };
      }
```

深度优先搜索

>树的深度优先遍历即有children就继续遍历children，直到没有children后再遍历下一个结点: 深度优先遍历流程：
>
>1.  访问根结点
>2.  对根结点的children继续深度优先遍历

```js
function des(root) {
  console.log('value', root.value)
  root.children.forEach(item => {
    des(item)
  })
}

des(treeData)
```

广度优先搜索

![BFS-and-DFS-Algorithms.png](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgs75fc42a2cfacf6e41a86b34b1861d2cdcd2965b20d8ebc0a6dcc41bb1fbcea31-BFS-and-DFS-Algorithms.png)

>广度优先遍历即优先遍历子结点，如果子结点遍历完成，则遍历各子结点的children： 广度优先遍历流程：
>
>创建一个数组，将根结点作为第一项
>将数组中第一项弹出并访问
>将弹出项中的children遍历并依次添加至数组中
>重复2、3步骤直到队列为空

```js
function bfs(root) {
  let arr = [root]

  while(tree = arr.shift()) {
    console.log('value', tree.value)
    tree.children.forEach(item => {
      arr.push(item)
    })
  }
}

bfs(treeData)
```

递归

```js
//时间复杂度O(n),n为节点个树，空间复杂度O(n)，即递归的空间开销(树的高度)，最坏的情况下树是链表，所以是O(n)，平均空间复杂度O(logn)
//前序遍历:
var preorderTraversal = function(root, res = []) {
    if (!root) return res;
    res.push(root.val);
    preorderTraversal(root.left, res)
    preorderTraversal(root.right, res)
    return res;
};

//中序遍历:
var inorderTraversal = function(root, res = []) {
    if (!root) return res;
    inorderTraversal(root.left, res);
    res.push(root.val);
    inorderTraversal(root.right, res);
    return res;
};

//后序遍历:
var postorderTraversal = function(root, res = []) {
    if (!root) return res;
    postorderTraversal(root.left, res);
    postorderTraversal(root.right, res);
    res.push(root.val);
    return res;
};

```

前序遍历

非递归

```javascript
var preorderTraversal = function(root) {
    const res =[];
    const stack = [];
    while (root || stack.length){
      while(root){
        res.push(root.val);
        stack.push(root);
        root = root.left;
      }
      root = stack.pop();
      root = root.right;
    }
    return res;
};
```

中序遍历

```javascript
const inorderTraversal = (root) => {
    if(!root) return [];
  const res = [];
  const stack = [];
  while(root || stack.length){
      while(root){
          stack.push(root)
          root = root.left;
      }
     root = stack.pop();
     res.push(root.val);
     root = root.right;
  }
  return res;
};
```

后序遍历

```javascript
var postorderTraversal = function(root) {
    const res =[];
    const stack = [];
    while (root || stack.length){
      while(root){
        stack.push(root);
        res.unshift(root.val);
        root = root.right;
      }
      root = stack.pop();
      root = root.left;
    }
    return res;
};
```

二叉树的层序遍历

递归

```js
var levelOrder = function(root) {
    if(!root) return []
    var res = []
    helper(root,0)
    function helper(node,level){
        if(!node) return
        if(!res[level]){
            res[level] = [node.val]
        }else{
            res[level].push(node.val)
        }
        var left = node.left
        var right = node.right
        helper(left,level + 1)
        helper(right,level + 1)
    }
    return res
}
```



非递归（队列实现）

```javascript
var levelOrder = function(root) {
    let res=[],queue=[]
    queue.push(root)
    if(root===null){
        return res
    }
    while(queue.length!==0){
        let length=queue.length
        let curLevel=[]
        for(let i=0;i<length;i++){
            let node=queue.shift()
            curLevel.push(node.val)
            node.left&&queue.push(node.left)
            node.right&&queue.push(node.right)
        }
        res.push(curLevel)
    }
    return res;
};
```



### 5.堆

堆是一种**特殊的完全二叉树**，堆中的所有所有结点都**大于等于或小于等于**他的子结点，若**大于等于子结点**则为`最大堆`，否则为`最小堆`。在`javaScript`中通常使用数组来表示堆
对于第`i`个结点:
其父结点的索引为：`Math.floor((i - 1) / 2)`
其左子结点的索引为：`(2 * i) + 1`
其右子结点的索引为：`(2 * i) + 2`

上面我们实现了一个简单构建`最小堆`的方法，那么实现堆排序的原理其实就是先构建一个`最小堆`然后将堆顶（最小值弹出），再将其他元素构建堆，每次都弹出`堆顶`元素直到剩余元素为1时结束，这样就是实现了一个堆排序

```js
function MinHeap() {
  this.heap = []

  this.getParentIndex = function (childIndex) {
    return Math.floor((childIndex - 1) / 2)
  }
  /**
   * 交换位置
   * @param {number} index1
   * @param {number} index2
   */
  this.swap = function (index1, index2) {
    const temp = this.heap[index1]
    this.heap[index1] = this.heap[index2]
    this.heap[index2] = temp
  }

  /**
   * 上移到合适位置,和父结点比较，如果比父结点小则交换
   * @param {number} index 索引
   */
  this.moveUp = function (index) {
    if (index === 0) return
    const parentIndex = this.getParentIndex(index)
    if (this.heap[index] < this.heap[parentIndex]) {
      this.swap(index, parentIndex)
      this.moveUp(parentIndex)
    }
  }
  /**
   * 添加元素
   * @param {number} value
   */
  this.append = function (value) {
    this.heap.push(value)
    this.moveUp(this.heap.length - 1)
  }
}

const minHeap = new MinHeap()
minHeap.append(3)
minHeap.append(4)
minHeap.append(1)
minHeap.append(0)
minHeap.append(2)
minHeap.append(7)
minHeap.append(9)
// [0, 1, 3, 4, 2, 7, 9]
```





## [排序算法](https://juejin.cn/post/6844903444365443080#heading-18)

![image-20220713104357499](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgseIf4dkY1cVW7Nlp.png)

### 冒泡排序

一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来

思路如下：

-   比较相邻的元素，如果第一个比第二个大，就交换它们两个

-   对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数

-   针对所有的元素重复以上的步骤，除了最后一个

-   重复上述步骤，直到没有任何一堆数字需要比较

![](https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp)

```js
function bubbleSort1(arr){
 const i=arr.length-1;//初始时,最后位置保持不变  
 while(i>0){
  let pos = 0;//每趟开始时,无记录交换
  for(let j = 0; j < i; j++){
   if(arr[j] > arr[j+1]){
        let tmp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
    pos = j;//记录最后交换的位置  
   }   
  }
  i = pos;//为下一趟排序作准备
 }
 return arr;
}
```

###  选择排序

选择排序是一种简单直观的排序算法，它也是一种交换排序算法

无论什么数据进去都是 `O(n²)`的时间复杂度。所以用到它的时候，数据规模越小越好

唯一的好处是不占用额外的内存存储空间

思路如下：

-   在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
-   从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
-   重复第二步，直到所有元素均排序完毕

![](https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp)

```js
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
```

### 插入排序

插入排序是一种简单直观的排序算法

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

解决思路如下：

-   把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的
-   从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
-   重复上述过程直到最后一个元素被插入有序子数组中

![](https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp)

```js
function insertionSort(arr) {
    const len = arr.length;
    let preIndex, current;
    for (let i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
```

### 归并排序

归并排序是建立在归并操作上的一种有效的排序算法

该算法是采用分治法的一个非常典型的应用

将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序

解决思路如下：

-   申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
-   设定两个指针，最初位置分别为两个已经排序序列的起始位置
-   比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
-   重复步骤3直到某一指针到达序列尾
-   将另一序列剩下的所有元素直接复制到合并序列尾

![](https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg)

```js
function mergeSort(arr) {  // 采用自上而下的递归方法
    const len = arr.length;
    if(len < 2) {
        return arr;
    }
    let middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    const result = [];

    while (left.length && right.length) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
}
```

### 快速排序

快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小

再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列

解决思路如下：

-   从数列中挑出一个元素，称为"基准"（pivot）
-   重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
-   递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序

![](https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.jpg)

```js
function quickSort (arr) {
  const rec = (arr) => {
    if (arr.length <= 1) { return arr; }
    const left = [];
    const right = [];
    const mid = arr[0]; // 基准元素
    for (let i = 1; i < arr.length; i++){
      if (arr[i] < mid) {
        left.push(arr[i]);
      } else {
        right.push(arr[i]);
      }
    }
    return [...rec(left), mid, ...rec(right)]
  }
  return res(arr)
};
```

### 堆排序

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

- 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；大顶堆的一个特性是数据将被从大到小取出，将取出的数字按照相反的顺序进行排列，数字就完成了排序
- 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

堆排序的平均时间复杂度为 Ο(nlogn)。

#### 算法步骤

堆排序的基本思想是：

1、将带排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；

2、将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；

3、重复步骤2，如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个有序的序列了。

```js
var len 
function buildMaxHeap(arr){  //建立大顶堆
	len=arr.length;  //第一个非叶子结点的下标为i=Math.floor(arr.length/2 - 1) 
	for(var i =Math.floor(len/2);i>=0;i--){
		heapify(arr,i) //下标 i 依次减1（即从第一个非叶子结点开始，从右至左，从下至上遍历所有非叶子节点）
	}
}
function heapify(arr,i){//调整堆 以三个数为基础进行比较 父节点 左子节点 右子节点
	let left=2*i+1,  //对于结点 i ，其子结点为 2*i+1 与 2*i+2 
	right=2*i+2,
	largest=i;
	if(left<len&&arr[left]>arr[largest]){
		largest=left
	}
	if(right<len&&arr[right]>arr[largest]){
		largest=right
	}
	if(largest!=i){
		swap(arr,i,largest)
		heapify(arr,largest)
	}
}
function swap(arr,i,j){
	var temp=arr[i]
	arr[i]=arr[j]
	arr[j]=temp
}
function heapSort(arr){
	buildMaxHeap(arr)
	for(var i=arr.length-1;i>0;i--){
		swap(arr,0,i)
		len--
		heapify(arr,0)
	}
	return arr;
}

var arr=[1,3,0,5,2,9,10,11,4]
console.log(heapSort(arr));
```

## 算法思想

### 位运算

平常我们用来计算的是十进制的数值 `0~9` ，但是计算机是个机器，它只能识别二进制

根据国际 IEEE 754 标准，`JavaScript` 在存储数字时是始终以双精度浮点数来存储的，这种格式用 64 位二进制存储数值，64 位也就是 64 比特（bit），相当于 8 个字节，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号

而在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位数值，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以，因为 64 位存储格式是不可见的，但是也正是因为后台这个默认转换操作，给 JS 这门语言产生了一个副作用，即特殊值 NaN 和 Infinity 在位运算中都会直接被当作 0 来处理

`ECMAScript` 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）

在 ECMAScript 中，所有整数字面量默认都是有符号整数

有符号整数也就是上文所说，二进制左侧首位是符号位来表明该数字正负

而无符号整数就是没有符号位，没有了符号位置也就说它表达不了负数，同时因为没有了符号位置，它的存储范围也会比有符号整数存储范围大

位运算符有 7 个，分为两类：

-   逻辑位运算符：位与（&）、位或（|）、位异或（^）、非位（~）
-   移位运算符：左移（<<）、右移（>>）、无符号右移（>>>）


逻辑位运算符与逻辑运算符的运算方式是相同的，但是针对的对象不同。逻辑位运算符针对的是二进制的整数值，而逻辑运算符针对的是非二进制的值。

#### “&”运算符

“&”运算符（位与）用于对两个二进制操作数逐位进行比较，并根据下表所示的换算表返回结果。



| 第一个数的位值 | 第二个数的位值 | 运算结果 |
| -------------- | -------------- | -------- |
| 1              | 1              | 1        |
| 1              | 0              | 0        |
| 0              | 1              | 0        |
| 0              | 0              | 0        |


在位运算中，数值 1 表示 true，0 表示 false，反之亦然。

12 和 5 进行位与运算，则返回值为 4。

```js
console.log(12 & 5);  //返回值4
```


下图以算式的形式解析了 12 和 5 进行位与运算的过程。通过位与运算，只有第 3 位的值为全为 true，故返回 true，其他位均返回 false。



![img](http://c.biancheng.net/uploads/allimg/190827/6-1ZRG5503E94.gif)

##### 使用按位与 & 判断奇偶数

按位与这个东西平常用的不太多，我一般只会在判断奇偶数的才会用到，如下：

```js
偶数 & 1 // 0
奇数 & 1 // 1
```

因为十进制数字 1 的二进制为 `0000 ... 0001`，只有最后一位为 1，其余位都是 0 ，所以任何数字和它对比除最后一位其余都是 0，那么当这个数字末位为 1 时，也就是奇数，那么结果就是 1，这个数字末位为 0 时，也就是偶数，那么结果就是 0，毕竟二进制只有 0 和 1

##### 使用按位与 & 判断数字是否为2的整数幂

判断数字是否为 2 的整数幂，使用 `n & (n - 1)`

```js
let a = 20;
let b = 32;

a & (a - 1) // 16 a不是2的整数幂
b & (b - 1) // 0 	b是2的整数幂
```

如上所示，套用这个小公式，当结果等于 0 时，数值就是 2 的整数幂

其实原理也很简单，首先我们来看数值 2 的幂对应的二进制

```js
0000 0001  -> 1  	// 2^0
0000 0010  -> 2		// 2^1
0000 0100  -> 4		// 2^2
0000 1000  -> 8		// 2^3
0001 0000  -> 16	// 2^4
```

如上，2 的幂在二进制中只有一个 1 后跟一些 0，那么我们在判断一个数字是不是 2 的幂时，用 `n & (n-1)`，如果 你是 2 的幂，n 减 1 之后的二进制就是原来的那一位 1 变成 0，后面的 0 全变成 1，这个时候再和自身做按位与对比时，每一位都不同，所以每一位都是 0，即最终结果为 0



#### “|”运算符

“|”运算符（位或）用于对两个二进制操作数逐位进行比较，并根据如表格所示的换算表返回结果。



| 第一个数的位值 | 第二个数的位值 | 运算结果 |
| -------------- | -------------- | -------- |
| 1              | 1              | 1        |
| 1              | 0              | 1        |
| 0              | 1              | 1        |
| 0              | 0              | 0        |


12 和 5 进行位或运算，则返回值为 13。

```js
console.log(12 | 5);  //返回值13
```


下图以算式的形式解析了 12 和 5 进行位或运算的过程。通过位或运算，除第 2 位的值为 false 外，其他位均返回 true。



![img](http://c.biancheng.net/uploads/allimg/190827/6-1ZRG5594I36.gif)

##### 使用按位或 ｜ 取整

取整的时候我们也可以使用按位或取整

```js
1.111 | 0 // 1
2.234 | 0 // 2
```

如上所示，只需要将小数同 0 进行按位或运算即可

原理也简单，位运算操作的是整数，相当于数值的整数部分和 0 进行按位或运算

0 的二进制全是 0 ，按位或对比时 1 和 0 就是 1 ，0 和 0 就是 0，得出的二进制就是我们要取整数值的整数部分

##### 使用按位或 | 代替Math.round()

我们上面知道按位或可以取整，其实四舍五入也就那么回事了，即正数加 0.5，负数减 0.5 进行按位或取整即可，道理就是这么简单，如下

```js
let a1 = 1.1
let a2 = 1.6
a1 + 0.5 | 0 // 1
a2 + 0.5 | 0 // 2

let b1 = -1.1
let b2 = -1.6
b1 - 0.5 | 0 // -1
b2 - 0.5 | 0 // -2
```



#### “^”运算符

“^”运算符（位异或）用于对两个二进制操作数逐位进行比较，并根据如表格所示的换算表返回结果。



| 第一个数的位值 | 第二个数的位值 | 运算结果 |
| -------------- | -------------- | -------- |
| 1              | 1              | 0        |
| 1              | 0              | 1        |
| 0              | 1              | 1        |
| 0              | 0              | 0        |


12 和 5 进行位异或运算，则返回值为 9。

```js
console.log(12 ^ 5);  //返回值9
```


下图以算式的形式解析了 12 和 5 进行位异或运算的过程。通过位异或运算，第 1、4 位的值为 true，而第 2、3 位的值为 false。



![img](http://c.biancheng.net/uploads/allimg/190827/6-1ZRG63913W0.gif)

##### 使用按位异或 ^ 判断整数部分是否相等

按位异或可以用来判断两个整数是否相等，如下

```js
let a = 1
let b = 1
a ^ b // 0

1 ^ 1 // 0
2 ^ 2 // 0
3 ^ 3 // 0
```

这是因为按位异或只在一位是 1 时返回 1，两位都是 1 或者两位都是 0 都返回 0，两个相同的数字二进制都是一致的，所以都是 0

我们也可以用作判断两个小数的整数部分是否相等，如下

```js
2.1 ^ 2.5 // 0
2.2 ^ 2.6 // 0
2.1 ^ 3.1 // 1
```

这是为什么？牢记位运算操作的是整数、是整数、是整数，也就是说上面这几个对比完全可以理解为同下

```js
2 ^ 2 // 0
2 ^ 2 // 0
2 ^ 3 // 1
```

##### 使用按位异或 ^ 来完成值交换

我们也可以使用按位异或来进行两个变量的值交换，如下

```js
let a = 1
let b = 2
a ^= b
b ^= a
a ^= b
console.log(a)   // 2
console.log(b)   // 1
```

道理也很简单，我们先要了解一个东西

```js
// 如果
a ^ b = c
// 那么
c ^ b = a
c ^ a = b
```

现在你再品一下值交换为什么可以交换，细品

不过这里使用 `^` 来做值交换不如用 ES6 的解构，因为 ES6 解构更方便易懂

##### 使用按位异或 ^ 切换 0 和 1

切换 0 和 1，即当变量等于 0 时，将它变成 1，当变量等于 1 时，将它变成 0

常用于 `toggle `开关状态切换，做开关状态更改时，普通小伙伴会如下这样做

```js
let toggle = 0

if(toggle){
  toggle = 0
}else{
  toggle = 1
}
```

聪明点的小伙伴会用三目运算符

```js
let toggle = 0

toggle = toggle ? 0 : 1
```

使用按位异或更简单

```js
let toggle = 0

toggle ^= 1
```

原理也简单， `toggle ^= 1` 等同于 `toggle = toggle ^ 1`，我们知道 `0 ^ 1` 等于 1，而 `1 ^ 1` 则为 0

##### 使用按位异或 ^ 判断两数符号是否相同

我们可以使用 `(a ^ b) >= 0` 来判断两个数字符号是否相同，也就是说同为正或同为负

```js
let a = 1
let b = 2
let c = -2

(a ^ b) >= 0 // true
(a ^ c) >= 0 // false
```

原理也简单，正数二进制左首位也就是符号位是 0，而负数则是 1

按位异或在对比时，只有一正一负时才为 1，两位都是 0 或者都是 1 时结果为 0

所以，两个数值符号一样时按位异或对比后的二进制结果符号位肯定是 0，最终数值也就是 `>=0`，反之则 `<0`

#### “~”运算符

“~”运算符（位非）用于对一个二进制操作数逐位进行取反操作。

-   第 1 步：把运算数转换为 32 位的二进制整数。
-   第 2 步：逐位进行取反操作。
-   第 3 步：把二进制反码转换为十进制浮点数。

反码是符号位不变其余位置取反，而按位非则是取反码后符号位也取反


对 12 进行位非运算，则返回值为 -13。

```js
console.log( ~ 12 );  //返回值-13
```


下图以算式的形式解析了对 12 进行位非运算的过程。



![img](http://c.biancheng.net/uploads/allimg/190827/6-1ZRG64625624.gif)


位非运算实际上就是对数字进行取负运算，再减 1。例如：

```
console.log( ~ 12 == 12-1);  //返回true
```

和 `(-x) - 1` 是一致的，那么为什么还要用按位非呢

很简单，原因有二，第一是位运算的操作是在数值底层表示上完成的，速度快。第二是因为它只用 2 个字符，比较方便

##### 使用按位非 ~ 判断是否等于-1

```js
let str = "abcdefg"

if(!~str.indexOf("n")){
	console.log("字符串 str 中不存在字符 n")
}

// 等同于

if(str.indexOf("n") == "-1"){
  console.log("字符串 str 中不存在字符 n")
}
```

>indexOf` 方法在找不到相同值时返回 -1，而 `~-1 == 0 == false` ，所以 `!~-1 == 1 == true

##### 使用按位非 ~ 取整

按位非的骚操作中，还有一个比较普遍的就是位运算双非取整了，如下所示

```js
~~3.14 == 3
```

很多人知道这样可以取整，但是由于不知道具体是为什么而不敢用，所以我们来解释下为什么它为什么可以取整

上面我们说过，在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位整数，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以

这里我们可以看到，32 位 `整数`，位运算操作的是整数，后台在进行 64 位到 32 位转换时，会忽略掉小数部分，只关注整数、整数、整数，记住了

```js
~3.14 == ~3
~5.89 == ~5
```

如上所示，接着我们再按照上面的公式

```js
~x == (-x) - 1

~~x == -((-x) - 1) -1 == -(-x) + 1 -1 == x
```

所以位运算中的双非 `~~` 即可取整，此取整是完全忽略小数部分

#### 左移（<<）

##### 简述

左移用符号 `<<` 来表示，正如它的名字，即将数值的二进制码按照指定的位数向左移动，符号位不变

**例如： **

求 `2 << 5`，即求十进制数 2 左移 5 位的操作

我们先将十进制数字 2 转二进制再左移 5 位后如下图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812a3ec24515437ea46e32d469dbe3d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

我们得到了一个新的二进制，转为 10 进制即为数值 64

数字 x 左移 y 位我们其实可以得到一个公式，如下

```js
x << y 

// 等同于

x * 2^y
```

##### 使用左移 << 取整

使用左移也可取整

```js
1.111 << 0 // 1
2.344 << 0 // 2
```

原理是位运算操作的是整数，忽略小数部分，等同于数值的整数部分，左移 0 位，结果还是整数部分

#### 有符号右移（>>）

##### 简述

有符号右移用符号 `>>` 来表示，即将数值的二进制码按照指定的位数向右移动，符号位不变，它和左移相反

**例如：**

求 `64 >> 5`，即求十进制数 64 有符号右移 5 位的操作

我们先将十进制数字 64 转二进制再右移 5 位后如下图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdd4f6d57ebd46c7afb70af671a5d557~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

有符号右移时移动数位后会同样也会造成空位，空位位于数字的左侧，但位于符号位之后，`ECMAScript` 中用符号位的值填充这些空位

随后，我们就得到了一个新的二进制，转为 10 进制即为数值 2，其实就是左移的逆运算

同样，数字 x 有符号右移 y 位我们也可以得到一个公式，如下

```js
x >> y 

// 等同于

x / 2^y
```

##### 使用右移 >> 取整

使用右移和左移一样都可以取整

```js
1.111 >> 0 // 1
2.344 >> 0 // 2
```

原理还是那一个，位运算操作的是整数，忽略小数部分，等同于数值的整数部分，右移 0 位，结果还是整数部分

#### 无符号右移（>>>）

##### 简述

无符号右移使用 `>>>` 表示，和有符号右移区别就是它是三个大于号，它会将数值的所有 32 位字符都右移

对于正数，无符号右移会给空位都补 0 ，不管符号位是什么，这样的话正数的有符号右移和无符号右移结果都是一致的

负数就不一样了，当把一个负数进行无符号右移时也就是说把负数的二进制码包括符号为全部右移，向右被移出的位被丢弃，左侧用0填充，由于符号位变成了 0，所以结果总是非负的

那么可能就有人要问了，如果一个负数无符号右移 0 位呢，我们可以测试一下

让十进制 -1 进行无符号右移 0 位

-1 是负数，在内存中二进制存储是补码即 `1111 .... 1111 1111`，32 位都是 1，我们在程序中写入 `-1 >>> 0` 运行得到十进制数字 `4294967295` ，再使用二进制转换工具转为二进制得到的就是 32 位二进制 `1111 .... 1111 1111`，所以就算无符号右移 0 位，得出的依然是一个很大的正数

##### 使用无符号右移 >>> 取整（正数）

无符号右移和有符号右移以及左移都差不多，移 0 位都可取整，只不过无符号右移只能支持正数的取整，至于原理，说过无数遍了，相信你已经记住了，如下

```js
1.323 >>> 0 // 1
2.324 >>> 0 // 2
```



### 位图法

可以解决海量数据的存在性问题，又不占用很多内存的前提下。

**位图法的原理主要就是利用int类型数据，一个int类型数据是4个字节，一个字节8位，然后一个int数据利用自身字节位就可以表示0-31的数是否存在，bit位表示数值，位山0，1值表示这个数值是否存在。**

**所有的int类型数据一共有**2^32/8 = 2^29 Byte约等于512MB（2^10=1KB 2^20 =1MB 2^30=1GB）表示所有的int类型数需要512MB，现在的计算机完全可以胜任，这些可以表示多少位数呢就是一个int可以表示32个数，32*2^32=2^37约等于10^11百亿级别；

**具体方案**

那么接下来我们只需要申请一个int数组长度为 int tmp[N/32+1]即可存储完这些数据，其中N代表要进行查找的总数（这里也就是2^32），tmp中的每个元素在内存在占32位可以对应表示十进制数0~31,所以可得到BitMap表:

tmp[0]:可表示0~31

tmp[1]:可表示32~63

tmp[2]可表示64~95

~~

假设这10亿int数据为：6,3,8,32,36,……，那么具体的BitMap表示为：





![img](https:////upload-images.jianshu.io/upload_images/23201985-049460b486f67d10.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/702/format/webp)



**使用如何快速查找具体的是否存在：**

(1). 如何判断int数字放在哪一个tmp数组中：将数字直接除以32取整数部分(x/32)，例如：整数8除以32取整等于0，那么8就在tmp[0]上；

(2). 如何确定数字放在32个位中的哪个位：将数字mod32取模(x%32)。上例中我们如何确定8在tmp[0]中的32个位中的哪个位，这种情况直接mod上32就ok，又如整数8，在tmp[0]中的第8 mod上32等于8，那么整数8就在tmp[0]中的第八个bit位（从右边数起）。

**对于多次出现的数据处理方法**

然后我们怎么统计只出现一次的数呢？每一个数出现的情况我们可以分为三种：0次、1次、大于1次。也就是说我们需要用2个bit位才能表示每个数的出现情况。此时则三种情况分别对应的bit位表示是：00、01、11

我们顺序扫描这10亿的数，在对应的双bit位上标记该数出现的次数。最后取出所有双bit位为01的int型数就可以了。

### 哈希表原理

[HashMap原理技术知识整理](https://juejin.cn/post/6844904040329904142#heading-12)

保存数据有两种比较简单的数据结构：数组 和 链表。

- 数组：寻址容易，插入和删除困难；
- 链表：寻址困难，但插入和删除容易。

把数组和链表这两种结构结合在一起，发挥出各自的优势，这种结构就是哈希表。

哈希表的底层实际上是基于数组来存储的，当插入键值对时，并不是直接插入该数组中，而是通过对键进行Hash运算得到Hash值，然后和数组容量取模，得到在数组中的位置后再插入。取值时，先对指定的键求Hash值，再和容量取模得到底层数组中对应的位置，如果指定的键值与存贮的键相匹配，则返回该键值对，如果不匹配，则表示哈希表中没有对应的键值对。这样做的好处是在查找、插入、删除等操作可以做到![O(1)](https://juejin.cn/equation?tex=O(1))，最坏的情况是![O(n)](https://juejin.cn/equation?tex=O(n))，当然这种是最极端的情况，极少遇到。

**数组：**采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)

**线性链表：**对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)

**二叉树：**对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。

**哈希表：**相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。

数据结构的物理存储结构只有两种：**顺序存储结构和链式存储结构**（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，**哈希表的主干就是数组**。

比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。

> **存储位置 = f(关键字)**

其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：

![image-20220901144739619](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgsimage-20220901144739619.png)

查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可

**`HashMap` 底层就是一个数组结构，数组中的每一项又是一个链表**

![image-20220901144307727](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgsimage-20220901144307727.png)

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/8/16bd1006f29c29d1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)


不管哪门语言，实现一个HashMap的过程均可分为三大步骤：



- 实现一个Hash函数
- 合理解决Hash冲突
- 实现HashMap的操作方法

**简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好**

#### Hash函数

Hash函数非常重要，一个好的Hash函数不仅性能优越，而且还会让存储于底层数组中的值分配的更加均匀，减少冲突发生。之所以是减少冲突，是因为取Hash的过程，实际上是将输入键（定义域）映射到一个非常小的空间中，所以冲突是无法避免的，能做的只是减少Hash碰撞发生的概率。具体实现时，哈希函数算法可能不同，在Rust及很多语言的实现中，默认选择SipHash哈希算法。

> 默认情况下，Rust的HashMap使用SipHash哈希算法，其旨在防止哈希表碰撞攻击，同时在各种工作负载上提供合理的性能。虽然 SipHash 在许多情况下表现出竞争优势，但其中一个比其它哈希算法要慢的情况是使用短键，例如整数。这就是为什么 Rust 程序员经常观察到 HashMap 表现不佳的原因。在这些情况下，经常推荐 FNV 哈希，但请注意，它不具备与 SipHash 相同的防碰撞性。

影响Hash碰撞（冲突）发生的除了Hash函数本身意外，底层数组容量也是一个重要原因。很明显，极端情况下如果数组容量为1，哪必然发生碰撞，如果数组容量无限大，哪碰撞的概率非常之低。所以，哈希碰撞还取决于负载因子。负载因子是存储的键值对数目与数组容量的比值，比如数组容量100，当前存贮了90个键值对，负载因子为0.9。负载因子决定了哈希表什么时候扩容，如果负载因子的值太大，说明存储的键值对接近容量，增加碰撞的风险，如果值太小，则浪费空间。

所以，既然冲突无法避免，就必须要有解决Hash冲突的机制方法。

#### 处理冲突的几种方法

主要有四类处理冲突的方法：

- 外部拉链法（常用）
- 开放定址法（常用）
- 公共溢出区（不常用）
- 再Hash法（不常用）

##### 外部拉链法

主要思想是基于数组和链表的组合来解决冲突，桶（Bucket）中不直接存储键值对，每个Bucket都链接一个链表，当发生冲突时，将冲突的键值对插入链表中。外部拉链法的有点在于方法简单，非同义词之间也不会产生聚集现象（相比于开放定址法），并且其空间结构是动态申请的，所以比较适合无法确定表长的情况：缺点是链表指针需要额外的空间，遇到碰撞拒绝服务时会退化为单链表。

> 同义词：两个元素通过Hash函数得到了相同的索引地址，这两个元素就叫做同义词。

下面是外部拉链法的两种实现方法，主要区别在于桶（Bucket）中是否存储数据。

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/8/16bd10077cad7031~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)





![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/8/16bd10073a24d54d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



##### 开放定址法

![image-20220901144001248](https://femarkdownpicture.oss-cn-qingdao.aliyuncs.com/imgsimage-20220901144001248.png)

下图为线性探测:



![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/8/16bd100716f2fd17~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



##### 公共溢出区

主要思想是建立一个独立的公共区，把冲突的键值对都放在其中。不常用，这里不再细述。

##### 再Hash法

主要思想是有冲突时，换另外一个Hash函数来算Hash值。不常用，这里不再细述。

#### 实现哈希表的操作方法

主要是：

- insert
- remove
- get
- contains_key
- ......等等......

其中最重要的是插入、查找、删除这三个操作

### 哈希函数

`hash`表（散列表）一般被用来加密，压缩等。
当选择的hash函数足够复杂时（难以破解），那么密码的明码通过此hash函数生成[散列](https://so.csdn.net/so/search?q=散列&spm=1001.2101.3001.7020)值的过程就是不可逆的，这往往被IT公司用来保存用户的密码，防止泄露。
hash table被用来压缩，主要是因为通过hash函数映射后，数据存储的空间大大缩小，提高空间利用率，往往被用来处理大数据，这是由于通过**hash函数映射的散列值所占用的空间远远小于原数据**。
以百度TopK面试题为例进行说明：

#### 问题描述

搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。
假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。

#### 分析：

**第一步：统计各个查询串出现的次数**
1.**首先直接将数据存入内存中是不合适的，因为根据题意此一千万条数据占用的内存大于1G，所以不能选择内部排序。考虑外排后，再遍历所有数据统计频数**。
2.外排时，文件排序用归并排序是最合适的，时间复杂度为O(nlogn)。而用hash table的时间复杂度为O（n）。

**用法如下：**

1.以查询串为Key值，以出现的次数为value创建哈希表，key值通过哈希函数映射为数字，数字对数组长度取余，余数就为hash表的下表，将对应的数据进行存储。hash表的实现方式有多种，邻接表是一个不错的实现。例如：
![这里写图片描述](https://img-blog.csdn.net/20180910161929819?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbmRva2luZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
2.依次遍历数据，如果查询串已经在哈希表中存在，那么将次数加1，如果不存在，通过映射进行存储，初始数据设为1。这样一次遍历完后就将每个查询串的频数统计完毕。即使300万条记录均只出现一次且散列值不同，占用的存储空间也满足要求。
**第二步：找出Top10**
这一步就是单纯的将查询串根据出现的频次进行排序。使用时间复杂度较小的堆排序，建立小顶堆（堆排序参考我的相关博文）。先遍历最初的十个数据建立小顶堆，然后依次遍历后续数据，和小顶堆根节点（最小的数据比较）。如果数据小于根节点，继续遍历。如果数据大于根节点，将根节点删除吗，将此数据放入堆中，调整为小顶堆，继续遍历比较。直到最后生成堆的是个数据便是Top10。遍历的时间复杂度为O(n),建堆调整堆的时间复杂度为O((n-k)logk),此处k为10。所以用堆操作的查找Top10时间复杂度为O(nlogn)。
必须指出的是，hash table 的优劣完全依赖哈希函数的选取，一般选取哈希函数有取模取余，平方等。显然这些简单的哈希函数映射后会有冲突发生，多个key值对应同一个存储空间，当然邻接链表结构是可以很好解决。但选取一个合适的函数是非常必要的，一般的公式为index=(value*x)>>28,右移，为除以2^28次方。
推荐x选取使用斐波那契（Fibonacci）散列法
斐波那契序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610， 987, 1597, 2584, 4181, 6765, 10946，…
对我们常见的32位整数而言，公式： index = (value * 2654435769) >> 28
对于64位整数而言，这个乘数是11400714819323198485

### 海量数据问题

[海量数据处理](https://blog.csdn.net/weixin_43831728/article/details/115347760)

#### top K问题

先拿10000个数建堆，然后一次添加剩余元素，如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的10000个数就是所需的最大的10000个。建堆时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为10亿，m为10000）。

优化的方法：可以把所有10亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果。

在大规模数据处理中，经常会遇到的一类问题：**在海量数据中找出出现频率最好的前k个数，或者从海量数据中找出最大的前k个数，这类问题通常被称为top K问题**。例如，在搜索引擎中，统计搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。
针对top K类问题，通常比较好的方案是**分治+Trie树/hash+小顶堆（就是上面提到的最小堆），即先将数据集按照Hash方法分解成多个小数据集，然后使用Trie树活着Hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数，最后在所有top K中求出最终的top K**。

#### 有1亿个浮点数，如果找出期中最大的10000个？

最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求（我机器内存都是8GB），该方法也并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。

第二种方法为**局部淘汰法**，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的10000个数还小，那么容器内这个10000个数就是最大10000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。

第三种方法是**分治法**，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100*10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。

第四种方法是**Hash法**。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。

第五种方法采用**最小堆**。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）。

实际运行：
实际上，最优的解决方案应该是最符合实际设计需求的方案，在时间应用中，可能有足够大的内存，那么直接将数据扔到内存中一次性处理即可，也可能机器有多个核，这样可以采用多线程处理整个数据集。

   **下面针对不容的应用场景，分析了适合相应应用场景的解决方案。**

（1）单机+单核+足够大内存
如果需要查找10亿个查询次（每个占8B）中出现频率最高的10个，考虑到每个查询词占8B，则10亿个查询次所需的内存大约是10^9 * 8B=8GB内存。如果有这么大内存，直接在内存中对查询次进行排序，顺序遍历找出10个出现频率最大的即可。这种方法简单快速，使用。然后，也可以先用HashMap求出每个词出现的频率，然后求出频率最大的10个词。

（2）单机+多核+足够大内存
这时可以直接在内存总使用Hash方法将数据划分成n个partition，每个partition交给一个线程处理，线程的处理逻辑同（1）类似，最后一个线程将结果归并。

​    该方法存在一个瓶颈会明显影响效率，即数据倾斜。每个线程的处理速度可能不同，快的线程需要等待慢的线程，最终的处理速度取决于慢的线程。而针对此问题，解决的方法是，将数据划分成c×n个partition（c>1），每个线程处理完当前partition后主动取下一个partition继续处理，知道所有数据处理完毕，最后由一个线程进行归并。

（3）单机+单核+受限内存
这种情况下，需要将原数据文件切割成一个一个小文件，如次啊用hash(x)%M，将原文件中的数据切割成M小文件，如果小文件仍大于内存大小，继续采用Hash的方法对数据文件进行分割，知道每个小文件小于内存大小，这样每个文件可放到内存中处理。采用（1）的方法依次处理每个小文件。

（4）多机+受限内存
这种情况，为了合理利用多台机器的资源，可将数据分发到多台机器上，每台机器采用（3）中的策略解决本地的数据。可采用hash+socket方法进行数据分发。

​    从实际应用的角度考虑，（1）（2）（3）（4）方案并不可行，因为在大规模数据处理环境下，作业效率并不是首要考虑的问题，算法的扩展性和容错性才是首要考虑的。算法应该具有良好的扩展性，以便数据量进一步加大（随着业务的发展，数据量加大是必然的）时，在不修改算法框架的前提下，可达到近似的线性比；算法应该具有容错性，即当前某个文件处理失败后，能自动将其交给另外一个线程继续处理，而不是从头开始处理。

​    top K问题很适合采用MapReduce框架解决，用户只需编写一个Map函数和两个Reduce 函数，然后提交到Hadoop（采用Mapchain和Reducechain）上即可解决该问题。具体而言，就是首先根据数据值或者把数据hash(MD5)后的值按照范围划分到不同的机器上，最好可以让数据划分后一次读入内存，这样不同的机器负责处理不同的数值范围，实际上就是Map。得到结果后，各个机器只需拿出各自出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是Reduce过程。对于Map函数，采用Hash算法，将Hash值相同的数据交给同一个Reduce task；对于第一个Reduce函数，采用HashMap统计出每个词出现的频率，对于第二个Reduce 函数，统计所有Reduce task，输出数据中的top K即可。

​    直接将数据均分到不同的机器上进行处理是无法得到正确的结果的。因为一个数据可能被均分到不同的机器上，而另一个则可能完全聚集到一个机器上，同时还可能存在具有相同数目的数据。

**以下是一些经常被提及的该类问题。**
（1）有10000000个记录，这些查询串的重复度比较高，如果除去重复后，不超过3000000个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请统计最热门的10个查询串，要求使用的内存不能超过1GB。

（2）有10个文件，每个文件1GB，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。按照query的频度排序。

（3）有一个1GB大小的文件，里面的每一行是一个词，词的大小不超过16个字节，内存限制大小是1MB。返回频数最高的100个词。

（4）提取某日访问网站次数最多的那个IP。

（5）10亿个整数找出重复次数最多的100个整数。

（6）搜索的输入信息是一个字符串，统计300万条输入信息中最热门的前10条，每次输入的一个字符串为不超过255B，内存使用只有1GB。

（7）有1000万个身份证号以及他们对应的数据，身份证号可能重复，找出出现次数最多的身份证号。

#### 重复问题

在海量数据中查找出重复出现的元素或者去除重复出现的元素也是常考的问题。针对此类问题，一般可以通过位图法实现。例如，已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。

​    本题最好的解决方法是通过使用位图法来实现。8位整数可以表示的最大十进制数值为99999999。如果每个数字对应于位图中一个bit位，那么存储8位整数大约需要99MB。因为1B=8bit，所以99Mbit折合成内存为99/8=12.375MB的内存，即可以只用12.375MB的内存表示所有的8位数电话号码的内容。



## 输入输出练习

### 常用数据结构

#### 一维数组

c++

```c++
int arr=[n]
vector<int> dp(n)
```

javascript

```js
const arr=[]
const arr=Array(n)
const arr=new Array(n)
const arr= Array(n).fill(0)
```

#### 二维数组

##### c++

```c++
vector<vector<int>> dp(n,vector<int>(m))  
n*m可扩展二维数组   长度可以直接扩展
```

##### javascript

推荐使用

`const dp=Array(m+1).fill().map(()=>Array(n+1).fill(0))`

`const dp=[]  dp.push([])`

```js
const dp = new Array(n).fill([0,0])
const dp = Array.from(Array(n), () => Array(n).fill(0));
const dp = new Array(word1.length + 1).fill(0)
        .map(() => new Array(word2.length + 1).fill(0))

const dp = Array(m + 1).fill()  //fill()必需有
        .map(() =>Array(n + 1).fill(0))
const dp=[]  dp.push([])
```

#### 哈希表（Map)

举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：

```js
var names = ['Michael', 'Bob', 'Tracy'];
var scores = [95, 75, 85];
```

给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。

如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。

用JavaScript写一个Map如下：

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：

```js
var m = new Map(); // 空Map
m.set('Adam', 67); // 添加新的key-value
m.set('Bob', 59);
m.has('Adam'); // 是否存在key 'Adam': true
m.get('Adam'); // 67
m.delete('Adam'); // 删除key 'Adam'
m.get('Adam'); // undefined
```

- `set(key, val)`: 向 `Map` 中添加新元素
- `get(key)`: 通过键值查找特定的数值并返回
- `has(key)`: 判断 `Map` 对象中是否有 `Key` 所对应的值，有返回 `true`，否则返回 `false`
- `delete(key)`: 通过键值从 `Map` 中移除对应的数据
- `clear()`: 将这个 `Map` 中的所有元素删除

- `keys()`：返回键名的遍历器
- `values()`：返回键值的遍历器
- `entries()`：返回键值对的遍历器
- `forEach()`：使用回调函数遍历每个成员

##### 常用

```js
for(let i=0;i<arr.length;i++){
	map.set(arr[i],(map.get(arr[i]||0)+1)
}
const count=Array.from(map).sort((a,b)=>{
        return b[1]-a[1]
    })         
```

#### 集合(Set)

Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。

要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
```

重复元素在Set中自动被过滤：

```js
var s = new Set([1, 2, 3, 3, '3']);
s; // Set {1, 2, 3, "3"}
```

通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：

```js
s.add(4);
s; // Set {1, 2, 3, 4}
s.add(4);
s; // 仍然是 Set {1, 2, 3, 4}
```

通过delete(key)方法可以删除元素：

```js
var s = new Set([1, 2, 3]);
s; // Set {1, 2, 3}
s.delete(3);
s; // Set {1, 2}
```

- `add(value)`：添加某个值，返回 `Set` 结构本身(可以链式调用)。
- `delete(value)`：删除某个值，删除成功返回 `true`，否则返回 `false`。
- `has(value)`：返回一个布尔值，表示该值是否为 `Set` 的成员。
- `clear()`：清除所有成员，没有返回值。

- `keys()`：返回键名的遍历器。
- `values()`：返回键值的遍历器。
- `entries()`：返回键值对的遍历器。
- `forEach()`：使用回调函数遍历每个成员。

#### 链表

```js
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
 }
```

#### 二叉树

```js
function TreeNode(val, left, right) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
 }
```

### 基本输入

牛客网v8模式是readline()

赛码网v8模式是read_line()

node模式通用模板

```js
let buf='';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
				line=line.split(' ')		
    })
});
```

### 单行输入

#### 两数相加

js

注意问题   **输入得到的字符串  需要进行去除空格转换成字符数组**  然后再进行parseInt

**技巧**   对于多个数组可以考虑 **arr.map((item)=>item*1)**  **不必每个都parseInt()**  (四则运算中只有加法会影响 字符串和数字的运算 str*1会优先转换成数字)

##### v8模式

```js
var line;
while(line = read_line()){
    line = line.split(' ');
    print(parseInt(line[0]) + parseInt(line[1]));
}
```

##### node模式

```js
var readline = require('readline');
const reader = readline.createInterface({
	input: process.stdin,
	output: process.stdout
});
reader.on('line', function (line) {
	var tokens = line.split(' ');
	console.log(parseInt(tokens[0]) + parseInt(tokens[1]));
});
```

可以直接 `+tokens[0]`转成数字  或者`1*tokens[0]`

`console.log()`本身就换行

换行  `console.log(a+'\n')`

简化

`let n=parseInt(readline())`

`let arr=readline().split(' ').map(Number)`

### 固定行输入

例如输入

3 

1 2
3 4
5 6

表示

输入三个数组

##### v8模式

```js
var line =read_line();
line=line.split(' ');
var m=parseInt(line[0])
var n=parseInt(line[1])
console.log(m)
console.log(n)
var a=[],b=[];
while(m--){
    var sum=read_line();
    sum=sum.split(' ');
    var x=parseInt(sum[0]);
    var y=parseInt(sum[1]);
    a.push(x);
    b.push(y);
}
console.log(a)
console.log(b)
```

##### node模式 模板

```js
let buf='';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
let getInputNums = line => line.split(' ').filter(s => s !== '').map(x => parseInt(x));
let getInputStr = line => line.split(' ').filter(s => s !== '');
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
         if (lineIdx === 0) {
            n = getInputNums(line)[0];
            m = getInputNums(line)[1];
        } else if (lineIdx <= n) {
            let a = getInputNums(line)[0];
            let b = getInputNums(line)[1];
            v[lineIdx] = a;
            w[lineIdx] = b;
          if(lineIdx===n) console.log(func(v,w,n,m))
    })
});
func(v,w,n,m)
```

##### 输入二维数组

输入

```
3 
1 2 3
4 5 6
7 8 9
```

```js
var line=readline()
line=line.split(' ')
var n=parseInt(line[0])
var q=parseInt(line[1])
var dp=Array(n+1).fill().map(()=>Array(n+1).fill(0))
for(let i=0;i<n;i++){
	var row = readline()
	row = row.split(' ')
	dp.push(row)  //直接按行进行push
}
```

##### **结构**

-   接受输入
-   处理字符串数据
-   处理输入
-   传入参数，接受算法函数返回结果
-   编写算法函数

##### 完全背包

输入

```js
4 5
1 2
2 4
3 4
4 5
```

```js
const N = 1010;


let v = new Int32Array(N);
let w = new Int32Array(N);
let f = [];
let init = n => {
    for (let i = 0; i <= n; i++) {
        f[i] = new Int32Array(N);
    }
}
let n = 0;
let buf = '';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
let getInputNums = line => line.split(' ').filter(s => s !== '').map(x => parseInt(x));
let getInputStr = line => line.split(' ').filter(s => s !== '');
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
        if (lineIdx === 0) {
            n = getInputNums(line)[0];
            m = getInputNums(line)[1];
            init(n);
        } else if (lineIdx <= n) {
            let a = getInputNums(line)[0];
            let b = getInputNums(line)[1];
            v[lineIdx] = a;
            w[lineIdx] = b;
            if (lineIdx === n) {
                for (let i = 1; i <= n; i++) { //件数
                    for (let j = 0; j <= m; j++) { //体积
                        f[i][j] = f[i - 1][j];
                        if (j >= v[i]) f[i][j] = Math.max(f[i][j], f[i][j - v[i]] + w[i]);
                    }
                }
                console.log(f[n][m]);
            }
        }
    });
});
```

##### 合并区间

输入

```js
5
1 2
2 4
5 6
7 8
7 9
```

```js
let inputRanges = [];

let getRangeCount = (ranges) => {
    ranges.sort((a, b) => a[0] - b[0]);
    let result = 1;
    let curr = ranges[0];
    for (let i = 1; i < ranges.length; i++) {
        if (ranges[i][0] <= curr[1])
            curr[1] = Math.max(curr[1], ranges[i][1]);
        else {
            result++;
            curr = ranges[i++];
        }
    }
    return result;
}
let buf = '';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
let getInputArgs = line =>
    line.split(' ').filter(s => s !== '').map(x => parseInt(x));
process.stdin.on('end', function () {
    let n = 0;
    buf.split('\n').forEach(function (line, lineIdx) {
        if (lineIdx === 0) {
            let a = getInputArgs(line);
            n = a[0];
        } else if (lineIdx <= n) {
            inputRanges.push(getInputArgs(line));
            if (lineIdx === n)
                console.log(getRangeCount(inputRanges));
        }
    });
});
```

##### 最长上升子序列

输入

```js
7
3 1 2 1 8 5 6
```

```js
const N = 1010;
let arr = [];
let f = new Int32Array(N).fill(1);  //最长序列只有自己一个数
let a = new Int32Array(N);

let n = 0;

let buf = '';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
let getInputNums = line => line.split(' ').filter(s => s !== '').map(x => parseInt(x));
let getInputStr = line => line.split(' ').filter(s => s !== '');
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
        if (lineIdx === 0) {
            n = getInputNums(line)[0];
        } else if (lineIdx === 1) {
            arr = getInputStr(line);
            for (let i = 0; i < arr.length; i++) a[i + 1] = arr[i];
            for (let i = 1; i <= n; i++) {
                for (let j = 1; j < i; j++)
                    if (a[j] < a[i])
                        f[i] = Math.max(f[i], f[j] + 1);
            }
            let res = 0;
            for (let i = 1; i <= n; i++) res = Math.max(res, f[i]);
            console.log(res);
        }
    });
});
```



### 不定行数输入字符串(无限输入)

#### 输入多个字符串进行正则匹配

##### v8模式

```js
var line;
var reg=/^(?=.*[0-9])(?=.*[a-zA-Z])(?=.*[^a-zA-Z0-9]).{8,}$/
while(line=read_line()){
  var ans=reg.test(line)
  if(ans) console.log('ok')
  else console.log('false')
}
```

##### node模式  

```js
let buf='';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
       if(line){
      var ans=reg.test(line)
      if(ans) console.log('ok')
      else console.log('false') 
        }
    })
});
```

##### c++模式

万能头文件

`#include<bits/stdc++.h>`

```c++
#include<iostream>
#include<regex>
using namespace std;
int main()
{	string str
	regex  reg("^(?=.*[0-9])(?=.*[a-zA-Z])(?=.*[^a-zA-Z0-9]).{8,}$");
	while(cin>>str){
	smatch result;
	bool ret = regex_match(str, result, reg);
	cout << (ret ? "合适" : "不合适") << endl;
	}
}
```

### c++ stl使用

[算法竞赛C++ STL详解（容器、算法、迭代器）](https://blog.csdn.net/m0_51755720/article/details/120616163)

#### STL六大组件是什么?

STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是容器、算法、迭代器、仿函数、适配器、空间配置器。其中，在算法竞赛中用到最多的为**容器、算法与迭代器**。

- 容器(`Container`)：STL容器为各种**数据结构**，如`vector`、`stack`、`queue`、`map`、`set`等，用来存放数据，从实现角度来看，STL容器是一种`class template`。
- 算法(`Algorithm`)：STL的算法多数定义在`<algorithm>`头文件中，其中包括了各种常用的算法，如`sort`、`find`、`copy`、`reverse`等，从实现角度来看，STL算法是一种`function template`。
- 迭代器(`Iterator`)：STL迭代器扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将`opetator*`、`opetator->`、`operator++`等指针相关操作予以重载的`class template`。所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。
- 仿函数(`Functor`)：行为类似函数，可作为算法的某种策略，从实现角度来看，仿函数是一种重载了`operator()`的`class`或者`class template`。
- 适配器(`Adaptor`)：一种用来修饰容器或仿函数或迭代器接口的东西。
- 空间配置器(`Allocator`)：负责空间的配置与管理。从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的`class template`。

#### STL容器详解

① `vector`：又称`变长数组`，定义在`<vector>`头文件中，`vector`容器是**动态空间**，随着元素的加入，它的内部机制会自动扩充空间以容纳新的元素。因此`vector`的运用对于内存的合理利用与运用的灵活性有很大的帮助。

-   `vector`的定义方式

```c++
vector<int> v;//定义一个vector，其中的元素为int类型
vector<int> v[N];//定义一个vector数组，其中有N个vector
vector<int> v(len);//定义一个长度为len的vector
vector<int> v(len, x);//定义一个长度为len的vector，初始化每个元素为x
vector<int> v2(v1);//用v1给v2赋值，v1的类型为vector
vector<int> v2(v1.begin(), v1.begin() + 3);//将v1中第0~2三个元素赋值给v2
```

-   `vector`的常用内置函数

```c++
    //vector中的常用内置函数
vector<int> v = { 1, 2, 3 };//初始化vector，v:{1, 2, 3}
vector<int>::iterator it = v.begin();//定义vector的迭代器，指向begin()

v.push_back(4);//在vector的尾部插入元素4，v:{1, 2, 3, 4}
v.pop_back();//删除vector的最后一个元素，v:{1, 2, 3}
//注意使用lower_bound()与upper_bound()函数时vector必须是有序的，upper_bound()在<algorithm>中
lower_bound(v.begin(), v.end(), 2);//返回第一个大于等于2的元素的迭代器v.begin() + 1，若不存在则返回v.end()
upper_bound(v.begin(), v.end(), 2);//返回第一个大于2的元素的迭代器v.begin() + 2，若不存在则返回v.end()
v.size();//返回vector中元素的个数
v.empty();//返回vector是否为空，若为空则返回true否则返回false
v.front();//返回vector中的第一个元素
v.back();//返回vector中的最后一个元素
v.begin();//返回vector第一个元素的迭代器
v.end();//返回vector最后一个元素后一个位置的迭代器
v.clear();//清空vector
v.erase(v.begin());//删除迭代器it所指向的元素，即删除第一个元素
v.erase(v.begin(), v.begin() + 2);//删除区间[v.begin(), v.begin() + 2)的所有元素
v.insert(v.begin(), 1);//在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器

//根据下标进行遍历
for (int i = 0; i < v.size(); i++)
cout << v[i] << ' ';
//使用迭代器遍历
for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
cout << *it << ' ';
//for_each遍历(C++11)
for (auto x : v)
cout << x << ' ';
```

②`stack`：又称`栈`，是一种**后进先出**(`Last In First Out，LIFO`)的数据结构，定义在`<stack>`头文件中，`stack`容器允许新增元素、移除元素、取得栈顶元素，但是除了最顶端以外，没有任何方法可以存取`stack`的其它元素，换言之，`stack`**不允许有遍历行为**。

-   `stack`的定义方式

```c++
    stack<int> stk;//定义一个stack，其中元素的类型为int
    stack<int> stk[N];//定义一个stack数组，其中有N个stack
```

-   `stack`的常用内置函数

```c++
    //stack中的常用内置函数
    stack<int> stk;
stk.push(x);//在stack中插入元素x
stk.pop();//弹出stack的栈顶元素
stk.top();//返回stack的栈顶元素
stk.size();//返回stack中元素的个数
stk.empty();//返回stack是否为空，若为空则返回true否则返回false
```

③`string`：又称字符串，定义在`<string>`头文件中。C风格的字符串(以空字符结尾的字符数组)太过复杂难于掌握，因此C++标准库定义了一种`string`类。`string`和`vector<char>`在数据结构、内存管理等方面都是相同的。但是，`vector<char>`只是单纯的一个“ c h a r char char元素的容器”，而`string`不仅是一个“ c h a r char char元素的容器”，它还扩展了一些针对字符串的操作，例如`string`可以使用`c_str()`函数转换为C风格的字符串， `vector`中并未对输入输出流操作符进行重载，因此无法直接对`vector<char>`进行 c i n cin cin或者 c o u t cout cout这样的操作，但是`string`可以，`vector<char>`并不能直接实现字符串的拼接，但是`string`可以，`string`中重载了 + , + = +,+= +,+\=运算符。

-   `string`的定义方式

```c++
string str;//定义一个空的字符串
string str[N];//定义一个string数组，其中有N个string
string str(5, 'a');//使用5个字符'a'初始化
string str("abc");//使用字符串初始化
```

-   `string`的常用内置函数

```c++
    //string中的常用内置函数
    string str("abcabc");
str.push_back('d');//在string尾部插入字符，"abcabcd"
str.pop_back();//删除string尾部的字符，"abcabc"
str.length();//返回string中字符的个数
str.size();//作用与length()相同
str.empty();//返回string是否为空，若为空返回true否则返回false
str.substr(1);//返回string中从下标为1开始至末尾的子串，"bcabc"
str.substr(0, 2);//返回string中从下标为0开始长度为2的子串，"ab"
str.insert(1, 2, 'x');//在下标为1的字符前插入2个字符'x'，"axxbcabc"
str.insert(1, "yy");//在下标为1的字符前插入字符串"yy"，"ayyxxbcabc"
str.erase(1, 4);//删除从位置1开始的4个字符，"abcabc"
str.find('b');//返回字符'b'在string中第一次出现的位置，返回1，若不存在则返回-1
str.find('b', 2);//返回从位置2开始字符'b'在string中第一次出现的位置，返回4
str.find("bc");//同上，返回字符串第一次出现的位置，返回1，若不存在则返回-1
str.find("bc", 2);//返回4
str.rfind('b');//反向查找，原理同上，返回4，若不存在则返回-1
str.rfind('b', 3);//返回1
str.rfind("bc");//返回4，若不存在则返回-1
str.rfind("bc", 3);//返回1
stoi(str);//返回str的整数形式
to_string(value);//返回value的字符串形式，value为整型、浮点型等
str[0];//用下标访问string中的字符
cout << (str == str) << endl;//string可比较大小，按字典序
```

-   `string`的`erase()`与`remove()`函数的用法

```c++
    //string中erase()与remove()的用法
string str1, str2, str3, str4, str5;
str1 = str2 = str3 = str4 = str5 = "I love AcWing! It's very funny!";
str1.erase(15);//删除[15,end())的所有元素，"I love AcWing!"
str2.erase(6, 11);//从第6个元素(包括)开始往后删除11个元素，"I love's very funny!"
str3.erase(str3.begin() + 2);//删除迭代器所指的元素，"I ove AcWing! It's very funny!"
str4.erase(str4.begin() + 7, str4.end() - 11);//删除[str4.begin()+7,str4.end()-11)的所有元素，"I love very funny!"
str5.erase(remove(str5.begin(), str5.end(), 'n'), str5.end());//删除[str5.begin(),str5.end())中所有字符'n'，"I love AcWig! It's very fuy!"
```

④`queue`：又称`队列`，是一种**先进先出**(`First In First Out，FIFO`)的数据结构，定义在`<queue>`头文件中，`queue`容器允许从一端(称为`队尾`)新增元素(`入队`)，从另一端(称为`队头`)移除元素(`出队`)。  
⑤`priority_queue`：又称`优先队列`，同样定义在`<queue>`头文件中，与`queue`不同的地方在于我们可以自定义其中数据的优先级，优先级高的排在队列前面，优先出队。`priority_queue`具有`queue`的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它的本质是用`堆`实现的，因此可分为`小根堆`与`大根堆`，`小根堆`中较小的元素排在前面，`大根堆`中较大的元素排在前面。**注意：创建`priority_queue`时默认是`大根堆`！**

-   `queue`的定义方式

```c++
queue<int> que;//定义一个queue，其中元素的类型为int
queue<int> que[N];//定义一个queue数组，其中有N个queue
priority_queue<int> bigHeap;//定义一个大根堆
priority_queue<int, vector<int>, greater<int> > smallHeap;//定义一个小根堆
```

-   `queue`的常用内置函数

```c++
    //queue中的常用内置函数
    queue<int> que;
    que.push(x);//在queue的队尾插入元素x
que.pop();//出队queue的队头元素
que.front();//返回queue的队头元素
que.back();//返回queue的队尾元素
que.size();//返回queue中元素的个数
que.empty();//返回queue是否为空，若为空则返回true否则返回false
```

⑥`deque`：又称`双端队列`，定义在`<deque>`头文件中，`vector`容器是单向开口的连续内存空间，`deque`则是一种**双向开口的连续线性空间**。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，`vector`也可以在头尾两端插入元素，但是在其头部进行插入操作效率奇差，无法被接受。`deque`和`vector`最大的差异一是在于`deque`允许使用常数项时间在头部进行元素的插入和删除操作，二是在于`deque`没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。

-   `deque`的定义方式

```c++
deque<int> deq;//定义一个deque，其中的元素为int类型
deque<int> deq[N];//定义一个deque数组，其中有N个deque
deque<int> deq(len);//定义一个长度为len的deque
deque<int> deq(len, x);//定义一个长度为len的deque，初始化每个元素为x
deque<int> deq2(deq1);//用deq1给v2赋值，deq2的类型为deque
deque<int> deq2(deq1.begin(), deq1.begin() + 3);//将deq1中第0~2三个元素赋值给deq2
```

-   `deque`的常用内置函数

```c++
    //deque中的常用内置函数
    deque<int> deq = { 1, 2, 3 };//初始化vector，v:{1, 2, 3}
deque<int>::iterator it = deq.begin();//定义vector的迭代器，指向begin()

deq.push_back(4);//在deque的尾部插入元素4，v:{1, 2, 3, 4}
deq.pop_back();//删除deque的尾部元素，v:{1, 2, 3}
deq.push_front(4);//在deque的头部插入元素4，v:{4, 1, 2, 3}
deq.pop_front();//删除deque的头部元素，v:{1, 2, 3}
deq.size();//返回deque中元素的个数
deq.empty();//返回deque是否为空，若为空则返回true否则返回false
deq.front();//返回deque中的第一个元素
deq.back();//返回deque中的最后一个元素
deq.begin();//返回deque第一个元素的迭代器
deq.end();//返回deque最后一个元素后一个位置的迭代器
deq.clear();//清空deque
deq.erase(deq.begin());//删除迭代器it所指向的元素，即删除第一个元素
deq.erase(deq.begin(), deq.begin() + 2);//删除区间[v.begin(), v.begin() + 2)的所有元素
deq.insert(deq.begin(), 1);//在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器

//根据下标进行遍历
for (int i = 0; i < deq.size(); i++)
cout << deq[i] << ' ';
//使用迭代器遍历
for (deque<int>::iterator it = deq.begin(); it != deq.end(); it++)
cout << *it << ' ';
//for_each遍历(C++11)
for (auto x : deq)
cout << x << ' ';
```

⑦`map/multimap`：又称`映射`，定义在`<map>`头文件中，`map`和`multimap`的底层实现机制都是红黑树。`map`的功能是**能够将任意类型的元素映射到另一个任意类型的元素上**，并且所有的元素都会根据元素的键值自动排序。`map`所有的元素都是`pair`，同时拥有`实值`和`键值`，`pair`的第一元素被视为`键值`，第二元素被视为`实值`，`map`不允许两个元素有相同的键值。`multimap`和`map`的操作类似，唯一区别是`multimap`的键值允许重复。

-   `map/multimap`的定义方式

```c++
map<string, int> mp;//定义一个将string映射成int的map
map<string, int> mp[N];//定义一个map数组，其中有N个map
multimap<string, int> mulmp;//定义一个将string映射成int的multimap
multimap<string, int> mulmp[N];//定义一个multimap数组，其中有N个multimap
```

-   `map/multimap`的常用内置函数

```c++
    //map/multimap中的常用内置函数
    map<string, int> mp;
mp["abc"] = 3;//将"abc"映射到3
mp["ab"]++;//将"ab"所映射的整数++
mp.insert(make_pair("cd", 2));//插入元素
mp.insert({ "ef", 5 });//同上
mp.size();//返回map中元素的个数
mp.empty();//返回map是否为空，若为空返回true否则返回false
mp.clear();//清空map
mp.erase("ef");//清除元素{"ef", 5}
mp["abc"];//返回"abc"映射的值
mp.begin();//返回map第一个元素的迭代器
mp.end();//返回map最后一个元素后一个位置的迭代器
mp.find("ab");//返回第一个键值为"ab"的迭代器，若不存在则返回mp.end()
mp.find({ "abc", 3 });//返回元素{"abc", 3}的迭代器，若不存在则返回mp.end()
mp.count("abc");//返回第一个键值为"abc"的元素数量1，由于map元素不能重复因此count返回值只有0或1
mp.count({ "abc", 2 });//返回第一个键值为"abc"的元素数量1，注意和find不一样，count只判断第一个键值
mp.lower_bound("abc");//返回第一个键值大于等于"abc"的元素的迭代器，{"abc", 3}
mp.upper_bound("abc");//返回第一个键值大于"abc"的元素的迭代器，{"cd", 2}

//使用迭代器遍历
for (map<string, int>::iterator it = mp.begin(); it != mp.end(); it++)
cout << (*it).first << ' ' << (*it).second << endl;
//for_each遍历(C++11)
for (auto x : mp)
cout << x.first << ' ' << x.second << endl;
//扩展推断范围的for_each遍历(C++17)
for (auto &[k, v] : mp)
cout << k << ' ' << v << endl;
```

⑧`set/multiset`：又称`集合`，定义在`<set>`头文件中。`set`的特性是所有元素都会根据元素的键值自动被排序，`set`的元素不像`map`那样可以同时拥有`实值`和`键值`，`set`的元素既是`键值`又是`实值`，`set`不允许两个元素有相同的键值，因此总结来说就是`set`中的元素是**有序且不重复的**。`multiset`的特性和用法和`set`完全相同，唯一的区别在于`multiset`允许有重复元素，`set`和`multiset`的底层实现都是红黑树。

-   `set/multiset`的定义方式

```c++
set<int> st;//定义一个set，其中的元素类型为int
set<int> st[N];//定义一个set数组，其中有N个set
multiset<int> mulst;//定义一个multiset
multiset<int> mulst[N];//定义一个multiset数组，其中有N个multiset
```

-   `set/multiset`的常用内置函数

```c++
    //set/multiset中的常用内置函数
set<int> st;
st.insert(5);//插入元素5
st.insert(6);//同上
st.insert(7);//同上
st.size();//返回set中元素的个数
st.empty();//返回set是否为空，若为空返回true否则返回false
st.erase(6);//清除元素6
st.begin();//返回set第一个元素的迭代器
st.end();//返回set最后一个元素后一个位置的迭代器
st.clear();//清空set
st.find(5);//返回元素5的迭代器，若不存在则返回st.end()
st.count(5);//返回元素5的个数1，由于set元素不会重复，因此count返回值只有0或1
st.lower_bound(5);//返回第一个键值大于等于5的元素的迭代器，返回元素5的迭代器
st.upper_bound(5);//返回第一个键值大于5的元素的迭代器，返回元素7的迭代器

//使用迭代器遍历
for (set<int>::iterator it = st.begin(); it != st.end(); it++)
cout << (*it) << ' ';
//for_each遍历(C++11)
for (auto x : st)
cout << x << ' ';
```

⑨`unordered_map/unordered_set`：分别定义在`<unordered_map>`与`<unordered_set>`头文件中，内部采用的是`hash`表结构，拥有快速检索的功能。与`map/set`相比最大的区别在于`unordered_map/unordered_set`中的元素是**无序**的，增删改查的时间复杂度为`O(1)`(`map/set`增删改查的时间复杂度为`O(logn)`)，但是不支持`lower_bound()/upper_bound()`函数。

-   `unordered_map/unordered_set`的定义方式

```c++
unordered_set<int> st;//定义一个unordered_set，其中的元素类型为int
unordered_set<int> st[N];//定义一个unordered_set数组，其中有N个unordered_set
unordered_map<int, int> mp;//定义一个unordered_map
unordered_map<int, int> mp[N];//定义一个unordered_map数组，其中有N个unordered_map
```

-   `unordered_map/unordered_set`的常用内置函数

```c++
    //unordered_map/unordered_set中的常用内置函数
    unordered_set<int> st;
unordered_map<int, int> mp;
st.insert(5);//插入元素5
st.insert(6);//同上
st.insert(7);//同上
st.size();//返回unordered_set中元素的个数
st.empty();//返回unordered_set是否为空，若为空返回true否则返回false
st.erase(6);//清除元素6
st.begin();//返回unordered_set第一个元素的迭代器
st.end();//返回unordered_set最后一个元素后一个位置的迭代器
st.clear();//清空unordered_set
mp.insert(make_pair(1, 2));//插入元素{1, 2}
mp.insert({ 3, 4 });//同上
mp.size();//返回unordered_map中元素的个数
mp.empty();//返回unordered_map是否为空，若为空返回true否则返回false
mp.erase(3);//清除元素{3, 4}
mp.begin();//返回unordered_map第一个元素的迭代器
mp.end();//返回unordered_map最后一个元素后一个位置的迭代器
mp.clear();//清空unordered_map

//使用迭代器遍历
for (unordered_set<int>::iterator it = st.begin(); it != st.end(); it++)
cout << (*it) << ' ';
//for_each遍历(C++11)
for (auto x : st)
cout << x << ' ';

//使用迭代器遍历
for (unordered_map<int, int>::iterator it = mp.begin(); it != mp.end(); it++)
cout << (*it).first << ' ' << (*it).second << endl;
//for_each遍历(C++11)
for (auto x : mp)
cout << x.first << ' ' << x.second << endl;
//扩展推断范围的for_each遍历(C++17)
for (auto &[k, v] : mp)
cout << k << ' ' << v << endl;
```

#### STL算法详解

C++标准库定义了一组`泛型算法`，之所以称为`泛型`指的是它们可以操作在多种容器上，**不但可以作用于标准库类型，还可以用在内置数组类型甚至其它类型的序列上。**`泛型算法`定义在`<algorithm>`头文件中，标准库还定义了一组`泛化的算术算法`(`Generalized Numeric Algorithm`)，定义在`<numeric>`头文件中。

```c++
#include <iostream>
#include <algorithm>
#include <numeric>
using namespace std;

int main()
{
//使用STL容器时将数组地址改为迭代器即可

int a[5] = { 1, 2, 3, 4, 5 };

//排序算法
sort(a, a + 5);//将区间[0, 5)内元素按字典序从小到大排序
sort(a, a + 5, greater<int>());//将区间[0, 5)内元素按字典序从大到小排序
reverse(a, a + 5);//将区间[0, 5)内元素翻转
nth_element(a, a + 3, a + 5);//将区间[0, 5)中第a + 3个数归位，即将第3大的元素放到正确的位置上，该元素前后的元素不一定有序

//查找与统计算法
find(a, a + 5, 3);//在区间[0, 5)内查找等于3的元素，返回迭代器，若不存在则返回end()
binary_search(a, a + 5, 2);//二分查找区间[0, 5)内是否存在元素2，若存在返回true否则返回false
count(a, a + 5, 3);//返回区间[0, 5)内元素3的个数

//可变序列算法
copy(a, a + 2, a + 3);//将区间[0, 2)的元素复制到以a+3开始的区间，即[3, 5)
replace(a, a + 5, 3, 4);//将区间[0, 5)内等于3的元素替换为4
fill(a, a + 5, 1);//将1写入区间[0, 5)中(初始化数组函数)
unique(a, a + 5);//将相邻元素间的重复元素全部移动至末端，返回去重之后数组最后一个元素之后的地址
remove(a, a + 5, 3);//将区间[0, 5)中的元素3移至末端，返回新数组最后一个元素之后的地址

//排列算法
next_permutation(a, a + 5);//产生下一个排列{ 1, 2, 3, 5, 4 }
prev_permutation(a, a + 5);//产生上一个排列{ 1, 2, 3, 4, 5 }

//前缀和算法
partial_sum(a, a + 5, a);//计算数组a在区间[0, 5)内的前缀和并将结果保存至数组a中

return 0;
}
```

