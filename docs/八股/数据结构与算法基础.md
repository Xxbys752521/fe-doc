# 数据结构与算法

## [常见数据结构总结](https://juejin.cn/post/6957919292352364551)

### 1.栈

栈是一种**后进先出**（即LIFO:Last in, First out）的数据结构，在`JavaScript`中没有栈的结构，但是可以用数组来实现栈的所有功能: `push(入栈)`和`pop（出栈）`

简易实现

```js
function Stack() {
    this.stack = []
    this.push = function(item) {
        this.stack.push(item)
    }
    this.pop = function() {
        this.stack.pop()
    }
}
```



### 2.队列

队列是一种**先进先出**（即FIFO:First in, First out）的数据结构，在`JavaScript`中没有队列的数据结构，不过我们依旧可以使用数组来实现队列的功能：`enqueue（入队）`和`dequeue（出队）`

#### 简易实现

```js
function Queue() {
  this.queue = []
  this.enqueue = function(item) {
    this.queue.push(item)
  }
  this.dequeue = function() {
    return this.queue.shift()
  }
}
```

#### 完全实现

```js
function Queue() {
        //属性
        this.items = [];
        //方法
        // 1.将元素加入到队列中
        Queue.prototype.enqueue = function (element) {
          this.items.push(element);
        };
        // 2.从队列中删除前端元素
        Queue.prototype.dequeue = function () {
          return this.items.shift();
        };
        // 3.查看前端元素
        Queue.prototype.front = function () {
          return this.items[0];
        };
        // 4.查看队列是否为空
        Queue.prototype.isEmpty = function () {
          return this.items.length == 0;
        };
        // 5.查看队列元素的个数
        Queue.prototype.size = function () {
          return this.items.length;
        };
        // 6.toString
        Queue.prototype.toString = function () {
          var resultString = "";
          for (var i = 0; i < this.items.length; i++) {
            resultString += this.items[i] + " ";
          }
          return resultString;
        };
      }
//使用
var queue = new Queue();

```

### 3.链表

链接也是由多个元素组成的列表，但是与队列和栈不同的是，链表的存储是不连续的，而是使用next指向下一个元素。在链表中，我们需要添加删除元素，只需要修改next指针即可。在`js`中我们可以用`object`来模拟链表。

简单实现

```js
function ListNode(val, next) {
     this.val = (val===undefined ? 0 : val)
     this.next = (next===undefined ? null : next)
 }
```

完全实现

```js
//封装链表的类
      function LinkedList() {
        //内部的类:节点类
        function Node(data) {
          this.data = data;
          this.next = null;
        }
        //属性
        this.head = null;
        //用于记录链表的长度
        this.length = 0;

        //1.追加方法
        LinkedList.prototype.append = function (data) {
          //1.创建新节点
          var newNode = new Node(data);
          //2.判断是否添加的是第一个节点
          if (this.length === 0) {
            //2.1是第一个节点
            this.head = newNode;
          } else {
            //2.2不是第一个节点
            //找到最后一个节点
            var current = this.head;
            while (current.next) {
              current = current.next;
            }
            //最后节点的next指向新的节点
            current.next = newNode;
          }

          //3.length+1
          this.length += 1;
        };
        //2.toString方法
        LinkedList.prototype.toString = function () {
          //1.定义变量
          var current = this.head;
          var listString = "";
          //2.循环获取一个个的节点
          while (current) {
            listString += current.data + " ";
            current = current.next;
          }
          return listString;
        };
        //3.insert方法
        LinkedList.prototype.insert = function (position, data) {
          //1.对position进行越界判断
          //负数判断，长度判断
          if (position < 0 || position > this.length) return false;

          //2.根据data创建newNode
          var newNode = new Node(data);

          //3.判断插入的位置是否是第一个
          if (position == 0) {
            //让新节点的next指向head的指针,而head的指针真好指向原先的第一个
            newNode.next = this.head;
            //再让head指向新的节点
            this.head = newNode;
            this.length += 1;
          } else {
            var index = 0;
            var current = this.head;
            var previous = null;
            while (index++ < position) {
              previous = current;
              current = current.next;
            }
            newNode.next = current;
            previous.next = newNode;
            this.length += 1;
          }
        };
        //4.get方法
        LinkedList.prototype.get = function (position) {
          //1.对position进行越界判断
          //负数判断，长度判断
          if (position < 0 || position >= this.length) return null;
          //2.获取对应的data
          var current = this.head;
          var index = 0;
          while (index++ < position) {
            current = current.next;
          }
          return current.data;
        };
        //5.indexOf方法
        LinkedList.prototype.indexOf = function (data) {
          //1.定义变量
          var current = this.head;
          var index = 0;
          //2.开始查找
          while (current) {
            if (current.data === data) {
              return index;
            } else {
              current = current.next;
              index += 1;
            }
          }
          //找到最后没有找到，返回-1
          return -1;
        };
        //6.update方法
        LinkedList.prototype.update = function (position, newData) {
          //1.对position进行越界判断
          //负数判断，长度判断
          if (position < 0 || position >= this.length) return false;
          //2.获取对应的data
          var current = this.head;
          var index = 0;
          while (index++ < position) {
            current = current.next;
          }
          //将position位置的data替换成新data
          current.data = newData;
        };
        //7.removeAt方法
        LinkedList.prototype.removeAt = function (position, newData) {
          //1.对position进行越界判断
          //负数判断，长度判断
          if (position < 0 || position >= this.length) return null;
          //2.判断是否删除的是第一个节点
          var current = this.head;
          if (position === 0) {
            this.head = this.head.next;
          } else {
            var index = 0;
            var previous = null;
            while (index++ < position) {
              previous = current;
              current = current.next;
            }
            //让前一个节点的next指向current的next
            previous.next = current.next;
          }

          //3.length-1
          this.length -= 1;
          return current.data;
        };
        //8.remove方法
        LinkedList.prototype.remove = function (data) {
          //1.获取data在列表中的位置
          var position = this.indexOf(data);
          //2.根据位置信息删除节点
          return this.removeAt(position);
        };
        //9.isEmpty方法
        LinkedList.prototype.isEmpty = function () {
          return this.length === 0;
        };
        //10.size方法
        LinkedList.prototype.size = function () {
          return this.length;
        };
      }

var list = new LinkedList();
```





### 4.二叉树

树是一种**分层**数据的抽象模型，在`JavaScript`中没有树这个数据结构，所以通常我们使用`Object`来模拟一个树的结构

树的高度：从根节点到所有叶节点中最大的边的数目。

树的深度：从根节点到所有叶节点中最多的节点数目

二叉树的度是指树中所以结点的度数的最大值。二叉树的度小于等于2，因为二叉树的定义要求二叉树中任意结点的度数（结点的分支数）小于等于2

二叉树**叶子结点**总数为n0，度为2的结点个数为n2，则n0=n2+1

>假设该二叉树总共有n个结点(n=n0+n1+n2)，则该二叉树总共会有n-1条边，度为2的结点会延伸出两条边，
>
>同理，度为1的结点会延伸出一条边，则可列公式：n-1 = 2*n2 + 1*n1 ，
>
>合并两个式子可得：2*n2 + 1*n1 +1 =n0 + n1 + n2 ，则计算可知 n0=n2+1

如果完全二叉树有n个结点，那么树最高为log2(n)+1

简单实现

```js
function TreeNode(val, left, right) {
 	this.val = (val===undefined ? 0 : val)
	this.left = (left===undefined ? null : left)
	this.right = (right===undefined ? null : right)
}
```



```js
     //封装二叉搜索树
      function BinarySearchTree() {
        //节点
        function Node(key) {
          this.key = key;
          this.left = null;
          this.right = null;
        }
        //属性
        this.root = null;
        //方法
        //1.1插入数据
        BinarySearchTree.prototype.insert = function (key) {
          //1.根据key创建节点
          var newNode = new Node(key);

          //2.判断根节点是否有值
          if (this.root == null) {
            this.root = newNode;
          } else {
            this.insertNode(this.root, newNode);
          }
        };
      }
```

深度优先搜索

>树的深度优先遍历即有children就继续遍历children，直到没有children后再遍历下一个结点: 深度优先遍历流程：
>
>1.  访问根结点
>2.  对根结点的children继续深度优先遍历

```js
function des(root) {
  console.log('value', root.value)
  root.children.forEach(item => {
    des(item)
  })
}

des(treeData)
```

广度优先搜索

>广度优先遍历即优先遍历子结点，如果子结点遍历完成，则遍历各子结点的children： 广度优先遍历流程：
>
>创建一个数组，将根结点作为第一项
>将数组中第一项弹出并访问
>将弹出项中的children遍历并依次添加至数组中
>重复2、3步骤直到队列为空

```js
function bfs(root) {
  let arr = [root]

  while(tree = arr.shift()) {
    console.log('value', tree.value)
    tree.children.forEach(item => {
      arr.push(item)
    })
  }
}

bfs(treeData)
```



### 5.堆

堆是一种**特殊的完全二叉树**，堆中的所有所有结点都**大于等于或小于等于**他的子结点，若**大于等于子结点**则为`最大堆`，否则为`最小堆`。在`javaScript`中通常使用数组来表示堆
对于第`i`个结点:
其父结点的索引为：`Math.floor((i - 1) / 2)`
其左子结点的索引为：`(2 * i) + 1`
其右子结点的索引为：`(2 * i) + 2`

上面我们实现了一个简单构建`最小堆`的方法，那么实现堆排序的原理其实就是先构建一个`最小堆`然后将堆顶（最小值弹出），再将其他元素构建堆，每次都弹出`堆顶`元素直到剩余元素为1时结束，这样就是实现了一个堆排序

```js
function MinHeap() {
  this.heap = []

  this.getParentIndex = function (childIndex) {
    return Math.floor((childIndex - 1) / 2)
  }
  /**
   * 交换位置
   * @param {number} index1
   * @param {number} index2
   */
  this.swap = function (index1, index2) {
    const temp = this.heap[index1]
    this.heap[index1] = this.heap[index2]
    this.heap[index2] = temp
  }

  /**
   * 上移到合适位置,和父结点比较，如果比父结点小则交换
   * @param {number} index 索引
   */
  this.moveUp = function (index) {
    if (index === 0) return
    const parentIndex = this.getParentIndex(index)
    if (this.heap[index] < this.heap[parentIndex]) {
      this.swap(index, parentIndex)
      this.moveUp(parentIndex)
    }
  }
  /**
   * 添加元素
   * @param {number} value
   */
  this.append = function (value) {
    this.heap.push(value)
    this.moveUp(this.heap.length - 1)
  }
}

const minHeap = new MinHeap()
minHeap.append(3)
minHeap.append(4)
minHeap.append(1)
minHeap.append(0)
minHeap.append(2)
minHeap.append(7)
minHeap.append(9)
// [0, 1, 3, 4, 2, 7, 9]
```



## [排序算法](https://juejin.cn/post/6844903444365443080#heading-18)

![image-20220713104357499](https://s2.loli.net/2022/07/13/eIf4dkY1cVW7Nlp.png)

### 冒泡排序

一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来

思路如下：

-   比较相邻的元素，如果第一个比第二个大，就交换它们两个

-   对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数

-   针对所有的元素重复以上的步骤，除了最后一个

-   重复上述步骤，直到没有任何一堆数字需要比较

![](https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp)

```js
function bubbleSort1(arr){
 const i=arr.length-1;//初始时,最后位置保持不变  
 while(i>0){
  let pos = 0;//每趟开始时,无记录交换
  for(let j = 0; j < i; j++){
   if(arr[j] > arr[j+1]){
        let tmp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
    pos = j;//记录最后交换的位置  
   }   
  }
  i = pos;//为下一趟排序作准备
 }
 return arr;
}
```

###  选择排序

选择排序是一种简单直观的排序算法，它也是一种交换排序算法

无论什么数据进去都是 `O(n²)`的时间复杂度。所以用到它的时候，数据规模越小越好

唯一的好处是不占用额外的内存存储空间

思路如下：

-   在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
-   从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
-   重复第二步，直到所有元素均排序完毕

![](https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp)

```js
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
```

### 插入排序

插入排序是一种简单直观的排序算法

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

解决思路如下：

-   把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的
-   从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
-   重复上述过程直到最后一个元素被插入有序子数组中

![](https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp)

```js
function insertionSort(arr) {
    const len = arr.length;
    let preIndex, current;
    for (let i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
```

### 归并排序

归并排序是建立在归并操作上的一种有效的排序算法

该算法是采用分治法的一个非常典型的应用

将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序

解决思路如下：

-   申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
-   设定两个指针，最初位置分别为两个已经排序序列的起始位置
-   比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
-   重复步骤3直到某一指针到达序列尾
-   将另一序列剩下的所有元素直接复制到合并序列尾

![](https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg)

```js
function mergeSort(arr) {  // 采用自上而下的递归方法
    const len = arr.length;
    if(len < 2) {
        return arr;
    }
    let middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    const result = [];

    while (left.length && right.length) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
}
```

### 快速排序

快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小

再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列

解决思路如下：

-   从数列中挑出一个元素，称为"基准"（pivot）
-   重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
-   递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序

![](https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.jpg)

```js
function quickSort (arr) {
  const rec = (arr) => {
    if (arr.length <= 1) { return arr; }
    const left = [];
    const right = [];
    const mid = arr[0]; // 基准元素
    for (let i = 1; i < arr.length; i++){
      if (arr[i] < mid) {
        left.push(arr[i]);
      } else {
        right.push(arr[i]);
      }
    }
    return [...rec(left), mid, ...rec(right)]
  }
  return res(arr)
};
```

### 堆排序

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

- 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；大顶堆的一个特性是数据将被从大到小取出，将取出的数字按照相反的顺序进行排列，数字就完成了排序
- 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

堆排序的平均时间复杂度为 Ο(nlogn)。

#### 算法步骤

堆排序的基本思想是：

1、将带排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；

2、将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；

3、重复步骤2，如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个有序的序列了。

```js
var len 
function buildMaxHeap(arr){  //建立大顶堆
	len=arr.length;  //第一个非叶子结点的下标为i=Math.floor(arr.length/2 - 1) 
	for(var i =Math.floor(len/2);i>=0;i--){
		heapify(arr,i) //下标 i 依次减1（即从第一个非叶子结点开始，从右至左，从下至上遍历所有非叶子节点）
	}
}
function heapify(arr,i){//调整堆 以三个数为基础进行比较 父节点 左子节点 右子节点
	let left=2*i+1,  //对于结点 i ，其子结点为 2*i+1 与 2*i+2 
	right=2*i+2,
	largest=i;
	if(left<len&&arr[left]>arr[largest]){
		largest=left
	}
	if(right<len&&arr[right]>arr[largest]){
		largest=right
	}
	if(largest!=i){
		swap(arr,i,largest)
		heapify(arr,largest)
	}
}
function swap(arr,i,j){
	var temp=arr[i]
	arr[i]=arr[j]
	arr[j]=temp
}
function heapSort(arr){
	buildMaxHeap(arr)
	for(var i=arr.length-1;i>0;i--){
		swap(arr,0,i)
		len--
		heapify(arr,0)
	}
	return arr;
}

var arr=[1,3,0,5,2,9,10,11,4]
console.log(heapSort(arr));
```

## 算法思想

### 位运算

平常我们用来计算的是十进制的数值 `0~9` ，但是计算机是个机器，它只能识别二进制

根据国际 IEEE 754 标准，`JavaScript` 在存储数字时是始终以双精度浮点数来存储的，这种格式用 64 位二进制存储数值，64 位也就是 64 比特（bit），相当于 8 个字节，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号

而在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位数值，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以，因为 64 位存储格式是不可见的，但是也正是因为后台这个默认转换操作，给 JS 这门语言产生了一个副作用，即特殊值 NaN 和 Infinity 在位运算中都会直接被当作 0 来处理

`ECMAScript` 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）

在 ECMAScript 中，所有整数字面量默认都是有符号整数

有符号整数也就是上文所说，二进制左侧首位是符号位来表明该数字正负

而无符号整数就是没有符号位，没有了符号位置也就说它表达不了负数，同时因为没有了符号位置，它的存储范围也会比有符号整数存储范围大

位运算符有 7 个，分为两类：

-   逻辑位运算符：位与（&）、位或（|）、位异或（^）、非位（~）
-   移位运算符：左移（<<）、右移（>>）、无符号右移（>>>）


逻辑位运算符与逻辑运算符的运算方式是相同的，但是针对的对象不同。逻辑位运算符针对的是二进制的整数值，而逻辑运算符针对的是非二进制的值。

#### “&”运算符

“&”运算符（位与）用于对两个二进制操作数逐位进行比较，并根据下表所示的换算表返回结果。



| 第一个数的位值 | 第二个数的位值 | 运算结果 |
| -------------- | -------------- | -------- |
| 1              | 1              | 1        |
| 1              | 0              | 0        |
| 0              | 1              | 0        |
| 0              | 0              | 0        |


在位运算中，数值 1 表示 true，0 表示 false，反之亦然。

12 和 5 进行位与运算，则返回值为 4。

```js
console.log(12 & 5);  //返回值4
```


下图以算式的形式解析了 12 和 5 进行位与运算的过程。通过位与运算，只有第 3 位的值为全为 true，故返回 true，其他位均返回 false。



![img](http://c.biancheng.net/uploads/allimg/190827/6-1ZRG5503E94.gif)

##### 使用按位与 & 判断奇偶数

按位与这个东西平常用的不太多，我一般只会在判断奇偶数的才会用到，如下：

```js
偶数 & 1 // 0
奇数 & 1 // 1
```

因为十进制数字 1 的二进制为 `0000 ... 0001`，只有最后一位为 1，其余位都是 0 ，所以任何数字和它对比除最后一位其余都是 0，那么当这个数字末位为 1 时，也就是奇数，那么结果就是 1，这个数字末位为 0 时，也就是偶数，那么结果就是 0，毕竟二进制只有 0 和 1

##### 使用按位与 & 判断数字是否为2的整数幂

判断数字是否为 2 的整数幂，使用 `n & (n - 1)`

```js
let a = 20;
let b = 32;

a & (a - 1) // 16 a不是2的整数幂
b & (b - 1) // 0 	b是2的整数幂
```

如上所示，套用这个小公式，当结果等于 0 时，数值就是 2 的整数幂

其实原理也很简单，首先我们来看数值 2 的幂对应的二进制

```js
0000 0001  -> 1  	// 2^0
0000 0010  -> 2		// 2^1
0000 0100  -> 4		// 2^2
0000 1000  -> 8		// 2^3
0001 0000  -> 16	// 2^4
```

如上，2 的幂在二进制中只有一个 1 后跟一些 0，那么我们在判断一个数字是不是 2 的幂时，用 `n & (n-1)`，如果 你是 2 的幂，n 减 1 之后的二进制就是原来的那一位 1 变成 0，后面的 0 全变成 1，这个时候再和自身做按位与对比时，每一位都不同，所以每一位都是 0，即最终结果为 0



#### “|”运算符

“|”运算符（位或）用于对两个二进制操作数逐位进行比较，并根据如表格所示的换算表返回结果。



| 第一个数的位值 | 第二个数的位值 | 运算结果 |
| -------------- | -------------- | -------- |
| 1              | 1              | 1        |
| 1              | 0              | 1        |
| 0              | 1              | 1        |
| 0              | 0              | 0        |


12 和 5 进行位或运算，则返回值为 13。

```js
console.log(12 | 5);  //返回值13
```


下图以算式的形式解析了 12 和 5 进行位或运算的过程。通过位或运算，除第 2 位的值为 false 外，其他位均返回 true。



![img](http://c.biancheng.net/uploads/allimg/190827/6-1ZRG5594I36.gif)

##### 使用按位或 ｜ 取整

取整的时候我们也可以使用按位或取整

```js
1.111 | 0 // 1
2.234 | 0 // 2
```

如上所示，只需要将小数同 0 进行按位或运算即可

原理也简单，位运算操作的是整数，相当于数值的整数部分和 0 进行按位或运算

0 的二进制全是 0 ，按位或对比时 1 和 0 就是 1 ，0 和 0 就是 0，得出的二进制就是我们要取整数值的整数部分

##### 使用按位或 | 代替Math.round()

我们上面知道按位或可以取整，其实四舍五入也就那么回事了，即正数加 0.5，负数减 0.5 进行按位或取整即可，道理就是这么简单，如下

```js
let a1 = 1.1
let a2 = 1.6
a1 + 0.5 | 0 // 1
a2 + 0.5 | 0 // 2

let b1 = -1.1
let b2 = -1.6
b1 - 0.5 | 0 // -1
b2 - 0.5 | 0 // -2
```



#### “^”运算符

“^”运算符（位异或）用于对两个二进制操作数逐位进行比较，并根据如表格所示的换算表返回结果。



| 第一个数的位值 | 第二个数的位值 | 运算结果 |
| -------------- | -------------- | -------- |
| 1              | 1              | 0        |
| 1              | 0              | 1        |
| 0              | 1              | 1        |
| 0              | 0              | 0        |


12 和 5 进行位异或运算，则返回值为 9。

```js
console.log(12 ^ 5);  //返回值9
```


下图以算式的形式解析了 12 和 5 进行位异或运算的过程。通过位异或运算，第 1、4 位的值为 true，而第 2、3 位的值为 false。



![img](http://c.biancheng.net/uploads/allimg/190827/6-1ZRG63913W0.gif)

##### 使用按位异或 ^ 判断整数部分是否相等

按位异或可以用来判断两个整数是否相等，如下

```js
let a = 1
let b = 1
a ^ b // 0

1 ^ 1 // 0
2 ^ 2 // 0
3 ^ 3 // 0
```

这是因为按位异或只在一位是 1 时返回 1，两位都是 1 或者两位都是 0 都返回 0，两个相同的数字二进制都是一致的，所以都是 0

我们也可以用作判断两个小数的整数部分是否相等，如下

```js
2.1 ^ 2.5 // 0
2.2 ^ 2.6 // 0
2.1 ^ 3.1 // 1
```

这是为什么？牢记位运算操作的是整数、是整数、是整数，也就是说上面这几个对比完全可以理解为同下

```js
2 ^ 2 // 0
2 ^ 2 // 0
2 ^ 3 // 1
```

##### 使用按位异或 ^ 来完成值交换

我们也可以使用按位异或来进行两个变量的值交换，如下

```js
let a = 1
let b = 2
a ^= b
b ^= a
a ^= b
console.log(a)   // 2
console.log(b)   // 1
```

道理也很简单，我们先要了解一个东西

```js
// 如果
a ^ b = c
// 那么
c ^ b = a
c ^ a = b
```

现在你再品一下值交换为什么可以交换，细品

不过这里使用 `^` 来做值交换不如用 ES6 的解构，因为 ES6 解构更方便易懂

##### 使用按位异或 ^ 切换 0 和 1

切换 0 和 1，即当变量等于 0 时，将它变成 1，当变量等于 1 时，将它变成 0

常用于 `toggle `开关状态切换，做开关状态更改时，普通小伙伴会如下这样做

```js
let toggle = 0

if(toggle){
  toggle = 0
}else{
  toggle = 1
}
```

聪明点的小伙伴会用三目运算符

```js
let toggle = 0

toggle = toggle ? 0 : 1
```

使用按位异或更简单

```js
let toggle = 0

toggle ^= 1
```

原理也简单， `toggle ^= 1` 等同于 `toggle = toggle ^ 1`，我们知道 `0 ^ 1` 等于 1，而 `1 ^ 1` 则为 0

##### 使用按位异或 ^ 判断两数符号是否相同

我们可以使用 `(a ^ b) >= 0` 来判断两个数字符号是否相同，也就是说同为正或同为负

```js
let a = 1
let b = 2
let c = -2

(a ^ b) >= 0 // true
(a ^ c) >= 0 // false
```

原理也简单，正数二进制左首位也就是符号位是 0，而负数则是 1

按位异或在对比时，只有一正一负时才为 1，两位都是 0 或者都是 1 时结果为 0

所以，两个数值符号一样时按位异或对比后的二进制结果符号位肯定是 0，最终数值也就是 `>=0`，反之则 `<0`

#### “~”运算符

“~”运算符（位非）用于对一个二进制操作数逐位进行取反操作。

-   第 1 步：把运算数转换为 32 位的二进制整数。
-   第 2 步：逐位进行取反操作。
-   第 3 步：把二进制反码转换为十进制浮点数。

反码是符号位不变其余位置取反，而按位非则是取反码后符号位也取反


对 12 进行位非运算，则返回值为 -13。

```js
console.log( ~ 12 );  //返回值-13
```


下图以算式的形式解析了对 12 进行位非运算的过程。



![img](http://c.biancheng.net/uploads/allimg/190827/6-1ZRG64625624.gif)


位非运算实际上就是对数字进行取负运算，再减 1。例如：

```
console.log( ~ 12 == 12-1);  //返回true
```

和 `(-x) - 1` 是一致的，那么为什么还要用按位非呢

很简单，原因有二，第一是位运算的操作是在数值底层表示上完成的，速度快。第二是因为它只用 2 个字符，比较方便

##### 使用按位非 ~ 判断是否等于-1

```js
let str = "abcdefg"

if(!~str.indexOf("n")){
	console.log("字符串 str 中不存在字符 n")
}

// 等同于

if(str.indexOf("n") == "-1"){
  console.log("字符串 str 中不存在字符 n")
}
```

>indexOf` 方法在找不到相同值时返回 -1，而 `~-1 == 0 == false` ，所以 `!~-1 == 1 == true

##### 使用按位非 ~ 取整

按位非的骚操作中，还有一个比较普遍的就是位运算双非取整了，如下所示

```js
~~3.14 == 3
```

很多人知道这样可以取整，但是由于不知道具体是为什么而不敢用，所以我们来解释下为什么它为什么可以取整

上面我们说过，在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位整数，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以

这里我们可以看到，32 位 `整数`，位运算操作的是整数，后台在进行 64 位到 32 位转换时，会忽略掉小数部分，只关注整数、整数、整数，记住了

```js
~3.14 == ~3
~5.89 == ~5
```

如上所示，接着我们再按照上面的公式

```js
~x == (-x) - 1

~~x == -((-x) - 1) -1 == -(-x) + 1 -1 == x
```

所以位运算中的双非 `~~` 即可取整，此取整是完全忽略小数部分

#### 左移（<<）

##### 简述

左移用符号 `<<` 来表示，正如它的名字，即将数值的二进制码按照指定的位数向左移动，符号位不变

**例如： **

求 `2 << 5`，即求十进制数 2 左移 5 位的操作

我们先将十进制数字 2 转二进制再左移 5 位后如下图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812a3ec24515437ea46e32d469dbe3d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

我们得到了一个新的二进制，转为 10 进制即为数值 64

数字 x 左移 y 位我们其实可以得到一个公式，如下

```js
x << y 

// 等同于

x * 2^y
```

##### 使用左移 << 取整

使用左移也可取整

```js
1.111 << 0 // 1
2.344 << 0 // 2
```

原理是位运算操作的是整数，忽略小数部分，等同于数值的整数部分，左移 0 位，结果还是整数部分

#### 有符号右移（>>）

##### 简述

有符号右移用符号 `>>` 来表示，即将数值的二进制码按照指定的位数向右移动，符号位不变，它和左移相反

**例如：**

求 `64 >> 5`，即求十进制数 64 有符号右移 5 位的操作

我们先将十进制数字 64 转二进制再右移 5 位后如下图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdd4f6d57ebd46c7afb70af671a5d557~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

有符号右移时移动数位后会同样也会造成空位，空位位于数字的左侧，但位于符号位之后，`ECMAScript` 中用符号位的值填充这些空位

随后，我们就得到了一个新的二进制，转为 10 进制即为数值 2，其实就是左移的逆运算

同样，数字 x 有符号右移 y 位我们也可以得到一个公式，如下

```js
x >> y 

// 等同于

x / 2^y
```

##### 使用右移 >> 取整

使用右移和左移一样都可以取整

```js
1.111 >> 0 // 1
2.344 >> 0 // 2
```

原理还是那一个，位运算操作的是整数，忽略小数部分，等同于数值的整数部分，右移 0 位，结果还是整数部分

#### 无符号右移（>>>）

##### 简述

无符号右移使用 `>>>` 表示，和有符号右移区别就是它是三个大于号，它会将数值的所有 32 位字符都右移

对于正数，无符号右移会给空位都补 0 ，不管符号位是什么，这样的话正数的有符号右移和无符号右移结果都是一致的

负数就不一样了，当把一个负数进行无符号右移时也就是说把负数的二进制码包括符号为全部右移，向右被移出的位被丢弃，左侧用0填充，由于符号位变成了 0，所以结果总是非负的

那么可能就有人要问了，如果一个负数无符号右移 0 位呢，我们可以测试一下

让十进制 -1 进行无符号右移 0 位

-1 是负数，在内存中二进制存储是补码即 `1111 .... 1111 1111`，32 位都是 1，我们在程序中写入 `-1 >>> 0` 运行得到十进制数字 `4294967295` ，再使用二进制转换工具转为二进制得到的就是 32 位二进制 `1111 .... 1111 1111`，所以就算无符号右移 0 位，得出的依然是一个很大的正数

##### 使用无符号右移 >>> 取整（正数）

无符号右移和有符号右移以及左移都差不多，移 0 位都可取整，只不过无符号右移只能支持正数的取整，至于原理，说过无数遍了，相信你已经记住了，如下

```js
1.323 >>> 0 // 1
2.324 >>> 0 // 2
```



### 位图法

可以解决海量数据的存在性问题，又不占用很多内存的前提下。

**位图法的原理主要就是利用int类型数据，一个int类型数据是4个字节，一个字节8位，然后一个int数据利用自身字节位就可以表示0-31的数是否存在，bit位表示数值，位山0，1值表示这个数值是否存在。**

**所有的int类型数据一共有**2^32/8 = 2^29 Byte约等于512MB（2^10=1KB 2^20 =1MB 2^30=1GB）表示所有的int类型数需要512MB，现在的计算机完全可以胜任，这些可以表示多少位数呢就是一个int可以表示32个数，32*2^32=2^37约等于10^11百亿级别；

**具体方案**

那么接下来我们只需要申请一个int数组长度为 int tmp[N/32+1]即可存储完这些数据，其中N代表要进行查找的总数（这里也就是2^32），tmp中的每个元素在内存在占32位可以对应表示十进制数0~31,所以可得到BitMap表:

tmp[0]:可表示0~31

tmp[1]:可表示32~63

tmp[2]可表示64~95

~~

假设这10亿int数据为：6,3,8,32,36,……，那么具体的BitMap表示为：





![img](https:////upload-images.jianshu.io/upload_images/23201985-049460b486f67d10.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/702/format/webp)



**使用如何快速查找具体的是否存在：**

(1). 如何判断int数字放在哪一个tmp数组中：将数字直接除以32取整数部分(x/32)，例如：整数8除以32取整等于0，那么8就在tmp[0]上；

(2). 如何确定数字放在32个位中的哪个位：将数字mod32取模(x%32)。上例中我们如何确定8在tmp[0]中的32个位中的哪个位，这种情况直接mod上32就ok，又如整数8，在tmp[0]中的第8 mod上32等于8，那么整数8就在tmp[0]中的第八个bit位（从右边数起）。

**对于多次出现的数据处理方法**

然后我们怎么统计只出现一次的数呢？每一个数出现的情况我们可以分为三种：0次、1次、大于1次。也就是说我们需要用2个bit位才能表示每个数的出现情况。此时则三种情况分别对应的bit位表示是：00、01、11

我们顺序扫描这10亿的数，在对应的双bit位上标记该数出现的次数。最后取出所有双bit位为01的int型数就可以了。

## 输入输出练习

### 常用数据结构

#### 一维数组

c++

```c++
int arr=[n]
vector<int> dp(n)
```

javascript

```js
const arr=[]
const arr=Array(n)
const arr=new Array(n)
const arr= Array(n).fill(0)
```

#### 二维数组

##### c++

```c++
vector<vector<int>> dp(n,vector<int>(m))  
n*m可扩展二维数组   长度可以直接扩展
```

##### javascript

推荐使用

`const dp=Array(m+1).fill().map(()=>Array(n+1).fill(0))`

`const dp=[]  dp.push([])`

```js
const dp = new Array(n).fill([0,0])
const dp = Array.from(Array(n), () => Array(n).fill(0));
const dp = new Array(word1.length + 1).fill(0)
        .map(() => new Array(word2.length + 1).fill(0))

const dp = Array(m + 1).fill()  //fill()必需有
        .map(() =>Array(n + 1).fill(0))
const dp=[]  dp.push([])
```

#### 哈希表（Map)

举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：

```js
var names = ['Michael', 'Bob', 'Tracy'];
var scores = [95, 75, 85];
```

给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。

如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。

用JavaScript写一个Map如下：

```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：

```js
var m = new Map(); // 空Map
m.set('Adam', 67); // 添加新的key-value
m.set('Bob', 59);
m.has('Adam'); // 是否存在key 'Adam': true
m.get('Adam'); // 67
m.delete('Adam'); // 删除key 'Adam'
m.get('Adam'); // undefined
```

由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

```js
var m = new Map();
m.set('Adam', 67);
m.set('Adam', 88);
m.get('Adam'); // 88
```

#### 集合(Set)

Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。

要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
```

重复元素在Set中自动被过滤：

```js
var s = new Set([1, 2, 3, 3, '3']);
s; // Set {1, 2, 3, "3"}
```

通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：

```js
s.add(4);
s; // Set {1, 2, 3, 4}
s.add(4);
s; // 仍然是 Set {1, 2, 3, 4}
```

通过delete(key)方法可以删除元素：

```js
var s = new Set([1, 2, 3]);
s; // Set {1, 2, 3}
s.delete(3);
s; // Set {1, 2}
```

#### 链表

```js
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
 }
```

#### 二叉树

```js
function TreeNode(val, left, right) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
 }
```

### 基本输入

牛客网v8模式是readline()

赛码网v8模式是read_line()

node模式通用模板

```js
let buf='';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
				line=line.split(' ')		
    })
});
```

### 单行输入

#### 两数相加

js

注意问题   **输入得到的字符串  需要进行去除空格转换成字符数组**  然后再进行parseInt

**技巧**   对于多个数组可以考虑 **arr.map((item)=>item*1)**  **不必每个都parseInt()**  (四则运算中只有加法会影响 字符串和数字的运算 str*1会优先转换成数字)

##### v8模式

```js
var line;
while(line = read_line()){
    line = line.split(' ');
    print(parseInt(line[0]) + parseInt(line[1]));
}
```

##### node模式

```js
var readline = require('readline');
const reader = readline.createInterface({
	input: process.stdin,
	output: process.stdout
});
reader.on('line', function (line) {
	var tokens = line.split(' ');
	console.log(parseInt(tokens[0]) + parseInt(tokens[1]));
});
```

可以直接 `+tokens[0]`转成数字  或者`1*tokens[0]`

`console.log()`本身就换行

换行  `console.log(a+'\n')`

### 固定行输入

例如输入

3 

1 2
3 4
5 6

表示

输入三个数组

##### v8模式

```js
var line =read_line();
line=line.split(' ');
var m=parseInt(line[0])
var n=parseInt(line[1])
console.log(m)
console.log(n)
var a=[],b=[];
while(m--){
    var sum=read_line();
    sum=sum.split(' ');
    var x=parseInt(sum[0]);
    var y=parseInt(sum[1]);
    a.push(x);
    b.push(y);
}
console.log(a)
console.log(b)
```

##### node模式 模板

```js
let buf='';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
let getInputNums = line => line.split(' ').filter(s => s !== '').map(x => parseInt(x));
let getInputStr = line => line.split(' ').filter(s => s !== '');
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
         if (lineIdx === 0) {
            n = getInputNums(line)[0];
            m = getInputNums(line)[1];
        } else if (lineIdx <= n) {
            let a = getInputNums(line)[0];
            let b = getInputNums(line)[1];
            v[lineIdx] = a;
            w[lineIdx] = b;
          if(lineIdx===n) console.log(func(v,w,n,m))
    })
});
func(v,w,n,m)
```

##### 输入二维数组

输入

```
3 
1 2 3
4 5 6
7 8 9
```

```js
var line=readline()
line=line.split(' ')
var n=parseInt(line[0])
var q=parseInt(line[1])
var dp=Array(n+1).fill().map(()=>Array(n+1).fill(0))
for(let i=0;i<n;i++){
	var row = readline()
	row = row.split(' ')
	dp.push(row)  //直接按行进行push
}
```

##### **结构**

-   接受输入
-   处理字符串数据
-   处理输入
-   传入参数，接受算法函数返回结果
-   编写算法函数

##### 完全背包

输入

```js
4 5
1 2
2 4
3 4
4 5
```

```js
const N = 1010;


let v = new Int32Array(N);
let w = new Int32Array(N);
let f = [];
let init = n => {
    for (let i = 0; i <= n; i++) {
        f[i] = new Int32Array(N);
    }
}
let n = 0;
let buf = '';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
let getInputNums = line => line.split(' ').filter(s => s !== '').map(x => parseInt(x));
let getInputStr = line => line.split(' ').filter(s => s !== '');
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
        if (lineIdx === 0) {
            n = getInputNums(line)[0];
            m = getInputNums(line)[1];
            init(n);
        } else if (lineIdx <= n) {
            let a = getInputNums(line)[0];
            let b = getInputNums(line)[1];
            v[lineIdx] = a;
            w[lineIdx] = b;
            if (lineIdx === n) {
                for (let i = 1; i <= n; i++) { //件数
                    for (let j = 0; j <= m; j++) { //体积
                        f[i][j] = f[i - 1][j];
                        if (j >= v[i]) f[i][j] = Math.max(f[i][j], f[i][j - v[i]] + w[i]);
                    }
                }
                console.log(f[n][m]);
            }
        }
    });
});
```

##### 合并区间

输入

```js
5
1 2
2 4
5 6
7 8
7 9
```

```js
let inputRanges = [];

let getRangeCount = (ranges) => {
    ranges.sort((a, b) => a[0] - b[0]);
    let result = 1;
    let curr = ranges[0];
    for (let i = 1; i < ranges.length; i++) {
        if (ranges[i][0] <= curr[1])
            curr[1] = Math.max(curr[1], ranges[i][1]);
        else {
            result++;
            curr = ranges[i++];
        }
    }
    return result;
}
let buf = '';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
let getInputArgs = line =>
    line.split(' ').filter(s => s !== '').map(x => parseInt(x));
process.stdin.on('end', function () {
    let n = 0;
    buf.split('\n').forEach(function (line, lineIdx) {
        if (lineIdx === 0) {
            let a = getInputArgs(line);
            n = a[0];
        } else if (lineIdx <= n) {
            inputRanges.push(getInputArgs(line));
            if (lineIdx === n)
                console.log(getRangeCount(inputRanges));
        }
    });
});
```

##### 最长上升子序列

输入

```js
7
3 1 2 1 8 5 6
```

```js
const N = 1010;
let arr = [];
let f = new Int32Array(N).fill(1);  //最长序列只有自己一个数
let a = new Int32Array(N);

let n = 0;

let buf = '';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
let getInputNums = line => line.split(' ').filter(s => s !== '').map(x => parseInt(x));
let getInputStr = line => line.split(' ').filter(s => s !== '');
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
        if (lineIdx === 0) {
            n = getInputNums(line)[0];
        } else if (lineIdx === 1) {
            arr = getInputStr(line);
            for (let i = 0; i < arr.length; i++) a[i + 1] = arr[i];
            for (let i = 1; i <= n; i++) {
                for (let j = 1; j < i; j++)
                    if (a[j] < a[i])
                        f[i] = Math.max(f[i], f[j] + 1);
            }
            let res = 0;
            for (let i = 1; i <= n; i++) res = Math.max(res, f[i]);
            console.log(res);
        }
    });
});
```



### 不定行数输入字符串(无限输入)

#### 输入多个字符串进行正则匹配

##### v8模式

```js
var line;
var reg=/^(?=.*[0-9])(?=.*[a-zA-Z])(?=.*[^a-zA-Z0-9]).{8,}$/
while(line=read_line()){
  var ans=reg.test(line)
  if(ans) console.log('ok')
  else console.log('false')
}
```

##### node模式  

```js
let buf='';
process.stdin.on('readable', function () {
    let chunk = process.stdin.read();
    if (chunk) buf += chunk.toString();
});
process.stdin.on('end', function () {
    buf.split('\n').forEach(function (line, lineIdx) {
       if(line){
      var ans=reg.test(line)
      if(ans) console.log('ok')
      else console.log('false') 
        }
    })
});
```

##### c++模式

万能头文件

`#include<bits/stdc++.h>`

```c++
#include<iostream>
#include<regex>
using namespace std;
int main()
{	string str
	regex  reg("^(?=.*[0-9])(?=.*[a-zA-Z])(?=.*[^a-zA-Z0-9]).{8,}$");
	while(cin>>str){
	smatch result;
	bool ret = regex_match(str, result, reg);
	cout << (ret ? "合适" : "不合适") << endl;
	}
}
```

### c++ stl使用

[算法竞赛C++ STL详解（容器、算法、迭代器）](https://blog.csdn.net/m0_51755720/article/details/120616163)

#### STL六大组件是什么?

STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是容器、算法、迭代器、仿函数、适配器、空间配置器。其中，在算法竞赛中用到最多的为**容器、算法与迭代器**。

- 容器(`Container`)：STL容器为各种**数据结构**，如`vector`、`stack`、`queue`、`map`、`set`等，用来存放数据，从实现角度来看，STL容器是一种`class template`。
- 算法(`Algorithm`)：STL的算法多数定义在`<algorithm>`头文件中，其中包括了各种常用的算法，如`sort`、`find`、`copy`、`reverse`等，从实现角度来看，STL算法是一种`function template`。
- 迭代器(`Iterator`)：STL迭代器扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将`opetator*`、`opetator->`、`operator++`等指针相关操作予以重载的`class template`。所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。
- 仿函数(`Functor`)：行为类似函数，可作为算法的某种策略，从实现角度来看，仿函数是一种重载了`operator()`的`class`或者`class template`。
- 适配器(`Adaptor`)：一种用来修饰容器或仿函数或迭代器接口的东西。
- 空间配置器(`Allocator`)：负责空间的配置与管理。从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的`class template`。

#### STL容器详解

① `vector`：又称`变长数组`，定义在`<vector>`头文件中，`vector`容器是**动态空间**，随着元素的加入，它的内部机制会自动扩充空间以容纳新的元素。因此`vector`的运用对于内存的合理利用与运用的灵活性有很大的帮助。

-   `vector`的定义方式

```c++
vector<int> v;//定义一个vector，其中的元素为int类型
vector<int> v[N];//定义一个vector数组，其中有N个vector
vector<int> v(len);//定义一个长度为len的vector
vector<int> v(len, x);//定义一个长度为len的vector，初始化每个元素为x
vector<int> v2(v1);//用v1给v2赋值，v1的类型为vector
vector<int> v2(v1.begin(), v1.begin() + 3);//将v1中第0~2三个元素赋值给v2
```

-   `vector`的常用内置函数

```c++
    //vector中的常用内置函数
vector<int> v = { 1, 2, 3 };//初始化vector，v:{1, 2, 3}
vector<int>::iterator it = v.begin();//定义vector的迭代器，指向begin()

v.push_back(4);//在vector的尾部插入元素4，v:{1, 2, 3, 4}
v.pop_back();//删除vector的最后一个元素，v:{1, 2, 3}
//注意使用lower_bound()与upper_bound()函数时vector必须是有序的，upper_bound()在<algorithm>中
lower_bound(v.begin(), v.end(), 2);//返回第一个大于等于2的元素的迭代器v.begin() + 1，若不存在则返回v.end()
upper_bound(v.begin(), v.end(), 2);//返回第一个大于2的元素的迭代器v.begin() + 2，若不存在则返回v.end()
v.size();//返回vector中元素的个数
v.empty();//返回vector是否为空，若为空则返回true否则返回false
v.front();//返回vector中的第一个元素
v.back();//返回vector中的最后一个元素
v.begin();//返回vector第一个元素的迭代器
v.end();//返回vector最后一个元素后一个位置的迭代器
v.clear();//清空vector
v.erase(v.begin());//删除迭代器it所指向的元素，即删除第一个元素
v.erase(v.begin(), v.begin() + 2);//删除区间[v.begin(), v.begin() + 2)的所有元素
v.insert(v.begin(), 1);//在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器

//根据下标进行遍历
for (int i = 0; i < v.size(); i++)
cout << v[i] << ' ';
//使用迭代器遍历
for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
cout << *it << ' ';
//for_each遍历(C++11)
for (auto x : v)
cout << x << ' ';
```

②`stack`：又称`栈`，是一种**后进先出**(`Last In First Out，LIFO`)的数据结构，定义在`<stack>`头文件中，`stack`容器允许新增元素、移除元素、取得栈顶元素，但是除了最顶端以外，没有任何方法可以存取`stack`的其它元素，换言之，`stack`**不允许有遍历行为**。

-   `stack`的定义方式

```c++
    stack<int> stk;//定义一个stack，其中元素的类型为int
    stack<int> stk[N];//定义一个stack数组，其中有N个stack
```

-   `stack`的常用内置函数

```c++
    //stack中的常用内置函数
    stack<int> stk;
stk.push(x);//在stack中插入元素x
stk.pop();//弹出stack的栈顶元素
stk.top();//返回stack的栈顶元素
stk.size();//返回stack中元素的个数
stk.empty();//返回stack是否为空，若为空则返回true否则返回false
```

③`string`：又称字符串，定义在`<string>`头文件中。C风格的字符串(以空字符结尾的字符数组)太过复杂难于掌握，因此C++标准库定义了一种`string`类。`string`和`vector<char>`在数据结构、内存管理等方面都是相同的。但是，`vector<char>`只是单纯的一个“ c h a r char char元素的容器”，而`string`不仅是一个“ c h a r char char元素的容器”，它还扩展了一些针对字符串的操作，例如`string`可以使用`c_str()`函数转换为C风格的字符串， `vector`中并未对输入输出流操作符进行重载，因此无法直接对`vector<char>`进行 c i n cin cin或者 c o u t cout cout这样的操作，但是`string`可以，`vector<char>`并不能直接实现字符串的拼接，但是`string`可以，`string`中重载了 + , + = +,+= +,+\=运算符。

-   `string`的定义方式

```c++
string str;//定义一个空的字符串
string str[N];//定义一个string数组，其中有N个string
string str(5, 'a');//使用5个字符'a'初始化
string str("abc");//使用字符串初始化
```

-   `string`的常用内置函数

```c++
    //string中的常用内置函数
    string str("abcabc");
str.push_back('d');//在string尾部插入字符，"abcabcd"
str.pop_back();//删除string尾部的字符，"abcabc"
str.length();//返回string中字符的个数
str.size();//作用与length()相同
str.empty();//返回string是否为空，若为空返回true否则返回false
str.substr(1);//返回string中从下标为1开始至末尾的子串，"bcabc"
str.substr(0, 2);//返回string中从下标为0开始长度为2的子串，"ab"
str.insert(1, 2, 'x');//在下标为1的字符前插入2个字符'x'，"axxbcabc"
str.insert(1, "yy");//在下标为1的字符前插入字符串"yy"，"ayyxxbcabc"
str.erase(1, 4);//删除从位置1开始的4个字符，"abcabc"
str.find('b');//返回字符'b'在string中第一次出现的位置，返回1，若不存在则返回-1
str.find('b', 2);//返回从位置2开始字符'b'在string中第一次出现的位置，返回4
str.find("bc");//同上，返回字符串第一次出现的位置，返回1，若不存在则返回-1
str.find("bc", 2);//返回4
str.rfind('b');//反向查找，原理同上，返回4，若不存在则返回-1
str.rfind('b', 3);//返回1
str.rfind("bc");//返回4，若不存在则返回-1
str.rfind("bc", 3);//返回1
stoi(str);//返回str的整数形式
to_string(value);//返回value的字符串形式，value为整型、浮点型等
str[0];//用下标访问string中的字符
cout << (str == str) << endl;//string可比较大小，按字典序
```

-   `string`的`erase()`与`remove()`函数的用法

```c++
    //string中erase()与remove()的用法
string str1, str2, str3, str4, str5;
str1 = str2 = str3 = str4 = str5 = "I love AcWing! It's very funny!";
str1.erase(15);//删除[15,end())的所有元素，"I love AcWing!"
str2.erase(6, 11);//从第6个元素(包括)开始往后删除11个元素，"I love's very funny!"
str3.erase(str3.begin() + 2);//删除迭代器所指的元素，"I ove AcWing! It's very funny!"
str4.erase(str4.begin() + 7, str4.end() - 11);//删除[str4.begin()+7,str4.end()-11)的所有元素，"I love very funny!"
str5.erase(remove(str5.begin(), str5.end(), 'n'), str5.end());//删除[str5.begin(),str5.end())中所有字符'n'，"I love AcWig! It's very fuy!"
```

④`queue`：又称`队列`，是一种**先进先出**(`First In First Out，FIFO`)的数据结构，定义在`<queue>`头文件中，`queue`容器允许从一端(称为`队尾`)新增元素(`入队`)，从另一端(称为`队头`)移除元素(`出队`)。  
⑤`priority_queue`：又称`优先队列`，同样定义在`<queue>`头文件中，与`queue`不同的地方在于我们可以自定义其中数据的优先级，优先级高的排在队列前面，优先出队。`priority_queue`具有`queue`的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它的本质是用`堆`实现的，因此可分为`小根堆`与`大根堆`，`小根堆`中较小的元素排在前面，`大根堆`中较大的元素排在前面。**注意：创建`priority_queue`时默认是`大根堆`！**

-   `queue`的定义方式

```c++
queue<int> que;//定义一个queue，其中元素的类型为int
queue<int> que[N];//定义一个queue数组，其中有N个queue
priority_queue<int> bigHeap;//定义一个大根堆
priority_queue<int, vector<int>, greater<int> > smallHeap;//定义一个小根堆
```

-   `queue`的常用内置函数

```c++
    //queue中的常用内置函数
    queue<int> que;
    que.push(x);//在queue的队尾插入元素x
que.pop();//出队queue的队头元素
que.front();//返回queue的队头元素
que.back();//返回queue的队尾元素
que.size();//返回queue中元素的个数
que.empty();//返回queue是否为空，若为空则返回true否则返回false
```

⑥`deque`：又称`双端队列`，定义在`<deque>`头文件中，`vector`容器是单向开口的连续内存空间，`deque`则是一种**双向开口的连续线性空间**。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，`vector`也可以在头尾两端插入元素，但是在其头部进行插入操作效率奇差，无法被接受。`deque`和`vector`最大的差异一是在于`deque`允许使用常数项时间在头部进行元素的插入和删除操作，二是在于`deque`没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。

-   `deque`的定义方式

```c++
deque<int> deq;//定义一个deque，其中的元素为int类型
deque<int> deq[N];//定义一个deque数组，其中有N个deque
deque<int> deq(len);//定义一个长度为len的deque
deque<int> deq(len, x);//定义一个长度为len的deque，初始化每个元素为x
deque<int> deq2(deq1);//用deq1给v2赋值，deq2的类型为deque
deque<int> deq2(deq1.begin(), deq1.begin() + 3);//将deq1中第0~2三个元素赋值给deq2
```

-   `deque`的常用内置函数

```c++
    //deque中的常用内置函数
    deque<int> deq = { 1, 2, 3 };//初始化vector，v:{1, 2, 3}
deque<int>::iterator it = deq.begin();//定义vector的迭代器，指向begin()

deq.push_back(4);//在deque的尾部插入元素4，v:{1, 2, 3, 4}
deq.pop_back();//删除deque的尾部元素，v:{1, 2, 3}
deq.push_front(4);//在deque的头部插入元素4，v:{4, 1, 2, 3}
deq.pop_front();//删除deque的头部元素，v:{1, 2, 3}
deq.size();//返回deque中元素的个数
deq.empty();//返回deque是否为空，若为空则返回true否则返回false
deq.front();//返回deque中的第一个元素
deq.back();//返回deque中的最后一个元素
deq.begin();//返回deque第一个元素的迭代器
deq.end();//返回deque最后一个元素后一个位置的迭代器
deq.clear();//清空deque
deq.erase(deq.begin());//删除迭代器it所指向的元素，即删除第一个元素
deq.erase(deq.begin(), deq.begin() + 2);//删除区间[v.begin(), v.begin() + 2)的所有元素
deq.insert(deq.begin(), 1);//在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器

//根据下标进行遍历
for (int i = 0; i < deq.size(); i++)
cout << deq[i] << ' ';
//使用迭代器遍历
for (deque<int>::iterator it = deq.begin(); it != deq.end(); it++)
cout << *it << ' ';
//for_each遍历(C++11)
for (auto x : deq)
cout << x << ' ';
```

⑦`map/multimap`：又称`映射`，定义在`<map>`头文件中，`map`和`multimap`的底层实现机制都是红黑树。`map`的功能是**能够将任意类型的元素映射到另一个任意类型的元素上**，并且所有的元素都会根据元素的键值自动排序。`map`所有的元素都是`pair`，同时拥有`实值`和`键值`，`pair`的第一元素被视为`键值`，第二元素被视为`实值`，`map`不允许两个元素有相同的键值。`multimap`和`map`的操作类似，唯一区别是`multimap`的键值允许重复。

-   `map/multimap`的定义方式

```c++
map<string, int> mp;//定义一个将string映射成int的map
map<string, int> mp[N];//定义一个map数组，其中有N个map
multimap<string, int> mulmp;//定义一个将string映射成int的multimap
multimap<string, int> mulmp[N];//定义一个multimap数组，其中有N个multimap
```

-   `map/multimap`的常用内置函数

```c++
    //map/multimap中的常用内置函数
    map<string, int> mp;
mp["abc"] = 3;//将"abc"映射到3
mp["ab"]++;//将"ab"所映射的整数++
mp.insert(make_pair("cd", 2));//插入元素
mp.insert({ "ef", 5 });//同上
mp.size();//返回map中元素的个数
mp.empty();//返回map是否为空，若为空返回true否则返回false
mp.clear();//清空map
mp.erase("ef");//清除元素{"ef", 5}
mp["abc"];//返回"abc"映射的值
mp.begin();//返回map第一个元素的迭代器
mp.end();//返回map最后一个元素后一个位置的迭代器
mp.find("ab");//返回第一个键值为"ab"的迭代器，若不存在则返回mp.end()
mp.find({ "abc", 3 });//返回元素{"abc", 3}的迭代器，若不存在则返回mp.end()
mp.count("abc");//返回第一个键值为"abc"的元素数量1，由于map元素不能重复因此count返回值只有0或1
mp.count({ "abc", 2 });//返回第一个键值为"abc"的元素数量1，注意和find不一样，count只判断第一个键值
mp.lower_bound("abc");//返回第一个键值大于等于"abc"的元素的迭代器，{"abc", 3}
mp.upper_bound("abc");//返回第一个键值大于"abc"的元素的迭代器，{"cd", 2}

//使用迭代器遍历
for (map<string, int>::iterator it = mp.begin(); it != mp.end(); it++)
cout << (*it).first << ' ' << (*it).second << endl;
//for_each遍历(C++11)
for (auto x : mp)
cout << x.first << ' ' << x.second << endl;
//扩展推断范围的for_each遍历(C++17)
for (auto &[k, v] : mp)
cout << k << ' ' << v << endl;
```

⑧`set/multiset`：又称`集合`，定义在`<set>`头文件中。`set`的特性是所有元素都会根据元素的键值自动被排序，`set`的元素不像`map`那样可以同时拥有`实值`和`键值`，`set`的元素既是`键值`又是`实值`，`set`不允许两个元素有相同的键值，因此总结来说就是`set`中的元素是**有序且不重复的**。`multiset`的特性和用法和`set`完全相同，唯一的区别在于`multiset`允许有重复元素，`set`和`multiset`的底层实现都是红黑树。

-   `set/multiset`的定义方式

```c++
set<int> st;//定义一个set，其中的元素类型为int
set<int> st[N];//定义一个set数组，其中有N个set
multiset<int> mulst;//定义一个multiset
multiset<int> mulst[N];//定义一个multiset数组，其中有N个multiset
```

-   `set/multiset`的常用内置函数

```c++
    //set/multiset中的常用内置函数
set<int> st;
st.insert(5);//插入元素5
st.insert(6);//同上
st.insert(7);//同上
st.size();//返回set中元素的个数
st.empty();//返回set是否为空，若为空返回true否则返回false
st.erase(6);//清除元素6
st.begin();//返回set第一个元素的迭代器
st.end();//返回set最后一个元素后一个位置的迭代器
st.clear();//清空set
st.find(5);//返回元素5的迭代器，若不存在则返回st.end()
st.count(5);//返回元素5的个数1，由于set元素不会重复，因此count返回值只有0或1
st.lower_bound(5);//返回第一个键值大于等于5的元素的迭代器，返回元素5的迭代器
st.upper_bound(5);//返回第一个键值大于5的元素的迭代器，返回元素7的迭代器

//使用迭代器遍历
for (set<int>::iterator it = st.begin(); it != st.end(); it++)
cout << (*it) << ' ';
//for_each遍历(C++11)
for (auto x : st)
cout << x << ' ';
```

⑨`unordered_map/unordered_set`：分别定义在`<unordered_map>`与`<unordered_set>`头文件中，内部采用的是`hash`表结构，拥有快速检索的功能。与`map/set`相比最大的区别在于`unordered_map/unordered_set`中的元素是**无序**的，增删改查的时间复杂度为`O(1)`(`map/set`增删改查的时间复杂度为`O(logn)`)，但是不支持`lower_bound()/upper_bound()`函数。

-   `unordered_map/unordered_set`的定义方式

```c++
unordered_set<int> st;//定义一个unordered_set，其中的元素类型为int
unordered_set<int> st[N];//定义一个unordered_set数组，其中有N个unordered_set
unordered_map<int, int> mp;//定义一个unordered_map
unordered_map<int, int> mp[N];//定义一个unordered_map数组，其中有N个unordered_map
```

-   `unordered_map/unordered_set`的常用内置函数

```c++
    //unordered_map/unordered_set中的常用内置函数
    unordered_set<int> st;
unordered_map<int, int> mp;
st.insert(5);//插入元素5
st.insert(6);//同上
st.insert(7);//同上
st.size();//返回unordered_set中元素的个数
st.empty();//返回unordered_set是否为空，若为空返回true否则返回false
st.erase(6);//清除元素6
st.begin();//返回unordered_set第一个元素的迭代器
st.end();//返回unordered_set最后一个元素后一个位置的迭代器
st.clear();//清空unordered_set
mp.insert(make_pair(1, 2));//插入元素{1, 2}
mp.insert({ 3, 4 });//同上
mp.size();//返回unordered_map中元素的个数
mp.empty();//返回unordered_map是否为空，若为空返回true否则返回false
mp.erase(3);//清除元素{3, 4}
mp.begin();//返回unordered_map第一个元素的迭代器
mp.end();//返回unordered_map最后一个元素后一个位置的迭代器
mp.clear();//清空unordered_map

//使用迭代器遍历
for (unordered_set<int>::iterator it = st.begin(); it != st.end(); it++)
cout << (*it) << ' ';
//for_each遍历(C++11)
for (auto x : st)
cout << x << ' ';

//使用迭代器遍历
for (unordered_map<int, int>::iterator it = mp.begin(); it != mp.end(); it++)
cout << (*it).first << ' ' << (*it).second << endl;
//for_each遍历(C++11)
for (auto x : mp)
cout << x.first << ' ' << x.second << endl;
//扩展推断范围的for_each遍历(C++17)
for (auto &[k, v] : mp)
cout << k << ' ' << v << endl;
```

#### STL算法详解

C++标准库定义了一组`泛型算法`，之所以称为`泛型`指的是它们可以操作在多种容器上，**不但可以作用于标准库类型，还可以用在内置数组类型甚至其它类型的序列上。**`泛型算法`定义在`<algorithm>`头文件中，标准库还定义了一组`泛化的算术算法`(`Generalized Numeric Algorithm`)，定义在`<numeric>`头文件中。

```c++
#include <iostream>
#include <algorithm>
#include <numeric>
using namespace std;

int main()
{
//使用STL容器时将数组地址改为迭代器即可

int a[5] = { 1, 2, 3, 4, 5 };

//排序算法
sort(a, a + 5);//将区间[0, 5)内元素按字典序从小到大排序
sort(a, a + 5, greater<int>());//将区间[0, 5)内元素按字典序从大到小排序
reverse(a, a + 5);//将区间[0, 5)内元素翻转
nth_element(a, a + 3, a + 5);//将区间[0, 5)中第a + 3个数归位，即将第3大的元素放到正确的位置上，该元素前后的元素不一定有序

//查找与统计算法
find(a, a + 5, 3);//在区间[0, 5)内查找等于3的元素，返回迭代器，若不存在则返回end()
binary_search(a, a + 5, 2);//二分查找区间[0, 5)内是否存在元素2，若存在返回true否则返回false
count(a, a + 5, 3);//返回区间[0, 5)内元素3的个数

//可变序列算法
copy(a, a + 2, a + 3);//将区间[0, 2)的元素复制到以a+3开始的区间，即[3, 5)
replace(a, a + 5, 3, 4);//将区间[0, 5)内等于3的元素替换为4
fill(a, a + 5, 1);//将1写入区间[0, 5)中(初始化数组函数)
unique(a, a + 5);//将相邻元素间的重复元素全部移动至末端，返回去重之后数组最后一个元素之后的地址
remove(a, a + 5, 3);//将区间[0, 5)中的元素3移至末端，返回新数组最后一个元素之后的地址

//排列算法
next_permutation(a, a + 5);//产生下一个排列{ 1, 2, 3, 5, 4 }
prev_permutation(a, a + 5);//产生上一个排列{ 1, 2, 3, 4, 5 }

//前缀和算法
partial_sum(a, a + 5, a);//计算数组a在区间[0, 5)内的前缀和并将结果保存至数组a中

return 0;
}
```

